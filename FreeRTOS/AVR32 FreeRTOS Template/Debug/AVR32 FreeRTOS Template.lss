
AVR32 FreeRTOS Template.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00004390  80002020  80002020  00002420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80006400  80006400  00006800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80006600  80006600  00006a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000170  80006618  80006618  00006a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80006788  00006c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80006790  00006c10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80006798  00006c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000679c  00006c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         000005d8  0000001c  8000679c  00006c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00000430  00000610  00000610  00000000  2**2
                  ALLOC
 14 .heap         0000e5c0  00000a40  00000a40  00000000  2**0
                  ALLOC
 15 .comment      00000060  00000000  00000000  000071f4  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00000e08  00000000  00000000  00007254  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001afd  00000000  00000000  0000805c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00029b50  00000000  00000000  00009b59  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000052dd  00000000  00000000  000336a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   0000fc9f  00000000  00000000  00038986  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00001fd4  00000000  00000000  00048628  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00008277  00000000  00000000  0004a5fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    00004f60  00000000  00000000  00052873  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 014aee84  00000000  00000000  000577d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00000e60  00000000  00000000  01506657  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

80002004 <_init>:
80002004:	eb cd 40 40 	pushm	r6,lr
80002008:	48 26       	lddpc	r6,80002010 <_init+0xc>
8000200a:	1e 26       	rsub	r6,pc
8000200c:	c0 48       	rjmp	80002014 <_init+0x10>
8000200e:	d7 03       	nop
80002010:	80 00       	ld.sh	r0,r0[0x0]
80002012:	1f ee       	ld.ub	lr,pc[0x6]
80002014:	c5 ec       	rcall	800020d0 <frame_dummy>
80002016:	e0 a0 21 c1 	rcall	80006398 <__do_global_ctors_aux>
8000201a:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002020 <_stext>:
80002020:	30 07       	mov	r7,0
80002022:	49 5a       	lddpc	r10,80002074 <_stext+0x54>
80002024:	5b fa       	cp.w	r10,-1
80002026:	f4 0d 17 10 	movne	sp,r10
8000202a:	49 4b       	lddpc	r11,80002078 <_stext+0x58>
8000202c:	49 4c       	lddpc	r12,8000207c <_stext+0x5c>
8000202e:	18 3b       	cp.w	r11,r12
80002030:	c0 60       	breq	8000203c <_stext+0x1c>
80002032:	49 4a       	lddpc	r10,80002080 <_stext+0x60>
80002034:	b7 09       	ld.d	r8,r11++
80002036:	b9 28       	st.d	r12++,r8
80002038:	14 3c       	cp.w	r12,r10
8000203a:	cf d5       	brlt	80002034 <_stext+0x14>
8000203c:	49 2a       	lddpc	r10,80002084 <_stext+0x64>
8000203e:	49 1c       	lddpc	r12,80002080 <_stext+0x60>
80002040:	30 08       	mov	r8,0
80002042:	30 09       	mov	r9,0
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf e5       	brlt	80002044 <_stext+0x24>
8000204a:	e0 a0 11 65 	rcall	80004314 <_init_startup>
8000204e:	fe cc ba 4e 	sub	r12,pc,-17842
80002052:	e0 a0 15 7b 	rcall	80004b48 <atexit>
80002056:	cd 7f       	rcall	80002004 <_init>
80002058:	1a 9c       	mov	r12,sp
8000205a:	30 0b       	mov	r11,0
8000205c:	e0 a0 1a b8 	rcall	800055cc <_init_argv>
80002060:	5b fc       	cp.w	r12,-1
80002062:	f9 bc 00 00 	moveq	r12,0
80002066:	f9 ba 00 00 	moveq	r10,0
8000206a:	14 1d       	sub	sp,r10
8000206c:	e0 a0 15 0a 	rcall	80004a80 <main>
80002070:	e0 a0 15 74 	rcall	80004b58 <exit>
80002074:	00 01       	add	r1,r0
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	67 88       	ld.w	r8,r3[0x60]
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	00 00       	add	r0,r0
80002082:	05 f8       	ld.ub	r8,r2[0x7]
80002084:	00 00       	add	r0,r0
80002086:	0a 40       	or	r0,r5

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	48 e8       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
8000208c:	11 89       	ld.ub	r9,r8[0x0]
8000208e:	30 08       	mov	r8,0
80002090:	f0 09 18 00 	cp.b	r9,r8
80002094:	c1 41       	brne	800020bc <__do_global_dtors_aux+0x34>
80002096:	48 c8       	lddpc	r8,800020c4 <__do_global_dtors_aux+0x3c>
80002098:	48 c6       	lddpc	r6,800020c8 <__do_global_dtors_aux+0x40>
8000209a:	10 95       	mov	r5,r8
8000209c:	10 16       	sub	r6,r8
8000209e:	48 c7       	lddpc	r7,800020cc <__do_global_dtors_aux+0x44>
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x28>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x1e>
800020b6:	30 19       	mov	r9,1
800020b8:	48 28       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
800020ba:	b0 89       	st.b	r8[0x0],r9
800020bc:	d8 22       	popm	r4-r7,pc
800020be:	d7 03       	nop
800020c0:	00 00       	add	r0,r0
800020c2:	06 10       	sub	r0,r3
800020c4:	00 00       	add	r0,r0
800020c6:	00 10       	sub	r0,r0
800020c8:	00 00       	add	r0,r0
800020ca:	00 14       	sub	r4,r0
800020cc:	00 00       	add	r0,r0
800020ce:	06 14       	sub	r4,r3

800020d0 <frame_dummy>:
800020d0:	d4 01       	pushm	lr
800020d2:	48 5c       	lddpc	r12,800020e4 <frame_dummy+0x14>
800020d4:	78 08       	ld.w	r8,r12[0x0]
800020d6:	58 08       	cp.w	r8,0
800020d8:	c0 50       	breq	800020e2 <frame_dummy+0x12>
800020da:	48 48       	lddpc	r8,800020e8 <frame_dummy+0x18>
800020dc:	58 08       	cp.w	r8,0
800020de:	c0 20       	breq	800020e2 <frame_dummy+0x12>
800020e0:	5d 18       	icall	r8
800020e2:	d8 02       	popm	pc
800020e4:	00 00       	add	r0,r0
800020e6:	00 18       	sub	r8,r0
800020e8:	00 00       	add	r0,r0
	...

800020ec <board_init>:
#endif



void board_init (void)
{
800020ec:	d4 01       	pushm	lr
    gpio_configure_pin (LED0_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020ee:	30 3b       	mov	r11,3
800020f0:	32 3c       	mov	r12,35
800020f2:	f0 1f 00 0a 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED1_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020f6:	30 3b       	mov	r11,3
800020f8:	34 9c       	mov	r12,73
800020fa:	f0 1f 00 08 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED2_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020fe:	30 3b       	mov	r11,3
80002100:	32 2c       	mov	r12,34
80002102:	f0 1f 00 06 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED3_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002106:	30 3b       	mov	r11,3
80002108:	32 6c       	mov	r12,38
8000210a:	f0 1f 00 04 	mcall	80002118 <board_init+0x2c>

    gpio_configure_pin (GPIO_PUSH_BUTTON_0, (GPIO_DIR_INPUT | GPIO_PULL_UP));
8000210e:	30 4b       	mov	r11,4
80002110:	32 1c       	mov	r12,33
80002112:	f0 1f 00 02 	mcall	80002118 <board_init+0x2c>
     * the platform Xplained board has configured basic clock settings,
     * GPIO pin mapping, interrupt controller options, etc.
     */
    sensor_board_init ();
#endif
}
80002116:	d8 02       	popm	pc
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	21 1c       	sub	r12,17

8000211c <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{  
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];  
8000211c:	f8 08 16 05 	lsr	r8,r12,0x5
80002120:	a9 68       	lsl	r8,0x8
80002122:	e0 28 f0 00 	sub	r8,61440
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif    
    if (flags & GPIO_PULL_UP)
80002126:	16 99       	mov	r9,r11
80002128:	e2 19 00 04 	andl	r9,0x4,COH
8000212c:	c0 70       	breq	8000213a <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
8000212e:	30 19       	mov	r9,1
80002130:	f2 0c 09 49 	lsl	r9,r9,r12
80002134:	f1 49 00 74 	st.w	r8[116],r9
80002138:	c0 68       	rjmp	80002144 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
8000213a:	30 19       	mov	r9,1
8000213c:	f2 0c 09 49 	lsl	r9,r9,r12
80002140:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
80002144:	16 99       	mov	r9,r11
80002146:	e2 19 00 80 	andl	r9,0x80,COH
8000214a:	c2 40       	breq	80002192 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
8000214c:	16 99       	mov	r9,r11
8000214e:	e2 19 01 80 	andl	r9,0x180,COH
80002152:	c0 90       	breq	80002164 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002154:	30 19       	mov	r9,1
80002156:	f2 0c 09 49 	lsl	r9,r9,r12
8000215a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
8000215e:	f1 49 00 b8 	st.w	r8[184],r9
80002162:	c1 88       	rjmp	80002192 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
80002164:	16 99       	mov	r9,r11
80002166:	e2 19 02 80 	andl	r9,0x280,COH
8000216a:	c0 90       	breq	8000217c <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
8000216c:	30 19       	mov	r9,1
8000216e:	f2 0c 09 49 	lsl	r9,r9,r12
80002172:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002176:	f1 49 00 b8 	st.w	r8[184],r9
8000217a:	c0 c8       	rjmp	80002192 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
8000217c:	16 99       	mov	r9,r11
8000217e:	e2 19 03 80 	andl	r9,0x380,COH
80002182:	c0 80       	breq	80002192 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002184:	30 19       	mov	r9,1
80002186:	f2 0c 09 49 	lsl	r9,r9,r12
8000218a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
8000218e:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
80002192:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
80002196:	c1 50       	breq	800021c0 <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
80002198:	e2 1b 00 02 	andl	r11,0x2,COH
8000219c:	c0 70       	breq	800021aa <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
8000219e:	30 19       	mov	r9,1
800021a0:	f2 0c 09 49 	lsl	r9,r9,r12
800021a4:	f1 49 00 54 	st.w	r8[84],r9
800021a8:	c0 68       	rjmp	800021b4 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
800021aa:	30 19       	mov	r9,1
800021ac:	f2 0c 09 49 	lsl	r9,r9,r12
800021b0:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
800021b4:	30 19       	mov	r9,1
800021b6:	f2 0c 09 49 	lsl	r9,r9,r12
800021ba:	f1 49 00 44 	st.w	r8[68],r9
800021be:	c0 68       	rjmp	800021ca <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
800021c0:	30 19       	mov	r9,1
800021c2:	f2 0c 09 49 	lsl	r9,r9,r12
800021c6:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
800021ca:	30 19       	mov	r9,1
800021cc:	f2 0c 09 4c 	lsl	r12,r9,r12
800021d0:	91 1c       	st.w	r8[0x4],r12
}
800021d2:	5e fc       	retal	r12

800021d4 <gpio_get_pin_value>:
    gpio_port->gpers = mask;
}

int gpio_get_pin_value(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800021d4:	f8 08 16 05 	lsr	r8,r12,0x5
800021d8:	a9 68       	lsl	r8,0x8
800021da:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800021de:	71 88       	ld.w	r8,r8[0x60]
800021e0:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800021e4:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800021e8:	5e fc       	retal	r12

800021ea <gpio_set_pin_high>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_set_pin_high(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800021ea:	f8 08 16 05 	lsr	r8,r12,0x5
800021ee:	a9 68       	lsl	r8,0x8
800021f0:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
800021f4:	30 19       	mov	r9,1
800021f6:	f2 0c 09 4c 	lsl	r12,r9,r12
800021fa:	f1 4c 00 54 	st.w	r8[84],r12
}
800021fe:	5e fc       	retal	r12

80002200 <gpio_set_pin_low>:
}


void gpio_set_pin_low(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002200:	f8 08 16 05 	lsr	r8,r12,0x5
80002204:	a9 68       	lsl	r8,0x8
80002206:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
8000220a:	30 19       	mov	r9,1
8000220c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002210:	f1 4c 00 58 	st.w	r8[88],r12
}
80002214:	5e fc       	retal	r12

80002216 <gpio_toggle_pin>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_toggle_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002216:	f8 08 16 05 	lsr	r8,r12,0x5
8000221a:	a9 68       	lsl	r8,0x8
8000221c:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrt  = 1 << (pin & 0x1F); // Toggle the I/O line.
80002220:	30 19       	mov	r9,1
80002222:	f2 0c 09 4c 	lsl	r12,r9,r12
80002226:	f1 4c 00 5c 	st.w	r8[92],r12
}
8000222a:	5e fc       	retal	r12

8000222c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000222c:	c0 08       	rjmp	8000222c <_unhandled_interrupt>
8000222e:	d7 03       	nop

80002230 <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002230:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
80002234:	48 99       	lddpc	r9,80002258 <INTC_register_interrupt+0x28>
80002236:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000223a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000223e:	72 19       	ld.w	r9,r9[0x4]
80002240:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_level & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
80002244:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002248:	48 59       	lddpc	r9,8000225c <INTC_register_interrupt+0x2c>
8000224a:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
8000224e:	fe 79 08 00 	mov	r9,-63488
80002252:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
80002256:	5e fc       	retal	r12
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	66 18       	ld.w	r8,r3[0x4]
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	65 3c       	ld.w	r12,r2[0x4c]

80002260 <INTC_init_interrupts>:
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
}

void INTC_init_interrupts(void)
{
80002260:	d4 21       	pushm	r4-r7,lr
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
80002262:	49 18       	lddpc	r8,800022a4 <INTC_init_interrupts+0x44>
80002264:	e3 b8 00 01 	mtsr	0x4,r8
80002268:	49 0e       	lddpc	lr,800022a8 <INTC_init_interrupts+0x48>
8000226a:	30 07       	mov	r7,0
8000226c:	0e 94       	mov	r4,r7
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000226e:	49 0c       	lddpc	r12,800022ac <INTC_init_interrupts+0x4c>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80002270:	49 08       	lddpc	r8,800022b0 <INTC_init_interrupts+0x50>
80002272:	70 05       	ld.w	r5,r8[0x0]
80002274:	fe 76 08 00 	mov	r6,-63488
80002278:	c1 08       	rjmp	80002298 <INTC_init_interrupts+0x38>
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
8000227a:	08 98       	mov	r8,r4
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000227c:	7c 1b       	ld.w	r11,lr[0x4]

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000227e:	7c 0a       	ld.w	r10,lr[0x0]
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
80002280:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
80002284:	2f f8       	sub	r8,-1
80002286:	10 3a       	cp.w	r10,r8
80002288:	fe 9b ff fc 	brhi	80002280 <INTC_init_interrupts+0x20>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
8000228c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
  unsigned int int_grp, int_req;

  INTC_init_evba();

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002290:	2f f7       	sub	r7,-1
80002292:	2f 8e       	sub	lr,-8
80002294:	59 e7       	cp.w	r7,30
80002296:	c0 50       	breq	800022a0 <INTC_init_interrupts+0x40>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
80002298:	7c 08       	ld.w	r8,lr[0x0]
8000229a:	58 08       	cp.w	r8,0
8000229c:	ce f1       	brne	8000227a <INTC_init_interrupts+0x1a>
8000229e:	cf 7b       	rjmp	8000228c <INTC_init_interrupts+0x2c>
800022a0:	d8 22       	popm	r4-r7,pc
800022a2:	00 00       	add	r0,r0
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	64 00       	ld.w	r0,r2[0x0]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	66 18       	ld.w	r8,r3[0x4]
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	22 2c       	sub	r12,34
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	65 3c       	ld.w	r12,r2[0x4c]

800022b4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_level)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
  // pass a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800022b4:	fe 78 08 00 	mov	r8,-63488
800022b8:	e0 69 00 83 	mov	r9,131
800022bc:	f2 0c 01 0c 	sub	r12,r9,r12
800022c0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
800022c4:	f2 ca ff c0 	sub	r10,r9,-64
800022c8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
800022cc:	58 08       	cp.w	r8,0
800022ce:	c0 21       	brne	800022d2 <_get_interrupt_handler+0x1e>
800022d0:	5e fd       	retal	0
800022d2:	f0 08 12 00 	clz	r8,r8
800022d6:	48 5a       	lddpc	r10,800022e8 <_get_interrupt_handler+0x34>
800022d8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800022dc:	f0 08 11 1f 	rsub	r8,r8,31
800022e0:	72 19       	ld.w	r9,r9[0x4]
800022e2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
800022e6:	5e fc       	retal	r12
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	66 18       	ld.w	r8,r3[0x4]

800022ec <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800022ec:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800022ee:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800022f2:	99 a8       	st.w	r12[0x28],r8
}
800022f4:	5e fc       	retal	r12
800022f6:	d7 03       	nop

800022f8 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800022f8:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800022fa:	ec 5b bb 9f 	cp.w	r11,899999
800022fe:	e0 8b 00 04 	brhi	80002306 <pm_enable_osc0_crystal+0xe>
80002302:	30 4b       	mov	r11,4
80002304:	c1 38       	rjmp	8000232a <pm_enable_osc0_crystal+0x32>
80002306:	e0 68 c6 bf 	mov	r8,50879
8000230a:	ea 18 00 2d 	orh	r8,0x2d
8000230e:	10 3b       	cp.w	r11,r8
80002310:	e0 8b 00 04 	brhi	80002318 <pm_enable_osc0_crystal+0x20>
80002314:	30 5b       	mov	r11,5
80002316:	c0 a8       	rjmp	8000232a <pm_enable_osc0_crystal+0x32>
80002318:	e0 68 12 00 	mov	r8,4608
8000231c:	ea 18 00 7a 	orh	r8,0x7a
80002320:	10 3b       	cp.w	r11,r8
80002322:	f9 bb 03 06 	movlo	r11,6
80002326:	f9 bb 02 07 	movhs	r11,7
8000232a:	f0 1f 00 02 	mcall	80002330 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000232e:	d8 02       	popm	pc
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	22 ec       	sub	r12,46

80002334 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002334:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002336:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000233a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000233c:	78 08       	ld.w	r8,r12[0x0]
8000233e:	a3 a8       	sbr	r8,0x2
80002340:	99 08       	st.w	r12[0x0],r8
}
80002342:	5e fc       	retal	r12

80002344 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002344:	79 58       	ld.w	r8,r12[0x54]
80002346:	e2 18 00 80 	andl	r8,0x80,COH
8000234a:	cf d0       	breq	80002344 <pm_wait_for_clk0_ready>
}
8000234c:	5e fc       	retal	r12
8000234e:	d7 03       	nop

80002350 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002350:	eb cd 40 80 	pushm	r7,lr
80002354:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002356:	f0 1f 00 04 	mcall	80002364 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000235a:	0e 9c       	mov	r12,r7
8000235c:	f0 1f 00 03 	mcall	80002368 <pm_enable_clk0+0x18>
}
80002360:	e3 cd 80 80 	ldm	sp++,r7,pc
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	23 34       	sub	r4,51
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	23 44       	sub	r4,52

8000236c <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000236c:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000236e:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002372:	99 08       	st.w	r12[0x0],r8
}
80002374:	5e fc       	retal	r12
80002376:	d7 03       	nop

80002378 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002378:	eb cd 40 c0 	pushm	r6-r7,lr
8000237c:	18 97       	mov	r7,r12
8000237e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002380:	f0 1f 00 06 	mcall	80002398 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002384:	0c 9b       	mov	r11,r6
80002386:	0e 9c       	mov	r12,r7
80002388:	f0 1f 00 05 	mcall	8000239c <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000238c:	30 1b       	mov	r11,1
8000238e:	0e 9c       	mov	r12,r7
80002390:	f0 1f 00 04 	mcall	800023a0 <pm_switch_to_osc0+0x28>
}
80002394:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	22 f8       	sub	r8,47
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	23 50       	sub	r0,53
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	23 6c       	sub	r12,54

800023a4 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3C device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
800023a4:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
800023a6:	58 0c       	cp.w	r12,0
800023a8:	c0 40       	breq	800023b0 <pcl_switch_to_osc+0xc>
800023aa:	fe 7c d8 f0 	mov	r12,-10000
800023ae:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
800023b0:	fe 7c 0c 00 	mov	r12,-62464
800023b4:	f0 1f 00 02 	mcall	800023bc <pcl_switch_to_osc+0x18>
800023b8:	d8 0a       	popm	pc,r12=0
800023ba:	00 00       	add	r0,r0
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	23 78       	sub	r8,55

800023c0 <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
800023c0:	5e ff       	retal	1

800023c2 <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
800023c2:	5e fd       	retal	0

800023c4 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
800023c4:	fe 68 00 00 	mov	r8,-131072
800023c8:	70 09       	ld.w	r9,r8[0x0]
800023ca:	a7 d9       	cbr	r9,0x7
800023cc:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
800023ce:	70 09       	ld.w	r9,r8[0x0]
800023d0:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023d4:	e0 19 ff 80 	andl	r9,0xff80
800023d8:	f9 e9 10 09 	or	r9,r12,r9
800023dc:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
800023de:	70 09       	ld.w	r9,r8[0x0]
800023e0:	a7 b9       	sbr	r9,0x7
800023e2:	91 09       	st.w	r8[0x0],r9
}
800023e4:	5e fc       	retal	r12

800023e6 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
800023e6:	fe 68 00 00 	mov	r8,-131072
800023ea:	70 0c       	ld.w	r12,r8[0x0]
}
800023ec:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023f0:	5e fc       	retal	r12

800023f2 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
800023f2:	fe 68 00 00 	mov	r8,-131072
800023f6:	70 8c       	ld.w	r12,r8[0x20]
}
800023f8:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
800023fc:	5e fc       	retal	r12

800023fe <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
800023fe:	fe 68 00 00 	mov	r8,-131072
80002402:	70 8c       	ld.w	r12,r8[0x20]
}
80002404:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
80002408:	5e fc       	retal	r12
8000240a:	d7 03       	nop

8000240c <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload,	uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
8000240c:	48 28       	lddpc	r8,80002414 <udd_set_setup_payload+0x8>
8000240e:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
80002410:	b0 6b       	st.h	r8[0xc],r11
}
80002412:	5e fc       	retal	r12
80002414:	00 00       	add	r0,r0
80002416:	0a 0c       	add	r12,r5

80002418 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
80002418:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000241c:	a3 68       	lsl	r8,0x2
8000241e:	e0 38 fe 40 	sub	r8,130624
80002422:	70 0c       	ld.w	r12,r8[0x0]
}
80002424:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
80002428:	5e fc       	retal	r12
8000242a:	d7 03       	nop

8000242c <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
8000242c:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index)
80002430:	30 38       	mov	r8,3
80002432:	f0 0c 18 00 	cp.b	r12,r8
80002436:	e0 8b 00 35 	brhi	800024a0 <udd_ep_set_halt+0x74>
		return false;

	ptr_job = &udd_ep_job[index - 1];
8000243a:	18 99       	mov	r9,r12
8000243c:	f8 c8 00 01 	sub	r8,r12,1
80002440:	a5 68       	lsl	r8,0x4
80002442:	49 9a       	lddpc	r10,800024a4 <udd_ep_set_halt+0x78>
80002444:	f4 08 00 08 	add	r8,r10,r8
	if (ptr_job->busy == true) {
80002448:	70 0a       	ld.w	r10,r8[0x0]
8000244a:	58 0a       	cp.w	r10,0
8000244c:	c2 a5       	brlt	800024a0 <udd_ep_set_halt+0x74>
		return false;	// Job on going, stall impossible
	}
	
	if (0 != udd_nb_busy_bank(index)) {
8000244e:	a3 69       	lsl	r9,0x2
80002450:	fe 6b 01 30 	mov	r11,-130768
80002454:	f2 0b 00 0a 	add	r10,r9,r11
80002458:	74 0a       	ld.w	r10,r10[0x0]
8000245a:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
8000245e:	c1 10       	breq	80002480 <udd_ep_set_halt+0x54>
		// Wait end of transfer on USB line before stall endpoint
		// Flag a stall requested
		ptr_job->stall_requested = true;
80002460:	70 0b       	ld.w	r11,r8[0x0]
80002462:	30 1a       	mov	r10,1
80002464:	f7 da d3 81 	bfins	r11,r10,0x1c,0x1
80002468:	91 0b       	st.w	r8[0x0],r11
		udd_enable_bank_interrupt(index);
8000246a:	e0 39 fe 10 	sub	r9,130576
8000246e:	e0 68 10 00 	mov	r8,4096
80002472:	93 08       	st.w	r9[0x0],r8
		udd_enable_endpoint_interrupt(index);
80002474:	f0 0c 09 4c 	lsl	r12,r8,r12
80002478:	fe 69 00 00 	mov	r9,-131072
8000247c:	93 6c       	st.w	r9[0x18],r12
8000247e:	5e fa       	retal	r10
	} else {
		// Stall endpoint
		udd_disable_endpoint_bank_autoswitch(index);
80002480:	fe 6a 01 00 	mov	r10,-130816
80002484:	f2 0a 00 08 	add	r8,r9,r10
80002488:	70 0a       	ld.w	r10,r8[0x0]
8000248a:	a9 da       	cbr	r10,0x9
8000248c:	91 0a       	st.w	r8[0x0],r10
		udd_enable_stall_handshake(index);
8000248e:	e0 39 fe 10 	sub	r9,130576
80002492:	e8 68 00 00 	mov	r8,524288
80002496:	93 08       	st.w	r9[0x0],r8
		udd_reset_data_toggle(index);
80002498:	e4 68 00 00 	mov	r8,262144
8000249c:	93 08       	st.w	r9[0x0],r8
8000249e:	5e ff       	retal	1
800024a0:	5e fd       	retal	0
800024a2:	00 00       	add	r0,r0
800024a4:	00 00       	add	r0,r0
800024a6:	07 28       	ld.uh	r8,r3++

800024a8 <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
800024a8:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
800024aa:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800024ae:	30 38       	mov	r8,3
800024b0:	f0 0c 18 00 	cp.b	r12,r8
800024b4:	e0 88 00 03 	brls	800024ba <udd_ep_clear_halt+0x12>
800024b8:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];
800024ba:	f8 c8 00 01 	sub	r8,r12,1
800024be:	a5 68       	lsl	r8,0x4
800024c0:	49 69       	lddpc	r9,80002518 <udd_ep_clear_halt+0x70>
800024c2:	f2 08 00 08 	add	r8,r9,r8

	if (Is_udd_endpoint_stall_requested(ep)	// Endpoint stalled
800024c6:	a3 6c       	lsl	r12,0x2
800024c8:	fe 6a 01 c0 	mov	r10,-130624
800024cc:	f8 0a 00 09 	add	r9,r12,r10
800024d0:	72 09       	ld.w	r9,r9[0x0]
800024d2:	e6 19 00 08 	andh	r9,0x8,COH
800024d6:	c0 51       	brne	800024e0 <udd_ep_clear_halt+0x38>
			|| ptr_job->stall_requested) {	// Endpoint stall is requested
800024d8:	70 09       	ld.w	r9,r8[0x0]
800024da:	e6 19 10 00 	andh	r9,0x1000,COH
800024de:	c1 c0       	breq	80002516 <udd_ep_clear_halt+0x6e>
		// Remove request to stall
		ptr_job->stall_requested = false;
800024e0:	70 09       	ld.w	r9,r8[0x0]
800024e2:	30 0a       	mov	r10,0
800024e4:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
800024e8:	91 09       	st.w	r8[0x0],r9
		// Remove stall
		udd_disable_stall_handshake(ep);
800024ea:	fe 6a 02 20 	mov	r10,-130528
800024ee:	f8 0a 00 09 	add	r9,r12,r10
800024f2:	e8 6a 00 00 	mov	r10,524288
800024f6:	93 0a       	st.w	r9[0x0],r10
		udd_enable_endpoint_bank_autoswitch(ep);	
800024f8:	e0 3c ff 00 	sub	r12,130816
800024fc:	78 09       	ld.w	r9,r12[0x0]
800024fe:	a9 b9       	sbr	r9,0x9
80002500:	99 09       	st.w	r12[0x0],r9
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
80002502:	70 09       	ld.w	r9,r8[0x0]
80002504:	58 09       	cp.w	r9,0
80002506:	c0 84       	brge	80002516 <udd_ep_clear_halt+0x6e>
			ptr_job->busy = false;
80002508:	30 0a       	mov	r10,0
8000250a:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
8000250e:	91 09       	st.w	r8[0x0],r9
			ptr_job->call_nohalt();
80002510:	70 38       	ld.w	r8,r8[0xc]
80002512:	5d 18       	icall	r8
80002514:	da 0a       	popm	pc,r12=1
80002516:	da 0a       	popm	pc,r12=1
80002518:	00 00       	add	r0,r0
8000251a:	07 28       	ld.uh	r8,r3++

8000251c <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
8000251c:	30 59       	mov	r9,5
8000251e:	48 58       	lddpc	r8,80002530 <udd_ctrl_stall_data+0x14>
80002520:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
80002522:	e8 69 00 00 	mov	r9,524288
80002526:	fe 68 01 f0 	mov	r8,-130576
8000252a:	91 09       	st.w	r8[0x0],r9
}
8000252c:	5e fc       	retal	r12
8000252e:	00 00       	add	r0,r0
80002530:	00 00       	add	r0,r0
80002532:	07 5c       	ld.sh	r12,--r3

80002534 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
80002534:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
80002536:	48 48       	lddpc	r8,80002544 <udd_ctrl_endofrequest+0x10>
80002538:	70 48       	ld.w	r8,r8[0x10]
8000253a:	58 08       	cp.w	r8,0
8000253c:	c0 20       	breq	80002540 <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
8000253e:	5d 18       	icall	r8
80002540:	d8 02       	popm	pc
80002542:	00 00       	add	r0,r0
80002544:	00 00       	add	r0,r0
80002546:	0a 0c       	add	r12,r5

80002548 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort)
{
80002548:	d4 01       	pushm	lr
8000254a:	16 99       	mov	r9,r11
	if (ptr_job->busy == false)
8000254c:	78 08       	ld.w	r8,r12[0x0]
8000254e:	58 08       	cp.w	r8,0
80002550:	c0 b4       	brge	80002566 <udd_ep_finish_job+0x1e>
		return;	// No on-going job
	ptr_job->busy = false;
80002552:	30 0a       	mov	r10,0
80002554:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80002558:	99 08       	st.w	r12[0x0],r8
	if (NULL == ptr_job->call_trans)
8000255a:	78 38       	ld.w	r8,r12[0xc]
8000255c:	58 08       	cp.w	r8,0
8000255e:	c0 40       	breq	80002566 <udd_ep_finish_job+0x1e>
		return;	// No callback linked to job
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
80002560:	78 2b       	ld.w	r11,r12[0x8]
80002562:	12 9c       	mov	r12,r9
80002564:	5d 18       	icall	r8
80002566:	d8 02       	popm	pc

80002568 <udd_ep_abort_job>:
	}
}


static void udd_ep_abort_job(udd_ep_id_t ep)
{
80002568:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
8000256a:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000256e:	20 18       	sub	r8,1
80002570:	a5 68       	lsl	r8,0x4
80002572:	30 1b       	mov	r11,1
80002574:	48 3c       	lddpc	r12,80002580 <udd_ep_abort_job+0x18>
80002576:	10 0c       	add	r12,r8
80002578:	f0 1f 00 03 	mcall	80002584 <udd_ep_abort_job+0x1c>
}
8000257c:	d8 02       	popm	pc
8000257e:	00 00       	add	r0,r0
80002580:	00 00       	add	r0,r0
80002582:	07 28       	ld.uh	r8,r3++
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	25 48       	sub	r8,84

80002588 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
80002588:	d4 01       	pushm	lr
	udd_disable_endpoint(ep & USB_EP_ADDR_MASK);
8000258a:	fe 69 00 00 	mov	r9,-131072
8000258e:	72 7b       	ld.w	r11,r9[0x1c]
80002590:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
80002594:	30 1a       	mov	r10,1
80002596:	f4 08 09 4a 	lsl	r10,r10,r8
8000259a:	5c da       	com	r10
8000259c:	16 6a       	and	r10,r11
8000259e:	93 7a       	st.w	r9[0x1c],r10
	udd_unallocate_memory(ep & USB_EP_ADDR_MASK);
800025a0:	a3 68       	lsl	r8,0x2
800025a2:	e0 38 ff 00 	sub	r8,130816
800025a6:	70 09       	ld.w	r9,r8[0x0]
800025a8:	a1 d9       	cbr	r9,0x1
800025aa:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
800025ac:	f0 1f 00 02 	mcall	800025b4 <udd_ep_free+0x2c>
}
800025b0:	d8 02       	popm	pc
800025b2:	00 00       	add	r0,r0
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	25 68       	sub	r8,86

800025b8 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
800025b8:	eb cd 40 e0 	pushm	r5-r7,lr
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
800025bc:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (ep > USB_DEVICE_MAX_EP)
800025c0:	30 39       	mov	r9,3
800025c2:	f2 08 18 00 	cp.b	r8,r9
800025c6:	e0 8b 00 88 	brhi	800026d6 <udd_ep_alloc+0x11e>
		return false;
	if (Is_udd_endpoint_enabled(ep))
800025ca:	fe 69 00 00 	mov	r9,-131072
800025ce:	72 79       	ld.w	r9,r9[0x1c]
800025d0:	30 17       	mov	r7,1
800025d2:	ee 08 09 47 	lsl	r7,r7,r8
800025d6:	ef e9 00 09 	and	r9,r7,r9
800025da:	c7 e1       	brne	800026d6 <udd_ep_alloc+0x11e>
		return false;

	// Bank choise
	switch(bmAttributes&USB_EP_TYPE_MASK) {
800025dc:	f3 db c0 02 	bfextu	r9,r11,0x0,0x2
800025e0:	58 19       	cp.w	r9,1
800025e2:	c7 a5       	brlt	800026d6 <udd_ep_alloc+0x11e>
800025e4:	58 29       	cp.w	r9,2
800025e6:	e0 8a 00 06 	brle	800025f2 <udd_ep_alloc+0x3a>
800025ea:	58 39       	cp.w	r9,3
800025ec:	c7 51       	brne	800026d6 <udd_ep_alloc+0x11e>
800025ee:	30 06       	mov	r6,0
800025f0:	c0 28       	rjmp	800025f4 <udd_ep_alloc+0x3c>
800025f2:	30 16       	mov	r6,1
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);
		   
	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
800025f4:	f0 09 15 02 	lsl	r9,r8,0x2
800025f8:	e0 39 ff 00 	sub	r9,130816
800025fc:	72 0e       	ld.w	lr,r9[0x0]
800025fe:	5c 7a       	castu.h	r10
80002600:	30 85       	mov	r5,8
80002602:	f4 05 0c 4a 	max	r10,r10,r5
80002606:	e0 65 04 00 	mov	r5,1024
8000260a:	f4 05 0d 4a 	min	r10,r10,r5
8000260e:	a1 7a       	lsl	r10,0x1
80002610:	20 1a       	sub	r10,1
80002612:	f4 0a 12 00 	clz	r10,r10
80002616:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
8000261a:	ab 7b       	lsl	r11,0xb
8000261c:	e2 1b 18 00 	andl	r11,0x1800,COH
80002620:	f7 ec 10 8c 	or	r12,r11,r12<<0x8
80002624:	f4 0b 11 1c 	rsub	r11,r10,28
80002628:	f9 eb 10 4b 	or	r11,r12,r11<<0x4
8000262c:	f7 e6 10 2b 	or	r11,r11,r6<<0x2
80002630:	e2 1b 19 7c 	andl	r11,0x197c,COH
80002634:	1c 9a       	mov	r10,lr
80002636:	e0 1a e6 83 	andl	r10,0xe683
8000263a:	f7 ea 10 0a 	or	r10,r11,r10
8000263e:	93 0a       	st.w	r9[0x0],r10
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
80002640:	5c 87       	casts.h	r7

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
80002642:	30 29       	mov	r9,2
80002644:	f2 08 18 00 	cp.b	r8,r9
80002648:	e0 8b 00 1d 	brhi	80002682 <udd_ep_alloc+0xca>
8000264c:	fe 6a 01 0c 	mov	r10,-130804
80002650:	30 39       	mov	r9,3
		if (Is_udd_endpoint_enabled(i)) {
80002652:	fe 6c 00 00 	mov	r12,-131072
80002656:	30 16       	mov	r6,1
80002658:	78 7e       	ld.w	lr,r12[0x1c]
8000265a:	ec 09 09 4b 	lsl	r11,r6,r9
8000265e:	f7 ee 00 0e 	and	lr,r11,lr
80002662:	c0 b0       	breq	80002678 <udd_ep_alloc+0xc0>
			ep_allocated |= 1 << i;
80002664:	f7 e7 10 07 	or	r7,r11,r7
80002668:	5c 87       	casts.h	r7
			udd_disable_endpoint(i);
8000266a:	78 7e       	ld.w	lr,r12[0x1c]
8000266c:	5c db       	com	r11
8000266e:	1c 6b       	and	r11,lr
80002670:	99 7b       	st.w	r12[0x1c],r11
			udd_unallocate_memory(i);
80002672:	74 0b       	ld.w	r11,r10[0x0]
80002674:	a1 db       	cbr	r11,0x1
80002676:	95 0b       	st.w	r10[0x0],r11
80002678:	20 19       	sub	r9,1
8000267a:	20 4a       	sub	r10,4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
8000267c:	f2 08 18 00 	cp.b	r8,r9
80002680:	ce c3       	brcs	80002658 <udd_ep_alloc+0xa0>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
80002682:	0e 9c       	mov	r12,r7
80002684:	5c 7c       	castu.h	r12
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
80002686:	fe 6e 00 00 	mov	lr,-131072
8000268a:	30 16       	mov	r6,1
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
8000268c:	30 37       	mov	r7,3
		if (ep_allocated & (1 << i)) {
8000268e:	f8 08 08 49 	asr	r9,r12,r8
80002692:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002696:	c1 80       	breq	800026c6 <udd_ep_alloc+0x10e>
			udd_allocate_memory(i);
80002698:	f0 0b 15 02 	lsl	r11,r8,0x2
8000269c:	fe 65 01 00 	mov	r5,-130816
800026a0:	f6 05 00 09 	add	r9,r11,r5
800026a4:	72 05       	ld.w	r5,r9[0x0]
800026a6:	a1 b5       	sbr	r5,0x1
800026a8:	93 05       	st.w	r9[0x0],r5
			udd_enable_endpoint(i);
800026aa:	7c 75       	ld.w	r5,lr[0x1c]
800026ac:	ec 08 09 4a 	lsl	r10,r6,r8
800026b0:	0a 4a       	or	r10,r5
800026b2:	9d 7a       	st.w	lr[0x1c],r10
			if (!Is_udd_endpoint_configured(i))
800026b4:	e0 3b fe d0 	sub	r11,130768
800026b8:	76 0a       	ld.w	r10,r11[0x0]
800026ba:	e6 1a 00 04 	andh	r10,0x4,COH
800026be:	c0 c0       	breq	800026d6 <udd_ep_alloc+0x11e>
				return false;
			udd_enable_endpoint_bank_autoswitch(i);	
800026c0:	72 0a       	ld.w	r10,r9[0x0]
800026c2:	a9 ba       	sbr	r10,0x9
800026c4:	93 0a       	st.w	r9[0x0],r10
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800026c6:	2f f8       	sub	r8,-1
800026c8:	5c 58       	castu.b	r8
800026ca:	ee 08 18 00 	cp.b	r8,r7
800026ce:	fe 98 ff e0 	brls	8000268e <udd_ep_alloc+0xd6>
800026d2:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800026d6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800026da:	d7 03       	nop

800026dc <udd_sleep_mode>:
 * 
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
800026dc:	58 0c       	cp.w	r12,0
800026de:	c1 11       	brne	80002700 <udd_sleep_mode+0x24>
800026e0:	49 18       	lddpc	r8,80002724 <udd_sleep_mode+0x48>
800026e2:	11 89       	ld.ub	r9,r8[0x0]
800026e4:	30 08       	mov	r8,0
800026e6:	f0 09 18 00 	cp.b	r9,r8
800026ea:	c1 a0       	breq	8000271e <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026ec:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800026f0:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
800026f2:	48 e8       	lddpc	r8,80002728 <udd_sleep_mode+0x4c>
800026f4:	11 9a       	ld.ub	r10,r8[0x1]
800026f6:	2f fa       	sub	r10,-1
800026f8:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026fa:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800026fe:	c1 08       	rjmp	8000271e <udd_sleep_mode+0x42>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
80002700:	48 98       	lddpc	r8,80002724 <udd_sleep_mode+0x48>
80002702:	11 89       	ld.ub	r9,r8[0x0]
80002704:	30 08       	mov	r8,0
80002706:	f0 09 18 00 	cp.b	r9,r8
8000270a:	c0 a1       	brne	8000271e <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000270c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002710:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
80002712:	48 68       	lddpc	r8,80002728 <udd_sleep_mode+0x4c>
80002714:	11 9a       	ld.ub	r10,r8[0x1]
80002716:	20 1a       	sub	r10,1
80002718:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000271a:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
8000271e:	48 28       	lddpc	r8,80002724 <udd_sleep_mode+0x48>
80002720:	b0 8c       	st.b	r8[0x0],r12
}
80002722:	5e fc       	retal	r12
80002724:	00 00       	add	r0,r0
80002726:	07 58       	ld.sh	r8,--r3
80002728:	00 00       	add	r0,r0
8000272a:	0a 24       	rsub	r4,r5

8000272c <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
8000272c:	d4 01       	pushm	lr
	otg_unfreeze_clock();
8000272e:	fe 68 00 00 	mov	r8,-131072
80002732:	f0 f9 08 00 	ld.w	r9,r8[2048]
80002736:	af c9       	cbr	r9,0xe
80002738:	f1 49 08 00 	st.w	r8[2048],r9
	// Detach device from the bus
	udd_detach_device();
8000273c:	70 09       	ld.w	r9,r8[0x0]
8000273e:	a9 a9       	sbr	r9,0x8
80002740:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
80002742:	30 0c       	mov	r12,0
80002744:	f0 1f 00 02 	mcall	8000274c <udd_detach+0x20>
}
80002748:	d8 02       	popm	pc
8000274a:	00 00       	add	r0,r0
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	26 dc       	sub	r12,109

80002750 <udd_ctrl_init>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002750:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002754:	d3 03       	ssrf	0x10
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI), 
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI 
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80002756:	30 1a       	mov	r10,1
80002758:	fe 69 02 20 	mov	r9,-130528
8000275c:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000275e:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
80002762:	30 29       	mov	r9,2
80002764:	fe 68 01 60 	mov	r8,-130720
80002768:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
8000276a:	48 59       	lddpc	r9,8000277c <udd_ctrl_init+0x2c>
8000276c:	30 08       	mov	r8,0
8000276e:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
80002770:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
80002772:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
80002774:	48 39       	lddpc	r9,80002780 <udd_ctrl_init+0x30>
80002776:	93 08       	st.w	r9[0x0],r8
}
80002778:	5e fc       	retal	r12
8000277a:	00 00       	add	r0,r0
8000277c:	00 00       	add	r0,r0
8000277e:	0a 0c       	add	r12,r5
80002780:	00 00       	add	r0,r0
80002782:	07 5c       	ld.sh	r12,--r3

80002784 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
80002784:	30 39       	mov	r9,3
80002786:	48 a8       	lddpc	r8,800027ac <udd_ctrl_send_zlp_in+0x28>
80002788:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000278a:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
8000278e:	d3 03       	ssrf	0x10
	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
80002790:	fe 6a 01 60 	mov	r10,-130720
80002794:	30 19       	mov	r9,1
80002796:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
80002798:	fe 68 01 f0 	mov	r8,-130576
8000279c:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
8000279e:	30 89       	mov	r9,8
800027a0:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
800027a2:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027a4:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
800027a8:	5e fc       	retal	r12
800027aa:	00 00       	add	r0,r0
800027ac:	00 00       	add	r0,r0
800027ae:	07 5c       	ld.sh	r12,--r3

800027b0 <udd_reset_ep_ctrl>:

static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;
	// Reset USB address to 0
	udd_configure_address(0);
800027b0:	fe 68 00 00 	mov	r8,-131072
800027b4:	70 09       	ld.w	r9,r8[0x0]
800027b6:	e0 19 ff 80 	andl	r9,0xff80
800027ba:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
800027bc:	70 09       	ld.w	r9,r8[0x0]
800027be:	a7 b9       	sbr	r9,0x7
800027c0:	91 09       	st.w	r8[0x0],r9
	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
800027c2:	fe 69 01 00 	mov	r9,-130816
800027c6:	72 0b       	ld.w	r11,r9[0x0]
800027c8:	30 8c       	mov	r12,8
800027ca:	34 0a       	mov	r10,64
800027cc:	f4 0c 0c 4a 	max	r10,r10,r12
800027d0:	e0 6c 04 00 	mov	r12,1024
800027d4:	f4 0c 0d 4a 	min	r10,r10,r12
800027d8:	a1 7a       	lsl	r10,0x1
800027da:	20 1a       	sub	r10,1
800027dc:	f4 0a 12 00 	clz	r10,r10
800027e0:	f4 0a 11 1c 	rsub	r10,r10,28
800027e4:	a5 6a       	lsl	r10,0x4
800027e6:	e2 1a 19 7c 	andl	r10,0x197c,COH
800027ea:	e0 1b e6 83 	andl	r11,0xe683
800027ee:	16 4a       	or	r10,r11
800027f0:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
800027f2:	72 0a       	ld.w	r10,r9[0x0]
800027f4:	a1 ba       	sbr	r10,0x1
800027f6:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(0);
800027f8:	70 79       	ld.w	r9,r8[0x1c]
800027fa:	a1 a9       	sbr	r9,0x0
800027fc:	91 79       	st.w	r8[0x1c],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027fe:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002802:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002804:	fe 69 01 f0 	mov	r9,-130576
80002808:	30 4b       	mov	r11,4
8000280a:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
8000280c:	30 2b       	mov	r11,2
8000280e:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002810:	e0 69 10 00 	mov	r9,4096
80002814:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002816:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);
}
8000281a:	5e fc       	retal	r12

8000281c <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
8000281c:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002820:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002824:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown, 
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002826:	30 1c       	mov	r12,1
80002828:	f0 1f 00 15 	mcall	8000287c <udd_attach+0x60>
	otg_unfreeze_clock();
8000282c:	fe 67 00 00 	mov	r7,-131072
80002830:	ee f8 08 00 	ld.w	r8,r7[2048]
80002834:	af c8       	cbr	r8,0xe
80002836:	ef 48 08 00 	st.w	r7[2048],r8
#else
	// Check USB clock because the source can be a PLL
	while( !Is_clock_usable() );
#endif
	// Authorize attach if VBus is present
	udd_attach_device();
8000283a:	6e 08       	ld.w	r8,r7[0x0]
8000283c:	a9 c8       	cbr	r8,0x8
8000283e:	8f 08       	st.w	r7[0x0],r8

	// (RESET_AND_WAKEUP)
	// After the attach and the first USB suspend, the following USB Reset time can be inferior to CPU restart clock time.
	// Thus, the USB Reset state is not detected and endpoint control is not allocated
	// In this case, a Reset is do automatically after attach.
	udc_reset();	// Reset USB Device Stack Core
80002840:	f0 1f 00 10 	mcall	80002880 <udd_attach+0x64>
	udd_reset_ep_ctrl();	// Reset endpoint control
80002844:	f0 1f 00 10 	mcall	80002884 <udd_attach+0x68>
	udd_ctrl_init();	// Reset endpoint control management
80002848:	f0 1f 00 10 	mcall	80002888 <udd_attach+0x6c>

	// Enable USB line events
	udd_enable_reset_interrupt();
8000284c:	30 8b       	mov	r11,8
8000284e:	8f 6b       	st.w	r7[0x18],r11
	udd_enable_suspend_interrupt();
80002850:	30 19       	mov	r9,1
80002852:	8f 69       	st.w	r7[0x18],r9
	udd_enable_wake_up_interrupt();
80002854:	31 08       	mov	r8,16
80002856:	8f 68       	st.w	r7[0x18],r8
	udd_enable_sof_interrupt();
80002858:	30 4a       	mov	r10,4
8000285a:	8f 6a       	st.w	r7[0x18],r10
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
8000285c:	8f 2b       	st.w	r7[0x8],r11
	udd_ack_sof();
8000285e:	8f 2a       	st.w	r7[0x8],r10
	udd_ack_msof();
80002860:	30 2a       	mov	r10,2
80002862:	8f 2a       	st.w	r7[0x8],r10

	// The first suspend interrupt must be forced
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
80002864:	8f 29       	st.w	r7[0x8],r9
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
#endif
	udd_ack_wake_up();
80002866:	8f 28       	st.w	r7[0x8],r8
	otg_freeze_clock();
80002868:	ee f8 08 00 	ld.w	r8,r7[2048]
8000286c:	af a8       	sbr	r8,0xe
8000286e:	ef 48 08 00 	st.w	r7[2048],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002872:	e3 b6 00 00 	mtsr	0x0,r6
	cpu_irq_restore(flags);
}
80002876:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	26 dc       	sub	r12,109
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	39 d4       	mov	r4,-99
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	27 b0       	sub	r0,123
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	27 50       	sub	r0,117

8000288c <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
8000288c:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002890:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002894:	d3 03       	ssrf	0x10
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
80002896:	30 1a       	mov	r10,1
80002898:	fe 69 02 20 	mov	r9,-130528
8000289c:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000289e:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
800028a2:	4c 38       	lddpc	r8,800029ac <udd_ctrl_in_sent+0x120>
800028a4:	70 08       	ld.w	r8,r8[0x0]
800028a6:	58 38       	cp.w	r8,3
800028a8:	c0 71       	brne	800028b6 <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
800028aa:	f0 1f 00 42 	mcall	800029b0 <udd_ctrl_in_sent+0x124>
		// Reinitializes control endpoint management
		udd_ctrl_init();
800028ae:	f0 1f 00 42 	mcall	800029b4 <udd_ctrl_in_sent+0x128>
		return;
800028b2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
800028b6:	4c 18       	lddpc	r8,800029b8 <udd_ctrl_in_sent+0x12c>
800028b8:	90 68       	ld.sh	r8,r8[0xc]
800028ba:	4c 19       	lddpc	r9,800029bc <udd_ctrl_in_sent+0x130>
800028bc:	92 07       	ld.sh	r7,r9[0x0]
800028be:	f0 07 01 07 	sub	r7,r8,r7
800028c2:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
800028c4:	c3 b1       	brne	8000293a <udd_ctrl_in_sent+0xae>
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
800028c6:	4b f9       	lddpc	r9,800029c0 <udd_ctrl_in_sent+0x134>
800028c8:	13 8a       	ld.ub	r10,r9[0x0]
800028ca:	30 09       	mov	r9,0
800028cc:	f2 0a 18 00 	cp.b	r10,r9
800028d0:	c1 21       	brne	800028f4 <udd_ctrl_in_sent+0x68>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800028d2:	30 49       	mov	r9,4
800028d4:	4b 68       	lddpc	r8,800029ac <udd_ctrl_in_sent+0x120>
800028d6:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800028d8:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800028dc:	d3 03       	ssrf	0x10
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
800028de:	31 08       	mov	r8,16
800028e0:	fe 6a 01 60 	mov	r10,-130720
800028e4:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
800028e6:	fe 6a 01 f0 	mov	r10,-130576
800028ea:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800028ec:	e3 b9 00 00 	mtsr	0x0,r9
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
800028f0:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
800028f4:	4b 19       	lddpc	r9,800029b8 <udd_ctrl_in_sent+0x12c>
800028f6:	92 b9       	ld.uh	r9,r9[0x6]
800028f8:	5c 78       	castu.h	r8
800028fa:	4b 3a       	lddpc	r10,800029c4 <udd_ctrl_in_sent+0x138>
800028fc:	94 8a       	ld.uh	r10,r10[0x0]
800028fe:	14 08       	add	r8,r10
80002900:	10 39       	cp.w	r9,r8
80002902:	e0 89 00 08 	brgt	80002912 <udd_ctrl_in_sent+0x86>
								+
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
80002906:	4a d8       	lddpc	r8,800029b8 <udd_ctrl_in_sent+0x12c>
80002908:	70 5c       	ld.w	r12,r8[0x14]
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
8000290a:	58 0c       	cp.w	r12,0
8000290c:	c0 30       	breq	80002912 <udd_ctrl_in_sent+0x86>
8000290e:	5d 1c       	icall	r12
80002910:	c0 51       	brne	8000291a <udd_ctrl_in_sent+0x8e>
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun or data packet complette than send zlp on IN (note don't change DataToggle)
			udd_ctrl_payload_need_in_zlp = false;
80002912:	30 09       	mov	r9,0
80002914:	4a b8       	lddpc	r8,800029c0 <udd_ctrl_in_sent+0x134>
80002916:	b0 89       	st.b	r8[0x0],r9
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002918:	c1 18       	rjmp	8000293a <udd_ctrl_in_sent+0xae>
			udd_ctrl_payload_need_in_zlp = false;
			// nb_remain==0 allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			// Update number of total data sending by previous playlaod buffer
			udd_ctrl_prev_payload_nb_trans +=
8000291a:	4a b9       	lddpc	r9,800029c4 <udd_ctrl_in_sent+0x138>
8000291c:	4a 88       	lddpc	r8,800029bc <udd_ctrl_in_sent+0x130>
8000291e:	90 0b       	ld.sh	r11,r8[0x0]
80002920:	92 0a       	ld.sh	r10,r9[0x0]
80002922:	f6 0a 00 0a 	add	r10,r11,r10
80002926:	b2 0a       	st.h	r9[0x0],r10
					udd_ctrl_payload_nb_trans;
			// Update maangement of current playoad transfer
			udd_ctrl_payload_nb_trans = 0;
80002928:	30 09       	mov	r9,0
8000292a:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
8000292c:	4a 38       	lddpc	r8,800029b8 <udd_ctrl_in_sent+0x12c>
8000292e:	90 67       	ld.sh	r7,r8[0xc]
			// Compute if an IN ZLP must be send after IN data
			udd_ctrl_payload_need_in_zlp =
80002930:	f1 d7 c0 06 	bfextu	r8,r7,0x0,0x6
80002934:	5f 09       	sreq	r9
80002936:	4a 38       	lddpc	r8,800029c0 <udd_ctrl_in_sent+0x134>
80002938:	b0 89       	st.b	r8[0x0],r9
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
8000293a:	4a 08       	lddpc	r8,800029b8 <udd_ctrl_in_sent+0x12c>
8000293c:	70 2a       	ld.w	r10,r8[0x8]
8000293e:	4a 08       	lddpc	r8,800029bc <udd_ctrl_in_sent+0x130>
80002940:	90 09       	ld.sh	r9,r8[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002942:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
80002946:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write 
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
80002948:	fe 68 01 30 	mov	r8,-130768
8000294c:	70 08       	ld.w	r8,r8[0x0]
8000294e:	e2 18 00 02 	andl	r8,0x2,COH
80002952:	c0 91       	brne	80002964 <udd_ctrl_in_sent+0xd8>
80002954:	34 08       	mov	r8,64
80002956:	f0 07 19 00 	cp.h	r7,r8
8000295a:	f9 b7 0b 40 	movhi	r7,64
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
8000295e:	58 07       	cp.w	r7,0
80002960:	c0 91       	brne	80002972 <udd_ctrl_in_sent+0xe6>
80002962:	c1 48       	rjmp	8000298a <udd_ctrl_in_sent+0xfe>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002964:	e3 bb 00 00 	mtsr	0x0,r11
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80002968:	30 49       	mov	r9,4
8000296a:	49 18       	lddpc	r8,800029ac <udd_ctrl_in_sent+0x120>
8000296c:	91 09       	st.w	r8[0x0],r9
		return;	// Exit of IN DATA phase
8000296e:	e3 cd 80 80 	ldm	sp++,r7,pc
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002972:	5c 79       	castu.h	r9
80002974:	f4 09 00 09 	add	r9,r10,r9
80002978:	fc 18 e0 00 	movh	r8,0xe000
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
8000297c:	13 3a       	ld.ub	r10,r9++
8000297e:	10 ca       	st.b	r8++,r10
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
80002980:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002984:	ee 0a 19 00 	cp.h	r10,r7
80002988:	cf a3       	brcs	8000297c <udd_ctrl_in_sent+0xf0>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
8000298a:	48 d8       	lddpc	r8,800029bc <udd_ctrl_in_sent+0x130>
8000298c:	90 09       	ld.sh	r9,r8[0x0]
8000298e:	f2 07 00 07 	add	r7,r9,r7
80002992:	b0 07       	st.h	r8[0x0],r7

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
80002994:	30 18       	mov	r8,1
80002996:	fe 69 01 60 	mov	r9,-130720
8000299a:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
8000299c:	fe 69 01 f0 	mov	r9,-130576
800029a0:	93 08       	st.w	r9[0x0],r8
800029a2:	e3 bb 00 00 	mtsr	0x0,r11
#endif
	barrier();
800029a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800029aa:	00 00       	add	r0,r0
800029ac:	00 00       	add	r0,r0
800029ae:	07 5c       	ld.sh	r12,--r3
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	25 34       	sub	r4,83
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	27 50       	sub	r0,117
800029b8:	00 00       	add	r0,r0
800029ba:	0a 0c       	add	r12,r5
800029bc:	00 00       	add	r0,r0
800029be:	07 5a       	ld.sh	r10,--r3
800029c0:	00 00       	add	r0,r0
800029c2:	07 60       	ld.uh	r0,--r3
800029c4:	00 00       	add	r0,r0
800029c6:	07 24       	ld.uh	r4,r3++

800029c8 <udd_enable>:
	return true;
}


void udd_enable(void)
{
800029c8:	eb cd 40 c0 	pushm	r6-r7,lr
	irqflags_t flags;
	sysclk_enable_usb();
800029cc:	f0 1f 00 39 	mcall	80002ab0 <udd_enable+0xe8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800029d0:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
800029d4:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	//** Enable USB hardware
	otg_disable();
800029d6:	fe 67 00 00 	mov	r7,-131072
800029da:	ee f8 08 00 	ld.w	r8,r7[2048]
800029de:	af d8       	cbr	r8,0xf
800029e0:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_enabled();
800029e4:	ee f8 08 00 	ld.w	r8,r7[2048]
	// Check UID pin state before enter in USB device mode
	if (!Is_otg_id_device())
		return false;
#else
	// Here, only the Device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBB_IRQ, UDD_USB_INT_LEVEL);
800029e8:	30 0a       	mov	r10,0
800029ea:	e0 6b 02 20 	mov	r11,544
800029ee:	4b 2c       	lddpc	r12,80002ab4 <udd_enable+0xec>
800029f0:	f0 1f 00 32 	mcall	80002ab8 <udd_enable+0xf0>
	otg_force_device_mode();
800029f4:	ee f8 08 00 	ld.w	r8,r7[2048]
800029f8:	b9 b8       	sbr	r8,0x19
800029fa:	ef 48 08 00 	st.w	r7[2048],r8
800029fe:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a02:	b9 c8       	cbr	r8,0x18
80002a04:	ef 48 08 00 	st.w	r7[2048],r8
#endif
	otg_disable_pad();
80002a08:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a0c:	ad c8       	cbr	r8,0xc
80002a0e:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable_pad();
80002a12:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a16:	ad a8       	sbr	r8,0xc
80002a18:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable();
80002a1c:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a20:	af b8       	sbr	r8,0xf
80002a22:	ef 48 08 00 	st.w	r7[2048],r8
	otg_unfreeze_clock();
80002a26:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a2a:	af c8       	cbr	r8,0xe
80002a2c:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_clock_frozen();
80002a30:	ee f8 08 00 	ld.w	r8,r7[2048]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002a34:	4a 28       	lddpc	r8,80002abc <udd_enable+0xf4>
80002a36:	70 0a       	ld.w	r10,r8[0x0]
80002a38:	30 09       	mov	r9,0
		udd_ep_job[i].stall_requested = false;
80002a3a:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002a3e:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002a42:	91 0a       	st.w	r8[0x0],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002a44:	70 4a       	ld.w	r10,r8[0x10]
		udd_ep_job[i].stall_requested = false;
80002a46:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002a4a:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002a4e:	91 4a       	st.w	r8[0x10],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002a50:	70 8a       	ld.w	r10,r8[0x20]
		udd_ep_job[i].stall_requested = false;
80002a52:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002a56:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002a5a:	91 8a       	st.w	r8[0x20],r10

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80002a5c:	6e 08       	ld.w	r8,r7[0x0]
80002a5e:	ad c8       	cbr	r8,0xc
80002a60:	8f 08       	st.w	r7[0x0],r8
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80002a62:	6e 08       	ld.w	r8,r7[0x0]
80002a64:	e8 18 0c 00 	orl	r8,0xc00
80002a68:	8f 08       	st.w	r7[0x0],r8
#  endif
#endif
	udd_enable_vbus_interrupt();
80002a6a:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a6e:	a1 b8       	sbr	r8,0x1
80002a70:	ef 48 08 00 	st.w	r7[2048],r8
	otg_freeze_clock();
80002a74:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a78:	af a8       	sbr	r8,0xe
80002a7a:	ef 48 08 00 	st.w	r7[2048],r8
	// Always authorize asynchrone USB interrupts to exit of sleep mode
	AVR32_PM.AWEN.usb_waken = 1;
80002a7e:	fe 78 0c 00 	mov	r8,-62464
80002a82:	f0 fa 01 44 	ld.w	r10,r8[324]
80002a86:	30 1b       	mov	r11,1
80002a88:	f5 db d0 01 	bfins	r10,r11,0x0,0x1
80002a8c:	f1 4a 01 44 	st.w	r8[324],r10

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
80002a90:	48 c8       	lddpc	r8,80002ac0 <udd_enable+0xf8>
80002a92:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a94:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002a98:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002a9a:	48 b8       	lddpc	r8,80002ac4 <udd_enable+0xfc>
80002a9c:	11 ba       	ld.ub	r10,r8[0x3]
80002a9e:	2f fa       	sub	r10,-1
80002aa0:	b0 ba       	st.b	r8[0x3],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002aa2:	e3 b9 00 00 	mtsr	0x0,r9
80002aa6:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
80002aaa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002aae:	00 00       	add	r0,r0
80002ab0:	80 00       	ld.sh	r0,r0[0x0]
80002ab2:	32 b8       	mov	r8,43
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	2c 10       	sub	r0,-63
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	22 30       	sub	r0,35
80002abc:	00 00       	add	r0,r0
80002abe:	07 28       	ld.uh	r8,r3++
80002ac0:	00 00       	add	r0,r0
80002ac2:	07 58       	ld.sh	r8,--r3
80002ac4:	00 00       	add	r0,r0
80002ac6:	0a 24       	rsub	r4,r5

80002ac8 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80002ac8:	eb cd 40 fc 	pushm	r2-r7,lr
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
	ep &= USB_EP_ADDR_MASK;
80002acc:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
80002ad0:	30 37       	mov	r7,3
80002ad2:	ee 0e 18 00 	cp.b	lr,r7
80002ad6:	e0 8b 00 99 	brhi	80002c08 <udd_ep_run+0x140>
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80002ada:	fe 67 00 00 	mov	r7,-131072
80002ade:	6e 76       	ld.w	r6,r7[0x1c]
80002ae0:	1c 95       	mov	r5,lr
80002ae2:	30 17       	mov	r7,1
80002ae4:	ee 0e 09 47 	lsl	r7,r7,lr
80002ae8:	0c 67       	and	r7,r6
80002aea:	e0 80 00 8f 	breq	80002c08 <udd_ep_run+0x140>
			|| Is_udd_endpoint_stall_requested(ep)
80002aee:	fc 06 15 02 	lsl	r6,lr,0x2
80002af2:	fe 64 01 c0 	mov	r4,-130624
80002af6:	ec 04 00 07 	add	r7,r6,r4
80002afa:	6e 07       	ld.w	r7,r7[0x0]
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80002afc:	e6 17 00 08 	andh	r7,0x8,COH
80002b00:	e0 81 00 84 	brne	80002c08 <udd_ep_run+0x140>
	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
80002b04:	fc c7 00 01 	sub	r7,lr,1
80002b08:	a5 67       	lsl	r7,0x4
80002b0a:	4c 14       	lddpc	r4,80002c0c <udd_ep_run+0x144>
80002b0c:	e8 07 00 07 	add	r7,r4,r7

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested)
80002b10:	6e 04       	ld.w	r4,r7[0x0]
80002b12:	e6 14 10 00 	andh	r4,0x1000,COH
80002b16:	c7 91       	brne	80002c08 <udd_ep_run+0x140>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b18:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
80002b1c:	d3 03       	ssrf	0x10
		return false;	// Endpoint is halted

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
80002b1e:	6e 03       	ld.w	r3,r7[0x0]
80002b20:	58 03       	cp.w	r3,0
80002b22:	c0 54       	brge	80002b2c <udd_ep_run+0x64>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002b24:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
80002b28:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
	bool b_dir_in;
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
80002b2c:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false;	// Job already on going
	}
	ptr_job->busy = true;
80002b30:	6e 03       	ld.w	r3,r7[0x0]
80002b32:	30 12       	mov	r2,1
80002b34:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
80002b38:	8f 03       	st.w	r7[0x0],r3
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002b3a:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);
	ptr_job->buf = buf;
80002b3e:	8f 1a       	st.w	r7[0x4],r10
	ptr_job->call_trans = callback;
80002b40:	8f 38       	st.w	r7[0xc],r8
	ptr_job->b_raise_dma = false;
80002b42:	6e 08       	ld.w	r8,r7[0x0]
80002b44:	30 04       	mov	r4,0
80002b46:	f1 d4 d3 a1 	bfins	r8,r4,0x1d,0x1
80002b4a:	8f 08       	st.w	r7[0x0],r8

	// The USBB supports a maximum transfer size of 64KB
	if (0x10000 <= buf_size) {
80002b4c:	e0 49 ff ff 	cp.w	r9,65535
80002b50:	e0 88 00 07 	brls	80002b5e <udd_ep_run+0x96>
		// Transfer size = 64KB
		ptr_job->buf_size = 0x10000;
80002b54:	e0 78 00 00 	mov	r8,65536
80002b58:	8f 28       	st.w	r7[0x8],r8
80002b5a:	08 99       	mov	r9,r4
80002b5c:	c3 58       	rjmp	80002bc6 <udd_ep_run+0xfe>
		buf_size = 0;
	} else {
		ptr_job->buf_size = buf_size;
80002b5e:	8f 29       	st.w	r7[0x8],r9
		if (b_dir_in) {
80002b60:	58 0c       	cp.w	r12,0
80002b62:	c3 20       	breq	80002bc6 <udd_ep_run+0xfe>
			if (buf_size==0) {
80002b64:	58 09       	cp.w	r9,0
80002b66:	c1 71       	brne	80002b94 <udd_ep_run+0xcc>
				// The USB DMA can't send a empty buffer
				// thus we raise the DMA interrupt end of transfert 
				// to execute ZLP process
				ptr_job->b_raise_dma = true;
80002b68:	6e 08       	ld.w	r8,r7[0x0]
80002b6a:	30 1c       	mov	r12,1
				ptr_job->b_send_zlp = true;
80002b6c:	bd b8       	sbr	r8,0x1d
80002b6e:	f1 dc d3 c1 	bfins	r8,r12,0x1e,0x1
80002b72:	8f 08       	st.w	r7[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b74:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002b78:	d3 03       	ssrf	0x10
				flags = cpu_irq_save();
				udd_enable_endpoint_dma_interrupt(ep);
80002b7a:	20 15       	sub	r5,1
80002b7c:	fc 19 02 00 	movh	r9,0x200
80002b80:	f2 05 09 49 	lsl	r9,r9,r5
80002b84:	fe 68 00 00 	mov	r8,-131072
80002b88:	91 69       	st.w	r8[0x18],r9
				udd_raise_endpoint_dma_interrupt(ep);
80002b8a:	91 39       	st.w	r8[0xc],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002b8c:	e3 ba 00 00 	mtsr	0x0,r10
				cpu_irq_restore(flags);
				return true;
80002b90:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			}
			if (0 != buf_size % udd_get_endpoint_size(ep)) {
80002b94:	e0 36 ff 00 	sub	r6,130816
80002b98:	6c 08       	ld.w	r8,r6[0x0]
80002b9a:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
80002b9e:	30 86       	mov	r6,8
80002ba0:	ec 08 09 48 	lsl	r8,r6,r8
80002ba4:	20 18       	sub	r8,1
80002ba6:	12 68       	and	r8,r9
80002ba8:	c0 b0       	breq	80002bbe <udd_ep_run+0xf6>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
80002baa:	6e 08       	ld.w	r8,r7[0x0]
80002bac:	30 0b       	mov	r11,0
80002bae:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
80002bb2:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002bb4:	a5 6e       	lsl	lr,0x4
80002bb6:	e0 3e fd 00 	sub	lr,130304
80002bba:	9d 1a       	st.w	lr[0x4],r10
80002bbc:	c1 18       	rjmp	80002bde <udd_ep_run+0x116>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
			}else{
				ptr_job->b_send_zlp = b_shortpacket;
80002bbe:	6e 08       	ld.w	r8,r7[0x0]
80002bc0:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
80002bc4:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002bc6:	a5 6e       	lsl	lr,0x4
80002bc8:	e0 3e fd 00 	sub	lr,130304
80002bcc:	9d 1a       	st.w	lr[0x4],r10
	if (b_shortpacket) {
80002bce:	58 0b       	cp.w	r11,0
80002bd0:	c0 31       	brne	80002bd6 <udd_ep_run+0x10e>
80002bd2:	30 08       	mov	r8,0
80002bd4:	c0 68       	rjmp	80002be0 <udd_ep_run+0x118>
		if (b_dir_in) {
80002bd6:	58 0c       	cp.w	r12,0
80002bd8:	c0 31       	brne	80002bde <udd_ep_run+0x116>
80002bda:	31 48       	mov	r8,20
80002bdc:	c0 28       	rjmp	80002be0 <udd_ep_run+0x118>
80002bde:	30 88       	mov	r8,8
		} else {
			udd_dma_ctrl = AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
					| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
		}
	}
	udd_dma_ctrl |= (buf_size <<
80002be0:	e8 18 00 21 	orl	r8,0x21
			AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
			& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
	udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80002be4:	f1 e9 11 09 	or	r9,r8,r9<<0x10
			AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;
	udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
80002be8:	9d 29       	st.w	lr[0x8],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002bea:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002bee:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_endpoint_dma_interrupt(ep);
80002bf0:	20 15       	sub	r5,1
80002bf2:	fc 19 02 00 	movh	r9,0x200
80002bf6:	f2 05 09 45 	lsl	r5,r9,r5
80002bfa:	fe 69 00 00 	mov	r9,-131072
80002bfe:	93 65       	st.w	r9[0x18],r5
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002c00:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
80002c04:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
	cpu_irq_restore(flags);

	return true;
80002c08:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002c0c:	00 00       	add	r0,r0
80002c0e:	07 28       	ld.uh	r8,r3++

80002c10 <udd_interrupt>:
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002c10:	eb cd 40 fc 	pushm	r2-r7,lr
	if (Is_udd_sof()) {
80002c14:	fe 68 00 00 	mov	r8,-131072
80002c18:	70 18       	ld.w	r8,r8[0x4]
80002c1a:	e2 18 00 04 	andl	r8,0x4,COH
80002c1e:	c0 f0       	breq	80002c3c <udd_interrupt+0x2c>
		udd_ack_sof();
80002c20:	fe 68 00 00 	mov	r8,-131072
80002c24:	30 49       	mov	r9,4
80002c26:	91 29       	st.w	r8[0x8],r9
		if (Is_udd_full_speed_mode()) {
80002c28:	f0 f8 08 04 	ld.w	r8,r8[2052]
80002c2c:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80002c30:	e0 81 02 ce 	brne	800031cc <udd_interrupt+0x5bc>
		udc_sof_notify();
80002c34:	f0 1f 01 6f 	mcall	800031f0 <udd_interrupt+0x5e0>
80002c38:	e0 8f 02 ca 	bral	800031cc <udd_interrupt+0x5bc>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
	}
	if (Is_udd_msof()) {
80002c3c:	fe 68 00 00 	mov	r8,-131072
80002c40:	70 18       	ld.w	r8,r8[0x4]
80002c42:	e2 18 00 02 	andl	r8,0x2,COH
80002c46:	c0 90       	breq	80002c58 <udd_interrupt+0x48>
		udd_ack_msof();
80002c48:	30 29       	mov	r9,2
80002c4a:	fe 68 00 00 	mov	r8,-131072
80002c4e:	91 29       	st.w	r8[0x8],r9
		udc_sof_notify();
80002c50:	f0 1f 01 68 	mcall	800031f0 <udd_interrupt+0x5e0>
		goto udd_interrupt_end;
80002c54:	e0 8f 02 bc 	bral	800031cc <udd_interrupt+0x5bc>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0))
80002c58:	fe 68 00 00 	mov	r8,-131072
80002c5c:	70 18       	ld.w	r8,r8[0x4]
80002c5e:	e2 18 10 00 	andl	r8,0x1000,COH
80002c62:	e0 80 01 6f 	breq	80002f40 <udd_interrupt+0x330>
		return false;	// No interrupt events on control endpoint

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002c66:	fe 68 02 20 	mov	r8,-130528
80002c6a:	31 09       	mov	r9,16
80002c6c:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002c6e:	30 89       	mov	r9,8
80002c70:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002c72:	fe 68 01 30 	mov	r8,-130768
80002c76:	70 08       	ld.w	r8,r8[0x0]
80002c78:	e2 18 00 04 	andl	r8,0x4,COH
80002c7c:	e0 80 00 87 	breq	80002d8a <udd_interrupt+0x17a>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002c80:	fe f8 05 74 	ld.w	r8,pc[1396]
80002c84:	70 08       	ld.w	r8,r8[0x0]
80002c86:	58 08       	cp.w	r8,0
80002c88:	c0 50       	breq	80002c92 <udd_interrupt+0x82>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002c8a:	f0 1f 01 5c 	mcall	800031f8 <udd_interrupt+0x5e8>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002c8e:	f0 1f 01 5c 	mcall	800031fc <udd_interrupt+0x5ec>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80002c92:	fe 68 01 30 	mov	r8,-130768
80002c96:	70 08       	ld.w	r8,r8[0x0]
80002c98:	f1 d8 c2 8b 	bfextu	r8,r8,0x14,0xb
80002c9c:	58 88       	cp.w	r8,8
80002c9e:	c0 90       	breq	80002cb0 <udd_interrupt+0xa0>
		udd_ctrl_stall_data();
80002ca0:	f0 1f 01 58 	mcall	80003200 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002ca4:	30 49       	mov	r9,4
80002ca6:	fe 68 01 60 	mov	r8,-130720
80002caa:	91 09       	st.w	r8[0x0],r9
80002cac:	e0 8f 02 90 	bral	800031cc <udd_interrupt+0x5bc>
80002cb0:	fc 18 e0 00 	movh	r8,0xe000
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80002cb4:	fe fc 05 50 	ld.w	r12,pc[1360]
80002cb8:	fc 1b 20 00 	movh	r11,0x2000
80002cbc:	f0 0c 00 09 	add	r9,r8,r12
80002cc0:	11 3a       	ld.ub	r10,r8++
80002cc2:	f2 0b 0b 0a 	st.b	r9[r11],r10
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80002cc6:	30 8a       	mov	r10,8
80002cc8:	ea 1a e0 00 	orh	r10,0xe000
80002ccc:	14 38       	cp.w	r8,r10
80002cce:	cf 71       	brne	80002cbc <udd_interrupt+0xac>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002cd0:	fe f8 05 34 	ld.w	r8,pc[1332]
80002cd4:	90 19       	ld.sh	r9,r8[0x2]
80002cd6:	5c c9       	swap.bh	r9
80002cd8:	b0 19       	st.h	r8[0x2],r9
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002cda:	90 29       	ld.sh	r9,r8[0x4]
80002cdc:	5c c9       	swap.bh	r9
80002cde:	b0 29       	st.h	r8[0x4],r9
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002ce0:	90 39       	ld.sh	r9,r8[0x6]
80002ce2:	5c c9       	swap.bh	r9
80002ce4:	b0 39       	st.h	r8[0x6],r9

	// Decode setup request
	if (udc_process_setup() == false) {
80002ce6:	f0 1f 01 49 	mcall	80003208 <udd_interrupt+0x5f8>
80002cea:	c0 91       	brne	80002cfc <udd_interrupt+0xec>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002cec:	f0 1f 01 45 	mcall	80003200 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002cf0:	30 49       	mov	r9,4
80002cf2:	fe 68 01 60 	mov	r8,-130720
80002cf6:	91 09       	st.w	r8[0x0],r9
80002cf8:	e0 8f 02 6a 	bral	800031cc <udd_interrupt+0x5bc>
		return;
	}
	udd_ack_setup_received(0);
80002cfc:	30 49       	mov	r9,4
80002cfe:	fe 68 01 60 	mov	r8,-130720
80002d02:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002d04:	fe f8 05 00 	ld.w	r8,pc[1280]
80002d08:	11 89       	ld.ub	r9,r8[0x0]
80002d0a:	30 08       	mov	r8,0
80002d0c:	f0 09 18 00 	cp.b	r9,r8
80002d10:	c1 94       	brge	80002d42 <udd_interrupt+0x132>
		// Compute if an IN ZLP must be send after IN data
		udd_ctrl_payload_need_in_zlp =
80002d12:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002d16:	90 e8       	ld.uh	r8,r8[0xc]
80002d18:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002d1c:	5f 09       	sreq	r9
80002d1e:	fe f8 04 ee 	ld.w	r8,pc[1262]
80002d22:	b0 89       	st.b	r8[0x0],r9
				((udd_g_ctrlreq.payload_size %
						USB_DEVICE_EP_CTRL_SIZE) == 0);
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d24:	30 08       	mov	r8,0
80002d26:	fe f9 04 ea 	ld.w	r9,pc[1258]
80002d2a:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d2c:	fe f9 04 e8 	ld.w	r9,pc[1256]
80002d30:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002d32:	30 29       	mov	r9,2
80002d34:	fe f8 04 c0 	ld.w	r8,pc[1216]
80002d38:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent();	// Send first data transfer
80002d3a:	f0 1f 01 38 	mcall	80003218 <udd_interrupt+0x608>
80002d3e:	e0 8f 02 47 	bral	800031cc <udd_interrupt+0x5bc>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002d42:	fe f8 04 c2 	ld.w	r8,pc[1218]
80002d46:	90 39       	ld.sh	r9,r8[0x6]
80002d48:	30 08       	mov	r8,0
80002d4a:	f0 09 19 00 	cp.h	r9,r8
80002d4e:	c0 51       	brne	80002d58 <udd_interrupt+0x148>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002d50:	f0 1f 01 33 	mcall	8000321c <udd_interrupt+0x60c>
80002d54:	e0 8f 02 3c 	bral	800031cc <udd_interrupt+0x5bc>
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d58:	30 08       	mov	r8,0
80002d5a:	fe f9 04 b6 	ld.w	r9,pc[1206]
80002d5e:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d60:	fe f9 04 b4 	ld.w	r9,pc[1204]
80002d64:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002d66:	30 19       	mov	r9,1
80002d68:	fe f8 04 8c 	ld.w	r8,pc[1164]
80002d6c:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002d6e:	31 08       	mov	r8,16
80002d70:	fe 69 01 60 	mov	r9,-130720
80002d74:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002d76:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002d7a:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002d7c:	fe 6a 01 f0 	mov	r10,-130576
80002d80:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002d82:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002d86:	e0 8f 02 23 	bral	800031cc <udd_interrupt+0x5bc>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002d8a:	fe 68 01 30 	mov	r8,-130768
80002d8e:	70 08       	ld.w	r8,r8[0x0]
80002d90:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d94:	c0 b0       	breq	80002daa <udd_interrupt+0x19a>
80002d96:	fe 68 01 c0 	mov	r8,-130624
80002d9a:	70 08       	ld.w	r8,r8[0x0]
80002d9c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002da0:	c0 50       	breq	80002daa <udd_interrupt+0x19a>
		// IN packet sent
		udd_ctrl_in_sent();
80002da2:	f0 1f 01 1e 	mcall	80003218 <udd_interrupt+0x608>
80002da6:	e0 8f 02 13 	bral	800031cc <udd_interrupt+0x5bc>
		return true;
	}
	if (Is_udd_out_received(0)) {
80002daa:	fe 68 01 30 	mov	r8,-130768
80002dae:	70 08       	ld.w	r8,r8[0x0]
80002db0:	e2 18 00 02 	andl	r8,0x2,COH
80002db4:	e0 80 00 a3 	breq	80002efa <udd_interrupt+0x2ea>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002db8:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002dbc:	70 08       	ld.w	r8,r8[0x0]
80002dbe:	58 18       	cp.w	r8,1
80002dc0:	c1 10       	breq	80002de2 <udd_interrupt+0x1d2>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80002dc2:	58 28       	cp.w	r8,2
80002dc4:	5f 09       	sreq	r9
80002dc6:	58 48       	cp.w	r8,4
80002dc8:	5f 08       	sreq	r8
80002dca:	f3 e8 10 08 	or	r8,r9,r8
80002dce:	c0 40       	breq	80002dd6 <udd_interrupt+0x1c6>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002dd0:	f0 1f 01 0a 	mcall	800031f8 <udd_interrupt+0x5e8>
80002dd4:	c0 38       	rjmp	80002dda <udd_interrupt+0x1ca>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002dd6:	f0 1f 01 0b 	mcall	80003200 <udd_interrupt+0x5f0>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002dda:	f0 1f 01 09 	mcall	800031fc <udd_interrupt+0x5ec>
80002dde:	e0 8f 01 f7 	bral	800031cc <udd_interrupt+0x5bc>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
80002de2:	fe 68 01 30 	mov	r8,-130768
80002de6:	70 0b       	ld.w	r11,r8[0x0]
80002de8:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002dec:	fe f8 04 18 	ld.w	r8,pc[1048]
80002df0:	90 69       	ld.sh	r9,r8[0xc]
80002df2:	fe f8 04 22 	ld.w	r8,pc[1058]
80002df6:	90 08       	ld.sh	r8,r8[0x0]
80002df8:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
80002dfc:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002e00:	f6 0a 00 0a 	add	r10,r11,r10
80002e04:	14 3c       	cp.w	r12,r10
80002e06:	c0 44       	brge	80002e0e <udd_interrupt+0x1fe>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002e08:	10 19       	sub	r9,r8
80002e0a:	f7 d9 b0 10 	bfexts	r11,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e0e:	fe f9 03 f6 	ld.w	r9,pc[1014]
80002e12:	72 29       	ld.w	r9,r9[0x8]
	for (i = 0; i < nb_data; i++) {
80002e14:	58 0b       	cp.w	r11,0
80002e16:	e0 80 01 e2 	breq	800031da <udd_interrupt+0x5ca>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e1a:	5c 78       	castu.h	r8
80002e1c:	10 09       	add	r9,r8
80002e1e:	fc 18 e0 00 	movh	r8,0xe000
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
80002e22:	11 3a       	ld.ub	r10,r8++
80002e24:	12 ca       	st.b	r9++,r10
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
80002e26:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002e2a:	f6 0a 19 00 	cp.h	r10,r11
80002e2e:	cf a3       	brcs	80002e22 <udd_interrupt+0x212>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80002e30:	fe f9 03 e4 	ld.w	r9,pc[996]
80002e34:	92 08       	ld.sh	r8,r9[0x0]
80002e36:	16 08       	add	r8,r11
80002e38:	5c 88       	casts.h	r8
80002e3a:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80002e3c:	34 09       	mov	r9,64
80002e3e:	f2 0b 19 00 	cp.h	r11,r9
80002e42:	c0 e1       	brne	80002e5e <udd_interrupt+0x24e>
80002e44:	fe f9 03 c0 	ld.w	r9,pc[960]
80002e48:	92 ba       	ld.uh	r10,r9[0x6]
80002e4a:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002e4e:	fe f9 03 c2 	ld.w	r9,pc[962]
80002e52:	92 89       	ld.uh	r9,r9[0x0]
80002e54:	f6 09 00 09 	add	r9,r11,r9
80002e58:	12 3a       	cp.w	r10,r9
80002e5a:	e0 89 00 1a 	brgt	80002e8e <udd_interrupt+0x27e>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback 
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002e5e:	fe f9 03 a6 	ld.w	r9,pc[934]
80002e62:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002e64:	72 5c       	ld.w	r12,r9[0x14]
80002e66:	58 0c       	cp.w	r12,0
80002e68:	c0 b0       	breq	80002e7e <udd_interrupt+0x26e>
			if (!udd_g_ctrlreq.over_under_run()) {
80002e6a:	5d 1c       	icall	r12
80002e6c:	c0 91       	brne	80002e7e <udd_interrupt+0x26e>
				// Stall ZLP
				udd_ctrl_stall_data();
80002e6e:	f0 1f 00 e5 	mcall	80003200 <udd_interrupt+0x5f0>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002e72:	30 29       	mov	r9,2
80002e74:	fe 68 01 60 	mov	r8,-130720
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	e0 8f 01 a9 	bral	800031cc <udd_interrupt+0x5bc>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002e7e:	30 29       	mov	r9,2
80002e80:	fe 68 01 60 	mov	r8,-130720
80002e84:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002e86:	f0 1f 00 e6 	mcall	8000321c <udd_interrupt+0x60c>
80002e8a:	e0 8f 01 a1 	bral	800031cc <udd_interrupt+0x5bc>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002e8e:	fe f9 03 76 	ld.w	r9,pc[886]
80002e92:	92 69       	ld.sh	r9,r9[0xc]
80002e94:	f0 09 19 00 	cp.h	r9,r8
80002e98:	c2 21       	brne	80002edc <udd_interrupt+0x2cc>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002e9a:	fe f8 03 6a 	ld.w	r8,pc[874]
80002e9e:	70 5c       	ld.w	r12,r8[0x14]
80002ea0:	58 0c       	cp.w	r12,0
80002ea2:	c0 91       	brne	80002eb4 <udd_interrupt+0x2a4>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002ea4:	f0 1f 00 d7 	mcall	80003200 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002ea8:	30 29       	mov	r9,2
80002eaa:	fe 68 01 60 	mov	r8,-130720
80002eae:	91 09       	st.w	r8[0x0],r9
80002eb0:	e0 8f 01 8e 	bral	800031cc <udd_interrupt+0x5bc>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002eb4:	5d 1c       	icall	r12
80002eb6:	c0 81       	brne	80002ec6 <udd_interrupt+0x2b6>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002eb8:	f0 1f 00 d2 	mcall	80003200 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002ebc:	30 29       	mov	r9,2
80002ebe:	fe 68 01 60 	mov	r8,-130720
80002ec2:	91 09       	st.w	r8[0x0],r9
80002ec4:	c8 49       	rjmp	800031cc <udd_interrupt+0x5bc>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002ec6:	fe f9 03 4a 	ld.w	r9,pc[842]
80002eca:	fe f8 03 4a 	ld.w	r8,pc[842]
80002ece:	90 0b       	ld.sh	r11,r8[0x0]
80002ed0:	92 0a       	ld.sh	r10,r9[0x0]
80002ed2:	f6 0a 00 0a 	add	r10,r11,r10
80002ed6:	b2 0a       	st.h	r9[0x0],r10
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002ed8:	30 09       	mov	r9,0
80002eda:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002edc:	fe 69 01 60 	mov	r9,-130720
80002ee0:	30 28       	mov	r8,2
80002ee2:	93 08       	st.w	r9[0x0],r8
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002ee4:	31 08       	mov	r8,16
80002ee6:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002ee8:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002eec:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002eee:	fe 6a 01 f0 	mov	r10,-130576
80002ef2:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002ef4:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002ef8:	c6 a9       	rjmp	800031cc <udd_interrupt+0x5bc>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002efa:	fe 68 01 30 	mov	r8,-130768
80002efe:	70 08       	ld.w	r8,r8[0x0]
80002f00:	e2 18 00 08 	andl	r8,0x8,COH
80002f04:	c1 80       	breq	80002f34 <udd_interrupt+0x324>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002f06:	30 89       	mov	r9,8
80002f08:	fe 68 01 60 	mov	r8,-130720
80002f0c:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
80002f0e:	fe 68 01 30 	mov	r8,-130768
80002f12:	70 08       	ld.w	r8,r8[0x0]
80002f14:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002f18:	e0 81 01 5a 	brne	800031cc <udd_interrupt+0x5bc>
		return;	// overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002f1c:	fe f8 02 d8 	ld.w	r8,pc[728]
80002f20:	70 08       	ld.w	r8,r8[0x0]
80002f22:	58 38       	cp.w	r8,3
80002f24:	e0 81 01 54 	brne	800031cc <udd_interrupt+0x5bc>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002f28:	e8 69 00 00 	mov	r9,524288
80002f2c:	fe 68 01 f0 	mov	r8,-130576
80002f30:	91 09       	st.w	r8[0x0],r9
80002f32:	c4 d9       	rjmp	800031cc <udd_interrupt+0x5bc>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002f34:	fe 68 01 30 	mov	r8,-130768
80002f38:	70 08       	ld.w	r8,r8[0x0]
80002f3a:	e2 18 00 10 	andl	r8,0x10,COH
80002f3e:	c0 e1       	brne	80002f5a <udd_interrupt+0x34a>
80002f40:	fe f7 02 e0 	ld.w	r7,pc[736]
80002f44:	0e 9a       	mov	r10,r7
80002f46:	fe 69 01 34 	mov	r9,-130764
80002f4a:	30 0b       	mov	r11,0
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f4c:	fe 66 00 00 	mov	r6,-131072
80002f50:	fc 14 02 00 	movh	r4,0x200
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002f54:	e0 63 10 00 	mov	r3,4096
80002f58:	c1 e8       	rjmp	80002f94 <udd_interrupt+0x384>
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002f5a:	31 09       	mov	r9,16
80002f5c:	fe 68 01 60 	mov	r8,-130720
80002f60:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002f62:	fe 68 01 30 	mov	r8,-130768
80002f66:	70 08       	ld.w	r8,r8[0x0]
80002f68:	e2 18 00 02 	andl	r8,0x2,COH
80002f6c:	e0 81 01 30 	brne	800031cc <udd_interrupt+0x5bc>
		return;	// underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002f70:	fe f8 02 84 	ld.w	r8,pc[644]
80002f74:	70 08       	ld.w	r8,r8[0x0]
80002f76:	58 18       	cp.w	r8,1
80002f78:	c0 41       	brne	80002f80 <udd_interrupt+0x370>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002f7a:	f0 1f 00 a9 	mcall	8000321c <udd_interrupt+0x60c>
80002f7e:	c2 79       	rjmp	800031cc <udd_interrupt+0x5bc>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002f80:	58 48       	cp.w	r8,4
80002f82:	e0 81 01 25 	brne	800031cc <udd_interrupt+0x5bc>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002f86:	e8 69 00 00 	mov	r9,524288
80002f8a:	fe 68 01 f0 	mov	r8,-130576
80002f8e:	91 09       	st.w	r8[0x0],r9
80002f90:	c1 e9       	rjmp	800031cc <udd_interrupt+0x5bc>
80002f92:	10 9b       	mov	r11,r8
80002f94:	f6 c8 ff ff 	sub	r8,r11,-1
80002f98:	14 9c       	mov	r12,r10
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f9a:	6c 45       	ld.w	r5,r6[0x10]
80002f9c:	10 9e       	mov	lr,r8
80002f9e:	e8 0b 09 4b 	lsl	r11,r4,r11
80002fa2:	f7 e5 00 05 	and	r5,r11,r5
80002fa6:	c4 b0       	breq	8000303c <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80002fa8:	6c 15       	ld.w	r5,r6[0x4]
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002faa:	f7 e5 00 05 	and	r5,r11,r5
80002fae:	c4 70       	breq	8000303c <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			udd_disable_endpoint_dma_interrupt(ep);
80002fb0:	fe 69 00 00 	mov	r9,-131072
80002fb4:	93 5b       	st.w	r9[0x14],r11
			if (ptr_job->b_raise_dma) {
80002fb6:	74 09       	ld.w	r9,r10[0x0]
80002fb8:	e6 19 20 00 	andh	r9,0x2000,COH
80002fbc:	c0 50       	breq	80002fc6 <udd_interrupt+0x3b6>
				// In case of manual raise DMA interrupt
				// to process a ZLP packet
				udd_raise_endpoint_dma_interrupt(ep);
80002fbe:	fe 69 00 00 	mov	r9,-131072
80002fc2:	93 3b       	st.w	r9[0xc],r11
80002fc4:	c0 a8       	rjmp	80002fd8 <udd_interrupt+0x3c8>
			}else{
				// Save number of data no transfered
				nb_remaining = (udd_endpoint_dma_get_status(ep) &
80002fc6:	f0 09 15 04 	lsl	r9,r8,0x4
80002fca:	e0 39 fd 00 	sub	r9,130304
80002fce:	72 39       	ld.w	r9,r9[0xc]
						AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
						>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
				// Update number of data transfered
				ptr_job->buf_size -= nb_remaining;
80002fd0:	b1 89       	lsr	r9,0x10
80002fd2:	74 2a       	ld.w	r10,r10[0x8]
80002fd4:	12 1a       	sub	r10,r9
80002fd6:	99 2a       	st.w	r12[0x8],r10
			}

			if (Is_udd_endpoint_in(ep)) {
80002fd8:	a3 68       	lsl	r8,0x2
80002fda:	fe 6b 01 00 	mov	r11,-130816
80002fde:	f0 0b 00 09 	add	r9,r8,r11
80002fe2:	72 09       	ld.w	r9,r9[0x0]
80002fe4:	e2 19 01 00 	andl	r9,0x100,COH
80002fe8:	c2 60       	breq	80003034 <udd_interrupt+0x424>
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
80002fea:	78 09       	ld.w	r9,r12[0x0]
80002fec:	e6 19 40 00 	andh	r9,0x4000,COH
80002ff0:	c2 20       	breq	80003034 <udd_interrupt+0x424>
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
80002ff2:	fe 6a 01 60 	mov	r10,-130720
80002ff6:	f0 0a 00 09 	add	r9,r8,r10
80002ffa:	30 1a       	mov	r10,1
80002ffc:	93 0a       	st.w	r9[0x0],r10
					if (Is_udd_write_enabled(ep)) {
80002ffe:	fe 6b 01 30 	mov	r11,-130768
80003002:	f0 0b 00 09 	add	r9,r8,r11
80003006:	72 09       	ld.w	r9,r9[0x0]
80003008:	e6 19 00 01 	andh	r9,0x1,COH
						udd_raise_in_send(ep);
8000300c:	fe 6a 01 90 	mov	r10,-130672
80003010:	f1 da e1 09 	addne	r9,r8,r10
80003014:	f9 ba 01 01 	movne	r10,1
80003018:	f3 fa 1a 00 	st.wne	r9[0x0],r10
					}
					udd_enable_in_send_interrupt(ep);
8000301c:	e0 38 fe 10 	sub	r8,130576
80003020:	30 19       	mov	r9,1
80003022:	91 09       	st.w	r8[0x0],r9
					udd_enable_endpoint_interrupt(ep);
80003024:	e0 68 10 00 	mov	r8,4096
80003028:	f0 0e 09 4e 	lsl	lr,r8,lr
8000302c:	fe 68 00 00 	mov	r8,-131072
80003030:	91 6e       	st.w	r8[0x18],lr
80003032:	cc d8       	rjmp	800031cc <udd_interrupt+0x5bc>
					return true;
				}
			}
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
80003034:	30 0b       	mov	r11,0
80003036:	f0 1f 00 7c 	mcall	80003224 <udd_interrupt+0x614>
8000303a:	cc 98       	rjmp	800031cc <udd_interrupt+0x5bc>
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
8000303c:	6c 4b       	ld.w	r11,r6[0x10]
8000303e:	e6 0e 09 4e 	lsl	lr,r3,lr
80003042:	fd eb 00 0b 	and	r11,lr,r11
80003046:	c4 60       	breq	800030d2 <udd_interrupt+0x4c2>
80003048:	e0 7b fe d0 	mov	r11,130768
8000304c:	f2 0b 00 02 	add	r2,r9,r11
80003050:	f2 cb ff 70 	sub	r11,r9,-144
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
80003054:	76 05       	ld.w	r5,r11[0x0]
80003056:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8000305a:	c1 50       	breq	80003084 <udd_interrupt+0x474>
8000305c:	72 05       	ld.w	r5,r9[0x0]
8000305e:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80003062:	c1 10       	breq	80003084 <udd_interrupt+0x474>
				udd_disable_in_send_interrupt(ep);
80003064:	fe 6a 02 20 	mov	r10,-130528
80003068:	e4 0a 00 08 	add	r8,r2,r10
8000306c:	30 19       	mov	r9,1
8000306e:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
80003070:	e0 32 fe a0 	sub	r2,130720
80003074:	85 09       	st.w	r2[0x0],r9
				udd_ack_fifocon(ep);
80003076:	e0 69 40 00 	mov	r9,16384
8000307a:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false);
8000307c:	30 0b       	mov	r11,0
8000307e:	f0 1f 00 6a 	mcall	80003224 <udd_interrupt+0x614>
80003082:	ca 58       	rjmp	800031cc <udd_interrupt+0x5bc>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0==udd_nb_busy_bank(ep))) {
80003084:	76 0b       	ld.w	r11,r11[0x0]
80003086:	e2 1b 10 00 	andl	r11,0x1000,COH
8000308a:	c2 40       	breq	800030d2 <udd_interrupt+0x4c2>
8000308c:	72 0b       	ld.w	r11,r9[0x0]
8000308e:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
80003092:	c2 01       	brne	800030d2 <udd_interrupt+0x4c2>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
80003094:	fe 69 02 20 	mov	r9,-130528
80003098:	e4 09 00 08 	add	r8,r2,r9
8000309c:	e0 69 10 00 	mov	r9,4096
800030a0:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
800030a2:	fe 68 00 00 	mov	r8,-131072
800030a6:	91 5e       	st.w	r8[0x14],lr

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
800030a8:	78 08       	ld.w	r8,r12[0x0]
800030aa:	30 09       	mov	r9,0
800030ac:	f1 d9 d3 81 	bfins	r8,r9,0x1c,0x1
800030b0:	99 08       	st.w	r12[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
800030b2:	fe 6b 01 00 	mov	r11,-130816
800030b6:	e4 0b 00 08 	add	r8,r2,r11
800030ba:	70 09       	ld.w	r9,r8[0x0]
800030bc:	a9 d9       	cbr	r9,0x9
800030be:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
800030c0:	e0 32 fe 10 	sub	r2,130576
800030c4:	e8 68 00 00 	mov	r8,524288
800030c8:	85 08       	st.w	r2[0x0],r8
				udd_reset_data_toggle(ep);
800030ca:	e4 68 00 00 	mov	r8,262144
800030ce:	85 08       	st.w	r2[0x0],r8
800030d0:	c7 e8       	rjmp	800031cc <udd_interrupt+0x5bc>
800030d2:	2f 0a       	sub	r10,-16
800030d4:	2f c9       	sub	r9,-4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
800030d6:	58 38       	cp.w	r8,3
800030d8:	fe 91 ff 5d 	brne	80002f92 <udd_interrupt+0x382>
800030dc:	c8 38       	rjmp	800031e2 <udd_interrupt+0x5d2>
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
800030de:	30 89       	mov	r9,8
800030e0:	fe 68 00 00 	mov	r8,-131072
800030e4:	91 29       	st.w	r8[0x8],r9
#if __ICCAVR32__
#if !defined(AVR32_USBB_IRQ_GROUP)
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
800030e6:	ee c6 ff d0 	sub	r6,r7,-48
static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true);
800030ea:	30 15       	mov	r5,1
800030ec:	0a 9b       	mov	r11,r5
800030ee:	0e 9c       	mov	r12,r7
800030f0:	f0 1f 00 4d 	mcall	80003224 <udd_interrupt+0x614>
800030f4:	2f 07       	sub	r7,-16

static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800030f6:	0c 37       	cp.w	r7,r6
800030f8:	cf a1       	brne	800030ec <udd_interrupt+0x4dc>
		// Abort all jobs on-going
#if (0!=USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
800030fa:	f0 1f 00 4c 	mcall	80003228 <udd_interrupt+0x618>
		// Reset endpoint control
		udd_reset_ep_ctrl();
800030fe:	f0 1f 00 4c 	mcall	8000322c <udd_interrupt+0x61c>
		// Reset endpoint control management
		udd_ctrl_init();
80003102:	f0 1f 00 3f 	mcall	800031fc <udd_interrupt+0x5ec>
		goto udd_interrupt_end;
80003106:	c6 38       	rjmp	800031cc <udd_interrupt+0x5bc>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
80003108:	fe 68 00 00 	mov	r8,-131072
8000310c:	70 48       	ld.w	r8,r8[0x10]
8000310e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003112:	c1 b0       	breq	80003148 <udd_interrupt+0x538>
80003114:	fe 68 00 00 	mov	r8,-131072
80003118:	70 18       	ld.w	r8,r8[0x4]
8000311a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000311e:	c1 50       	breq	80003148 <udd_interrupt+0x538>
		otg_unfreeze_clock();
80003120:	fe 68 00 00 	mov	r8,-131072
80003124:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003128:	af c9       	cbr	r9,0xe
8000312a:	f1 49 08 00 	st.w	r8[2048],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
8000312e:	30 19       	mov	r9,1
80003130:	91 59       	st.w	r8[0x14],r9
		udd_enable_wake_up_interrupt();
80003132:	31 09       	mov	r9,16
80003134:	91 69       	st.w	r8[0x18],r9
		otg_freeze_clock();	// Mandatory to exit of sleep mode after a wakeup event
80003136:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000313a:	af a9       	sbr	r9,0xe
8000313c:	f1 49 08 00 	st.w	r8[2048],r9
		udd_sleep_mode(false);	// Enter in SUSPEND mode
80003140:	30 0c       	mov	r12,0
80003142:	f0 1f 00 3c 	mcall	80003230 <udd_interrupt+0x620>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
80003146:	c4 38       	rjmp	800031cc <udd_interrupt+0x5bc>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80003148:	fe 68 00 00 	mov	r8,-131072
8000314c:	70 48       	ld.w	r8,r8[0x10]
8000314e:	e2 18 00 10 	andl	r8,0x10,COH
80003152:	c2 10       	breq	80003194 <udd_interrupt+0x584>
80003154:	fe 68 00 00 	mov	r8,-131072
80003158:	70 18       	ld.w	r8,r8[0x4]
8000315a:	e2 18 00 10 	andl	r8,0x10,COH
8000315e:	c1 b0       	breq	80003194 <udd_interrupt+0x584>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
80003160:	fe 68 00 00 	mov	r8,-131072
80003164:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003168:	af c9       	cbr	r9,0xe
8000316a:	f1 49 08 00 	st.w	r8[2048],r9
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
8000316e:	c0 58       	rjmp	80003178 <udd_interrupt+0x568>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
80003170:	70 19       	ld.w	r9,r8[0x4]
80003172:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003176:	c0 61       	brne	80003182 <udd_interrupt+0x572>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
80003178:	f0 f9 08 04 	ld.w	r9,r8[2052]
8000317c:	e2 19 40 00 	andl	r9,0x4000,COH
80003180:	cf 80       	breq	80003170 <udd_interrupt+0x560>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
80003182:	fe 68 00 00 	mov	r8,-131072
80003186:	31 09       	mov	r9,16
80003188:	91 59       	st.w	r8[0x14],r9
		udd_enable_suspend_interrupt();
8000318a:	30 1c       	mov	r12,1
8000318c:	91 6c       	st.w	r8[0x18],r12
		udd_sleep_mode(true);	// Enter in IDLE mode
8000318e:	f0 1f 00 29 	mcall	80003230 <udd_interrupt+0x620>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
80003192:	c1 d8       	rjmp	800031cc <udd_interrupt+0x5bc>
	}

	if (Is_udd_vbus_transition()) {
80003194:	fe 68 00 00 	mov	r8,-131072
80003198:	f0 f8 08 04 	ld.w	r8,r8[2052]
8000319c:	e2 18 00 02 	andl	r8,0x2,COH
800031a0:	c1 60       	breq	800031cc <udd_interrupt+0x5bc>
		// Ack VBus transition and send status to high level
		otg_unfreeze_clock();
800031a2:	fe 68 00 00 	mov	r8,-131072
800031a6:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031aa:	af c9       	cbr	r9,0xe
800031ac:	f1 49 08 00 	st.w	r8[2048],r9
		udd_ack_vbus_transition();
800031b0:	30 29       	mov	r9,2
800031b2:	f1 49 08 08 	st.w	r8[2056],r9
		otg_freeze_clock();
800031b6:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031ba:	af a9       	sbr	r9,0xe
800031bc:	f1 49 08 00 	st.w	r8[2048],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_udd_vbus_high());
800031c0:	f0 fc 08 04 	ld.w	r12,r8[2052]
800031c4:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
800031c8:	f0 1f 00 1b 	mcall	80003234 <udd_interrupt+0x624>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
800031cc:	fe 68 00 00 	mov	r8,-131072
800031d0:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
800031d4:	e3 cd 40 fc 	ldm	sp++,r2-r7,lr
800031d8:	d6 03       	rete
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
800031da:	48 f9       	lddpc	r9,80003214 <udd_interrupt+0x604>
800031dc:	b2 08       	st.h	r9[0x0],r8
800031de:	fe 9f fe 40 	bral	80002e5e <udd_interrupt+0x24e>
	if (udd_ep_interrupt())
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
800031e2:	fe 68 00 00 	mov	r8,-131072
800031e6:	70 18       	ld.w	r8,r8[0x4]
800031e8:	e2 18 00 08 	andl	r8,0x8,COH
800031ec:	c8 e0       	breq	80003108 <udd_interrupt+0x4f8>
800031ee:	c7 8b       	rjmp	800030de <udd_interrupt+0x4ce>
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	37 b4       	mov	r4,123
800031f4:	00 00       	add	r0,r0
800031f6:	07 5c       	ld.sh	r12,--r3
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	25 34       	sub	r4,83
800031fc:	80 00       	ld.sh	r0,r0[0x0]
800031fe:	27 50       	sub	r0,117
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	25 1c       	sub	r12,81
80003204:	00 00       	add	r0,r0
80003206:	0a 0c       	add	r12,r5
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	3a 34       	mov	r4,-93
8000320c:	00 00       	add	r0,r0
8000320e:	07 60       	ld.uh	r0,--r3
80003210:	00 00       	add	r0,r0
80003212:	07 24       	ld.uh	r4,r3++
80003214:	00 00       	add	r0,r0
80003216:	07 5a       	ld.sh	r10,--r3
80003218:	80 00       	ld.sh	r0,r0[0x0]
8000321a:	28 8c       	sub	r12,-120
8000321c:	80 00       	ld.sh	r0,r0[0x0]
8000321e:	27 84       	sub	r4,120
80003220:	00 00       	add	r0,r0
80003222:	07 28       	ld.uh	r8,r3++
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	25 48       	sub	r8,84
80003228:	80 00       	ld.sh	r0,r0[0x0]
8000322a:	39 d4       	mov	r4,-99
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	27 b0       	sub	r0,123
80003230:	80 00       	ld.sh	r0,r0[0x0]
80003232:	26 dc       	sub	r12,109
80003234:	80 00       	ld.sh	r0,r0[0x0]
80003236:	3f 34       	mov	r4,-13

80003238 <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003238:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
8000323c:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000323e:	fe 78 0c 00 	mov	r8,-62464
80003242:	71 59       	ld.w	r9,r8[0x54]
80003244:	e2 19 00 40 	andl	r9,0x40,COH
80003248:	cf d0       	breq	80003242 <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
8000324a:	a3 6c       	lsl	r12,0x2
8000324c:	e0 2c f3 f8 	sub	r12,62456
80003250:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
80003252:	30 19       	mov	r9,1
80003254:	f2 0b 09 4b 	lsl	r11,r9,r11
80003258:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
8000325a:	99 0b       	st.w	r12[0x0],r11
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000325c:	e3 ba 00 00 	mtsr	0x0,r10

	cpu_irq_restore(flags);
}
80003260:	5e fc       	retal	r12
80003262:	d7 03       	nop

80003264 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
80003264:	eb cd 40 e0 	pushm	r5-r7,lr
80003268:	18 96       	mov	r6,r12
8000326a:	58 9c       	cp.w	r12,9
8000326c:	5f 07       	sreq	r7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000326e:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
80003272:	d3 03       	ssrf	0x10
		pbus_id = 1;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_bus_refcount[pbus_id])
80003274:	48 f8       	lddpc	r8,800032b0 <sysclk_enable_pbb_module+0x4c>
80003276:	f0 07 07 09 	ld.ub	r9,r8[r7]
8000327a:	30 08       	mov	r8,0
8000327c:	f0 09 18 00 	cp.b	r9,r8
80003280:	c0 a1       	brne	80003294 <sysclk_enable_pbb_module+0x30>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
80003282:	ee 0b 15 01 	lsl	r11,r7,0x1
80003286:	f9 bb 01 06 	movne	r11,6
8000328a:	f9 bb 00 02 	moveq	r11,2
8000328e:	30 1c       	mov	r12,1
80003290:	f0 1f 00 09 	mcall	800032b4 <sysclk_enable_pbb_module+0x50>
		sysclk_enable_hsb_module(2 + (4 * pbus_id));
	sysclk_bus_refcount[pbus_id]++;
80003294:	48 78       	lddpc	r8,800032b0 <sysclk_enable_pbb_module+0x4c>
80003296:	f0 07 07 09 	ld.ub	r9,r8[r7]
8000329a:	2f f9       	sub	r9,-1
8000329c:	f0 07 0b 09 	st.b	r8[r7],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032a0:	e3 b5 00 00 	mtsr	0x0,r5

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
800032a4:	0c 9b       	mov	r11,r6
800032a6:	30 3c       	mov	r12,3
800032a8:	f0 1f 00 03 	mcall	800032b4 <sysclk_enable_pbb_module+0x50>
}
800032ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032b0:	00 00       	add	r0,r0
800032b2:	07 64       	ld.uh	r4,--r3
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	32 38       	mov	r8,35

800032b8 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 12MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
800032b8:	d4 01       	pushm	lr
	struct genclk_config gcfg;

	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
800032ba:	30 1c       	mov	r12,1
800032bc:	f0 1f 00 0f 	mcall	800032f8 <sysclk_enable_usb+0x40>
800032c0:	30 3b       	mov	r11,3
800032c2:	30 1c       	mov	r12,1
800032c4:	f0 1f 00 0e 	mcall	800032fc <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800032c8:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800032cc:	d3 03       	ssrf	0x10
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
800032ce:	fe 78 0c 00 	mov	r8,-62464
800032d2:	e0 6a 03 07 	mov	r10,775
800032d6:	91 aa       	st.w	r8[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
800032d8:	70 0a       	ld.w	r10,r8[0x0]
800032da:	a3 aa       	sbr	r10,0x2
800032dc:	91 0a       	st.w	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032de:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_OSC0RDY + id)));
800032e2:	71 59       	ld.w	r9,r8[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
800032e4:	e2 19 00 80 	andl	r9,0x80,COH
800032e8:	cf d0       	breq	800032e2 <sysclk_enable_usb+0x2a>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
800032ea:	30 49       	mov	r9,4
800032ec:	fe 78 0c 00 	mov	r8,-62464
800032f0:	f1 49 00 70 	st.w	r8[112],r9
		break;
	}

	genclk_config_set_divider(&gcfg, CONFIG_USBCLK_DIV);
	genclk_enable(&gcfg, AVR32_PM_GCLK_USBB);
}
800032f4:	d8 02       	popm	pc
800032f6:	00 00       	add	r0,r0
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	32 64       	mov	r4,38
800032fc:	80 00       	ld.sh	r0,r0[0x0]
800032fe:	32 38       	mov	r8,35

80003300 <udi_cdc_data_disable>:
	UDI_CDC_DISABLE_EXT();
}

void udi_cdc_data_disable(void)
{
}
80003300:	5e fc       	retal	r12
80003302:	d7 03       	nop

80003304 <udi_cdc_comm_setup>:


bool udi_cdc_comm_setup(void)
{
	if (Udd_setup_is_in()) {
80003304:	49 e8       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
80003306:	11 88       	ld.ub	r8,r8[0x0]
80003308:	30 09       	mov	r9,0
8000330a:	f2 08 18 00 	cp.b	r8,r9
8000330e:	c1 84       	brge	8000333e <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests 
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80003310:	e2 18 00 60 	andl	r8,0x60,COH
80003314:	e0 48 00 20 	cp.w	r8,32
80003318:	c3 11       	brne	8000337a <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
8000331a:	49 98       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
8000331c:	11 99       	ld.ub	r9,r8[0x1]
8000331e:	32 18       	mov	r8,33
80003320:	f0 09 18 00 	cp.b	r9,r8
80003324:	c2 b1       	brne	8000337a <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80003326:	49 68       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
80003328:	90 39       	ld.sh	r9,r8[0x6]
8000332a:	30 78       	mov	r8,7
8000332c:	f0 09 19 00 	cp.h	r9,r8
80003330:	c2 51       	brne	8000337a <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.payload =
80003332:	49 38       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
80003334:	49 39       	lddpc	r9,80003380 <udi_cdc_comm_setup+0x7c>
80003336:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003338:	30 79       	mov	r9,7
8000333a:	b0 69       	st.h	r8[0xc],r9
8000333c:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests  
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000333e:	e2 18 00 60 	andl	r8,0x60,COH
80003342:	e0 48 00 20 	cp.w	r8,32
80003346:	c1 a1       	brne	8000337a <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
80003348:	48 d8       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
8000334a:	11 98       	ld.ub	r8,r8[0x1]
8000334c:	32 09       	mov	r9,32
8000334e:	f2 08 18 00 	cp.b	r8,r9
80003352:	c0 60       	breq	8000335e <udi_cdc_comm_setup+0x5a>
80003354:	32 29       	mov	r9,34
80003356:	f2 08 18 00 	cp.b	r8,r9
8000335a:	c1 01       	brne	8000337a <udi_cdc_comm_setup+0x76>
8000335c:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
8000335e:	48 88       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
80003360:	90 39       	ld.sh	r9,r8[0x6]
80003362:	30 78       	mov	r8,7
80003364:	f0 09 19 00 	cp.h	r9,r8
80003368:	c0 91       	brne	8000337a <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.callback =
8000336a:	48 58       	lddpc	r8,8000337c <udi_cdc_comm_setup+0x78>
8000336c:	48 69       	lddpc	r9,80003384 <udi_cdc_comm_setup+0x80>
8000336e:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
80003370:	48 49       	lddpc	r9,80003380 <udi_cdc_comm_setup+0x7c>
80003372:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003374:	30 79       	mov	r9,7
80003376:	b0 69       	st.h	r8[0xc],r9
80003378:	5e ff       	retal	1
						sizeof(udi_cdc_line_coding);
				return true;
8000337a:	5e fd       	retal	0
8000337c:	00 00       	add	r0,r0
8000337e:	0a 0c       	add	r12,r5
80003380:	00 00       	add	r0,r0
80003382:	07 68       	ld.uh	r8,--r3
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	33 8c       	mov	r12,56

80003388 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
80003388:	5e fd       	retal	0

8000338a <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
8000338a:	5e fd       	retal	0

8000338c <udi_cdc_line_coding_received>:

void udi_cdc_line_coding_received(void)
{
	// Send line coding to component associated to CDC
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));
}
8000338c:	5e fc       	retal	r12
8000338e:	d7 03       	nop

80003390 <udi_cdc_is_rx_ready>:
}


bool udi_cdc_is_rx_ready(void)
{
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
80003390:	48 68       	lddpc	r8,800033a8 <udi_cdc_is_rx_ready+0x18>
80003392:	11 8a       	ld.ub	r10,r8[0x0]
80003394:	48 68       	lddpc	r8,800033ac <udi_cdc_is_rx_ready+0x1c>
80003396:	90 08       	ld.sh	r8,r8[0x0]
80003398:	48 69       	lddpc	r9,800033b0 <udi_cdc_is_rx_ready+0x20>
8000339a:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
8000339e:	f0 09 19 00 	cp.h	r9,r8
}
800033a2:	5f bc       	srhi	r12
800033a4:	5e fc       	retal	r12
800033a6:	00 00       	add	r0,r0
800033a8:	00 00       	add	r0,r0
800033aa:	07 fc       	ld.ub	r12,r3[0x7]
800033ac:	00 00       	add	r0,r0
800033ae:	07 f8       	ld.ub	r8,r3[0x7]
800033b0:	00 00       	add	r0,r0
800033b2:	07 f4       	ld.ub	r4,r3[0x7]

800033b4 <udi_cdc_is_tx_ready>:


bool udi_cdc_is_tx_ready(void)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS) {
800033b4:	49 58       	lddpc	r8,80003408 <udi_cdc_is_tx_ready+0x54>
800033b6:	11 89       	ld.ub	r9,r8[0x0]
800033b8:	49 58       	lddpc	r8,8000340c <udi_cdc_is_tx_ready+0x58>
800033ba:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033be:	34 08       	mov	r8,64
800033c0:	f0 09 19 00 	cp.h	r9,r8
800033c4:	c0 20       	breq	800033c8 <udi_cdc_is_tx_ready+0x14>
800033c6:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send) {
800033c8:	49 28       	lddpc	r8,80003410 <udi_cdc_is_tx_ready+0x5c>
800033ca:	11 88       	ld.ub	r8,r8[0x0]
800033cc:	58 08       	cp.w	r8,0
800033ce:	c1 21       	brne	800033f2 <udi_cdc_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800033d0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800033d4:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing) {
800033d6:	49 09       	lddpc	r9,80003414 <udi_cdc_is_tx_ready+0x60>
800033d8:	13 89       	ld.ub	r9,r9[0x0]
800033da:	58 09       	cp.w	r9,0
800033dc:	c0 91       	brne	800033ee <udi_cdc_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send = true;
800033de:	30 1a       	mov	r10,1
800033e0:	48 c9       	lddpc	r9,80003410 <udi_cdc_is_tx_ready+0x5c>
800033e2:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel = (udi_cdc_tx_buf_sel==0)?1:0;
800033e4:	48 99       	lddpc	r9,80003408 <udi_cdc_is_tx_ready+0x54>
800033e6:	13 8a       	ld.ub	r10,r9[0x0]
800033e8:	58 0a       	cp.w	r10,0
800033ea:	5f 0a       	sreq	r10
800033ec:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800033ee:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS);
800033f2:	48 68       	lddpc	r8,80003408 <udi_cdc_is_tx_ready+0x54>
800033f4:	11 89       	ld.ub	r9,r8[0x0]
800033f6:	48 68       	lddpc	r8,8000340c <udi_cdc_is_tx_ready+0x58>
800033f8:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033fc:	34 08       	mov	r8,64
800033fe:	f0 09 19 00 	cp.h	r9,r8
80003402:	5f 1c       	srne	r12
}
80003404:	5e fc       	retal	r12
80003406:	00 00       	add	r0,r0
80003408:	00 00       	add	r0,r0
8000340a:	07 6f       	ld.uh	pc,--r3
8000340c:	00 00       	add	r0,r0
8000340e:	07 70       	ld.ub	r0,--r3
80003410:	00 00       	add	r0,r0
80003412:	08 81       	andn	r1,r4
80003414:	00 00       	add	r0,r0
80003416:	07 fe       	ld.ub	lr,r3[0x7]

80003418 <udi_cdc_putc>:


int udi_cdc_putc(int value)
{
80003418:	eb cd 40 fe 	pushm	r1-r7,lr
8000341c:	18 97       	mov	r7,r12
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
8000341e:	49 88       	lddpc	r8,8000347c <udi_cdc_putc+0x64>
80003420:	11 e9       	ld.ub	r9,r8[0x6]
80003422:	30 98       	mov	r8,9
80003424:	f0 09 18 00 	cp.b	r9,r8
80003428:	5f 04       	sreq	r4

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
		if (!udi_cdc_running) {
8000342a:	49 66       	lddpc	r6,80003480 <udi_cdc_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
8000342c:	49 63       	lddpc	r3,80003484 <udi_cdc_putc+0x6c>
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
8000342e:	49 75       	lddpc	r5,80003488 <udi_cdc_putc+0x70>
80003430:	49 72       	lddpc	r2,8000348c <udi_cdc_putc+0x74>
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
80003432:	30 01       	mov	r1,0

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
80003434:	f0 1f 00 17 	mcall	80003490 <udi_cdc_putc+0x78>
80003438:	c0 51       	brne	80003442 <udi_cdc_putc+0x2a>
		if (!udi_cdc_running) {
8000343a:	0d 88       	ld.ub	r8,r6[0x0]
8000343c:	58 08       	cp.w	r8,0
8000343e:	cf b1       	brne	80003434 <udi_cdc_putc+0x1c>
80003440:	c1 b8       	rjmp	80003476 <udi_cdc_putc+0x5e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003442:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003446:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003448:	07 88       	ld.ub	r8,r3[0x0]
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
8000344a:	ea 08 04 19 	ld.sh	r9,r5[r8<<0x1]
8000344e:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
80003452:	f0 0c 15 06 	lsl	r12,r8,0x6
80003456:	f8 0b 00 0b 	add	r11,r12,r11
8000345a:	e4 0b 0b 07 	st.b	r2[r11],r7
8000345e:	2f f9       	sub	r9,-1
80003460:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003464:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
80003468:	58 04       	cp.w	r4,0
8000346a:	c0 31       	brne	80003470 <udi_cdc_putc+0x58>
8000346c:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
80003470:	a9 47       	asr	r7,0x8
80003472:	02 94       	mov	r4,r1
80003474:	ce 0b       	rjmp	80003434 <udi_cdc_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
80003476:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000347a:	00 00       	add	r0,r0
8000347c:	00 00       	add	r0,r0
8000347e:	07 68       	ld.uh	r8,--r3
80003480:	00 00       	add	r0,r0
80003482:	07 fd       	ld.ub	sp,r3[0x7]
80003484:	00 00       	add	r0,r0
80003486:	07 6f       	ld.uh	pc,--r3
80003488:	00 00       	add	r0,r0
8000348a:	07 70       	ld.ub	r0,--r3
8000348c:	00 00       	add	r0,r0
8000348e:	07 74       	ld.ub	r4,--r3
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	33 b4       	mov	r4,59

80003494 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(void)
{
80003494:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003498:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000349c:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel;
8000349e:	49 78       	lddpc	r8,800034f8 <udi_cdc_rx_start+0x64>
800034a0:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing ||
800034a2:	49 78       	lddpc	r8,800034fc <udi_cdc_rx_start+0x68>
800034a4:	11 88       	ld.ub	r8,r8[0x0]
800034a6:	58 08       	cp.w	r8,0
800034a8:	c0 a1       	brne	800034bc <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos < udi_cdc_rx_buf_nb[buf_sel_trans])) {
800034aa:	49 68       	lddpc	r8,80003500 <udi_cdc_rx_start+0x6c>
800034ac:	90 08       	ld.sh	r8,r8[0x0]
800034ae:	49 6a       	lddpc	r10,80003504 <udi_cdc_rx_start+0x70>
800034b0:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
800034b4:	f0 0a 19 00 	cp.h	r10,r8
800034b8:	e0 88 00 06 	brls	800034c4 <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034bc:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800034c0:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos = 0;
800034c4:	30 0a       	mov	r10,0
800034c6:	48 f8       	lddpc	r8,80003500 <udi_cdc_rx_start+0x6c>
800034c8:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel = (buf_sel_trans==0)?1:0;
800034ca:	58 07       	cp.w	r7,0
800034cc:	5f 0a       	sreq	r10
800034ce:	48 b8       	lddpc	r8,800034f8 <udi_cdc_rx_start+0x64>
800034d0:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing = true;
800034d2:	30 1a       	mov	r10,1
800034d4:	48 a8       	lddpc	r8,800034fc <udi_cdc_rx_start+0x68>
800034d6:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034d8:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
	
	if (udi_cdc_is_rx_ready()) {
800034dc:	f0 1f 00 0b 	mcall	80003508 <udi_cdc_rx_start+0x74>
		UDI_CDC_RX_NOTIFY();
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUT,
800034e0:	a7 67       	lsl	r7,0x6
800034e2:	48 b8       	lddpc	r8,8000350c <udi_cdc_rx_start+0x78>
800034e4:	34 09       	mov	r9,64
800034e6:	48 ba       	lddpc	r10,80003510 <udi_cdc_rx_start+0x7c>
800034e8:	0e 0a       	add	r10,r7
800034ea:	30 1b       	mov	r11,1
800034ec:	30 2c       	mov	r12,2
800034ee:	f0 1f 00 0a 	mcall	80003514 <udi_cdc_rx_start+0x80>
					true,
					udi_cdc_rx_buf[buf_sel_trans],
					UDI_CDC_RX_BUFFERS,
					udi_cdc_data_recevied);
}
800034f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800034f6:	00 00       	add	r0,r0
800034f8:	00 00       	add	r0,r0
800034fa:	07 fc       	ld.ub	r12,r3[0x7]
800034fc:	00 00       	add	r0,r0
800034fe:	08 80       	andn	r0,r4
80003500:	00 00       	add	r0,r0
80003502:	07 f8       	ld.ub	r8,r3[0x7]
80003504:	00 00       	add	r0,r0
80003506:	07 f4       	ld.ub	r4,r3[0x7]
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	33 90       	mov	r0,57
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	35 94       	mov	r4,89
80003510:	00 00       	add	r0,r0
80003512:	08 00       	add	r0,r4
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	2a c8       	sub	r8,-84

80003518 <udi_cdc_getc>:
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
}


int udi_cdc_getc(void)
{
80003518:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
8000351a:	49 88       	lddpc	r8,80003578 <udi_cdc_getc+0x60>
8000351c:	11 e9       	ld.ub	r9,r8[0x6]
8000351e:	30 98       	mov	r8,9
80003520:	f0 09 18 00 	cp.b	r9,r8
80003524:	5f 02       	sreq	r2
80003526:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003528:	49 56       	lddpc	r6,8000357c <udi_cdc_getc+0x64>
8000352a:	49 67       	lddpc	r7,80003580 <udi_cdc_getc+0x68>
8000352c:	49 65       	lddpc	r5,80003584 <udi_cdc_getc+0x6c>
		if (!udi_cdc_running) {
8000352e:	49 74       	lddpc	r4,80003588 <udi_cdc_getc+0x70>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
80003530:	49 71       	lddpc	r1,8000358c <udi_cdc_getc+0x74>
	udi_cdc_rx_start();

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
80003532:	06 90       	mov	r0,r3
80003534:	c0 48       	rjmp	8000353c <udi_cdc_getc+0x24>
	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
		if (!udi_cdc_running) {
80003536:	09 88       	ld.ub	r8,r4[0x0]
80003538:	58 08       	cp.w	r8,0
8000353a:	c1 b0       	breq	80003570 <udi_cdc_getc+0x58>

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
8000353c:	0d 89       	ld.ub	r9,r6[0x0]
8000353e:	8e 08       	ld.sh	r8,r7[0x0]
80003540:	ea 09 04 19 	ld.sh	r9,r5[r9<<0x1]
80003544:	f0 09 19 00 	cp.h	r9,r8
80003548:	fe 98 ff f7 	brls	80003536 <udi_cdc_getc+0x1e>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
8000354c:	0d 88       	ld.ub	r8,r6[0x0]
8000354e:	8e 09       	ld.sh	r9,r7[0x0]
80003550:	5c 79       	castu.h	r9
80003552:	a7 68       	lsl	r8,0x6
80003554:	12 08       	add	r8,r9
80003556:	e2 08 07 08 	ld.ub	r8,r1[r8]
8000355a:	10 43       	or	r3,r8
	udi_cdc_rx_pos++;
8000355c:	8e 08       	ld.sh	r8,r7[0x0]
8000355e:	2f f8       	sub	r8,-1
80003560:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start();
80003562:	f0 1f 00 0c 	mcall	80003590 <udi_cdc_getc+0x78>

	if (b_databit_9) {
80003566:	58 02       	cp.w	r2,0
80003568:	c0 50       	breq	80003572 <udi_cdc_getc+0x5a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
8000356a:	a9 63       	lsl	r3,0x8
8000356c:	00 92       	mov	r2,r0
8000356e:	ce 7b       	rjmp	8000353c <udi_cdc_getc+0x24>
		goto udi_cdc_getc_process_one_byte;
80003570:	30 03       	mov	r3,0
	}
	return rx_data;
}
80003572:	06 9c       	mov	r12,r3
80003574:	d8 32       	popm	r0-r7,pc
80003576:	00 00       	add	r0,r0
80003578:	00 00       	add	r0,r0
8000357a:	07 68       	ld.uh	r8,--r3
8000357c:	00 00       	add	r0,r0
8000357e:	07 fc       	ld.ub	r12,r3[0x7]
80003580:	00 00       	add	r0,r0
80003582:	07 f8       	ld.ub	r8,r3[0x7]
80003584:	00 00       	add	r0,r0
80003586:	07 f4       	ld.ub	r4,r3[0x7]
80003588:	00 00       	add	r0,r0
8000358a:	07 fd       	ld.ub	sp,r3[0x7]
8000358c:	00 00       	add	r0,r0
8000358e:	08 00       	add	r0,r4
80003590:	80 00       	ld.sh	r0,r0[0x0]
80003592:	34 94       	mov	r4,73

80003594 <udi_cdc_data_recevied>:
					udi_cdc_data_recevied);
}


void udi_cdc_data_recevied(udd_ep_status_t status, iram_size_t n)
{
80003594:	d4 01       	pushm	lr
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
80003596:	58 0c       	cp.w	r12,0
80003598:	c1 01       	brne	800035b8 <udi_cdc_data_recevied+0x24>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel==0)?1:0;
8000359a:	48 98       	lddpc	r8,800035bc <udi_cdc_data_recevied+0x28>
8000359c:	11 88       	ld.ub	r8,r8[0x0]
	udi_cdc_rx_buf_nb[buf_sel_trans] = n;
8000359e:	58 08       	cp.w	r8,0
800035a0:	f9 b8 01 00 	movne	r8,0
800035a4:	f9 b8 00 02 	moveq	r8,2
800035a8:	48 69       	lddpc	r9,800035c0 <udi_cdc_data_recevied+0x2c>
800035aa:	f2 08 0a 0b 	st.h	r9[r8],r11
	udi_cdc_rx_trans_ongoing = false;
800035ae:	30 09       	mov	r9,0
800035b0:	48 58       	lddpc	r8,800035c4 <udi_cdc_data_recevied+0x30>
800035b2:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start();
800035b4:	f0 1f 00 05 	mcall	800035c8 <udi_cdc_data_recevied+0x34>
800035b8:	d8 02       	popm	pc
800035ba:	00 00       	add	r0,r0
800035bc:	00 00       	add	r0,r0
800035be:	07 fc       	ld.ub	r12,r3[0x7]
800035c0:	00 00       	add	r0,r0
800035c2:	07 f4       	ld.ub	r4,r3[0x7]
800035c4:	00 00       	add	r0,r0
800035c6:	08 80       	andn	r0,r4
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	34 94       	mov	r4,73

800035cc <udi_cdc_tx_send>:
	udi_cdc_tx_send();
}


static void udi_cdc_tx_send(void)
{
800035cc:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing) {
800035d0:	4a a8       	lddpc	r8,80003678 <udi_cdc_tx_send+0xac>
800035d2:	11 88       	ld.ub	r8,r8[0x0]
800035d4:	58 08       	cp.w	r8,0
800035d6:	c4 f1       	brne	80003674 <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
800035d8:	f0 1f 00 29 	mcall	8000367c <udi_cdc_tx_send+0xb0>
800035dc:	c0 a0       	breq	800035f0 <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num == udd_get_micro_frame_number()) {
800035de:	f0 1f 00 29 	mcall	80003680 <udi_cdc_tx_send+0xb4>
800035e2:	4a 98       	lddpc	r8,80003684 <udi_cdc_tx_send+0xb8>
800035e4:	90 08       	ld.sh	r8,r8[0x0]
800035e6:	f8 08 19 00 	cp.h	r8,r12
800035ea:	c0 a1       	brne	800035fe <udi_cdc_tx_send+0x32>
800035ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num == udd_get_frame_number()) {
800035f0:	f0 1f 00 26 	mcall	80003688 <udi_cdc_tx_send+0xbc>
800035f4:	4a 48       	lddpc	r8,80003684 <udi_cdc_tx_send+0xb8>
800035f6:	90 08       	ld.sh	r8,r8[0x0]
800035f8:	f8 08 19 00 	cp.h	r8,r12
800035fc:	c3 c0       	breq	80003674 <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800035fe:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80003602:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel;
80003604:	4a 29       	lddpc	r9,8000368c <udi_cdc_tx_send+0xc0>
80003606:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send) {
80003608:	4a 29       	lddpc	r9,80003690 <udi_cdc_tx_send+0xc4>
8000360a:	13 89       	ld.ub	r9,r9[0x0]
8000360c:	58 09       	cp.w	r9,0
8000360e:	c0 61       	brne	8000361a <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel = (buf_sel_trans==0)?1:0;
80003610:	58 07       	cp.w	r7,0
80003612:	5f 0a       	sreq	r10
80003614:	49 e9       	lddpc	r9,8000368c <udi_cdc_tx_send+0xc0>
80003616:	b2 8a       	st.b	r9[0x0],r10
80003618:	c0 38       	rjmp	8000361e <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
8000361a:	58 07       	cp.w	r7,0
8000361c:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing = true;
8000361e:	30 1a       	mov	r10,1
80003620:	49 69       	lddpc	r9,80003678 <udi_cdc_tx_send+0xac>
80003622:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003624:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80003628:	0e 95       	mov	r5,r7
8000362a:	49 b8       	lddpc	r8,80003694 <udi_cdc_tx_send+0xc8>
8000362c:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
80003630:	34 08       	mov	r8,64
80003632:	f0 09 19 00 	cp.h	r9,r8
80003636:	5f 16       	srne	r6
	if (b_short_packet) {
80003638:	58 06       	cp.w	r6,0
8000363a:	c0 e0       	breq	80003656 <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
8000363c:	f0 1f 00 10 	mcall	8000367c <udi_cdc_tx_send+0xb0>
80003640:	c0 60       	breq	8000364c <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num = udd_get_micro_frame_number();
80003642:	f0 1f 00 10 	mcall	80003680 <udi_cdc_tx_send+0xb4>
80003646:	49 08       	lddpc	r8,80003684 <udi_cdc_tx_send+0xb8>
80003648:	b0 0c       	st.h	r8[0x0],r12
8000364a:	c0 98       	rjmp	8000365c <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num = udd_get_frame_number();
8000364c:	f0 1f 00 0f 	mcall	80003688 <udi_cdc_tx_send+0xbc>
80003650:	48 d8       	lddpc	r8,80003684 <udi_cdc_tx_send+0xb8>
80003652:	b0 0c       	st.h	r8[0x0],r12
80003654:	c0 48       	rjmp	8000365c <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num = 0; // Force next transfer without wait SOF
80003656:	30 09       	mov	r9,0
80003658:	48 b8       	lddpc	r8,80003684 <udi_cdc_tx_send+0xb8>
8000365a:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_IN,
8000365c:	a7 67       	lsl	r7,0x6
8000365e:	48 f8       	lddpc	r8,80003698 <udi_cdc_tx_send+0xcc>
80003660:	48 d9       	lddpc	r9,80003694 <udi_cdc_tx_send+0xc8>
80003662:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
80003666:	48 ea       	lddpc	r10,8000369c <udi_cdc_tx_send+0xd0>
80003668:	0e 0a       	add	r10,r7
8000366a:	0c 9b       	mov	r11,r6
8000366c:	e0 6c 00 81 	mov	r12,129
80003670:	f0 1f 00 0c 	mcall	800036a0 <udi_cdc_tx_send+0xd4>
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003678:	00 00       	add	r0,r0
8000367a:	07 fe       	ld.ub	lr,r3[0x7]
8000367c:	80 00       	ld.sh	r0,r0[0x0]
8000367e:	23 c2       	sub	r2,60
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	23 fe       	sub	lr,63
80003684:	00 00       	add	r0,r0
80003686:	07 fa       	ld.ub	r10,r3[0x7]
80003688:	80 00       	ld.sh	r0,r0[0x0]
8000368a:	23 f2       	sub	r2,63
8000368c:	00 00       	add	r0,r0
8000368e:	07 6f       	ld.uh	pc,--r3
80003690:	00 00       	add	r0,r0
80003692:	08 81       	andn	r1,r4
80003694:	00 00       	add	r0,r0
80003696:	07 70       	ld.ub	r0,--r3
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	36 a4       	mov	r4,106
8000369c:	00 00       	add	r0,r0
8000369e:	07 74       	ld.ub	r4,--r3
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	2a c8       	sub	r8,-84

800036a4 <udi_cdc_data_sent>:
	udi_cdc_rx_start();
}


void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
800036a4:	d4 01       	pushm	lr
	if (UDD_EP_TRANSFER_OK != status) {
800036a6:	58 0c       	cp.w	r12,0
800036a8:	c1 21       	brne	800036cc <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[(udi_cdc_tx_buf_sel==0)?1:0] = 0;
800036aa:	48 a8       	lddpc	r8,800036d0 <udi_cdc_data_sent+0x2c>
800036ac:	11 88       	ld.ub	r8,r8[0x0]
800036ae:	58 08       	cp.w	r8,0
800036b0:	f9 b9 01 00 	movne	r9,0
800036b4:	f9 b9 00 02 	moveq	r9,2
800036b8:	30 08       	mov	r8,0
800036ba:	48 7a       	lddpc	r10,800036d4 <udi_cdc_data_sent+0x30>
800036bc:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send = false;
800036c0:	48 69       	lddpc	r9,800036d8 <udi_cdc_data_sent+0x34>
800036c2:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing = false;
800036c4:	48 69       	lddpc	r9,800036dc <udi_cdc_data_sent+0x38>
800036c6:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send();
800036c8:	f0 1f 00 06 	mcall	800036e0 <udi_cdc_data_sent+0x3c>
800036cc:	d8 02       	popm	pc
800036ce:	00 00       	add	r0,r0
800036d0:	00 00       	add	r0,r0
800036d2:	07 6f       	ld.uh	pc,--r3
800036d4:	00 00       	add	r0,r0
800036d6:	07 70       	ld.ub	r0,--r3
800036d8:	00 00       	add	r0,r0
800036da:	08 81       	andn	r1,r4
800036dc:	00 00       	add	r0,r0
800036de:	07 fe       	ld.ub	lr,r3[0x7]
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	35 cc       	mov	r12,92

800036e4 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
800036e4:	d4 01       	pushm	lr
	udi_cdc_tx_send();
800036e6:	f0 1f 00 02 	mcall	800036ec <udi_cdc_data_sof_notify+0x8>
}
800036ea:	d8 02       	popm	pc
800036ec:	80 00       	ld.sh	r0,r0[0x0]
800036ee:	35 cc       	mov	r12,92

800036f0 <udi_cdc_data_enable>:
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
}

bool udi_cdc_data_enable(void)
{
800036f0:	eb cd 40 c0 	pushm	r6-r7,lr
	// Initialize TX management
	udi_cdc_tx_trans_ongoing = false;
800036f4:	30 06       	mov	r6,0
800036f6:	48 f8       	lddpc	r8,80003730 <udi_cdc_data_enable+0x40>
800036f8:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send = false;
800036fa:	48 f8       	lddpc	r8,80003734 <udi_cdc_data_enable+0x44>
800036fc:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel = 0;
800036fe:	48 f8       	lddpc	r8,80003738 <udi_cdc_data_enable+0x48>
80003700:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[0] = 0;
80003702:	48 f8       	lddpc	r8,8000373c <udi_cdc_data_enable+0x4c>
80003704:	30 07       	mov	r7,0
80003706:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[1] = 0;
80003708:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num = 0;
8000370a:	48 e8       	lddpc	r8,80003740 <udi_cdc_data_enable+0x50>
8000370c:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send();
8000370e:	f0 1f 00 0e 	mcall	80003744 <udi_cdc_data_enable+0x54>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing = false;
80003712:	48 e8       	lddpc	r8,80003748 <udi_cdc_data_enable+0x58>
80003714:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel = 0;
80003716:	48 e8       	lddpc	r8,8000374c <udi_cdc_data_enable+0x5c>
80003718:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[0] = 0;
8000371a:	48 e8       	lddpc	r8,80003750 <udi_cdc_data_enable+0x60>
8000371c:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos = 0;
8000371e:	48 e8       	lddpc	r8,80003754 <udi_cdc_data_enable+0x64>
80003720:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running = udi_cdc_rx_start();
80003722:	f0 1f 00 0e 	mcall	80003758 <udi_cdc_data_enable+0x68>
80003726:	48 e8       	lddpc	r8,8000375c <udi_cdc_data_enable+0x6c>
80003728:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running;
8000372a:	11 8c       	ld.ub	r12,r8[0x0]
}
8000372c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003730:	00 00       	add	r0,r0
80003732:	07 fe       	ld.ub	lr,r3[0x7]
80003734:	00 00       	add	r0,r0
80003736:	08 81       	andn	r1,r4
80003738:	00 00       	add	r0,r0
8000373a:	07 6f       	ld.uh	pc,--r3
8000373c:	00 00       	add	r0,r0
8000373e:	07 70       	ld.ub	r0,--r3
80003740:	00 00       	add	r0,r0
80003742:	07 fa       	ld.ub	r10,r3[0x7]
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	35 cc       	mov	r12,92
80003748:	00 00       	add	r0,r0
8000374a:	08 80       	andn	r0,r4
8000374c:	00 00       	add	r0,r0
8000374e:	07 fc       	ld.ub	r12,r3[0x7]
80003750:	00 00       	add	r0,r0
80003752:	07 f4       	ld.ub	r4,r3[0x7]
80003754:	00 00       	add	r0,r0
80003756:	07 f8       	ld.ub	r8,r3[0x7]
80003758:	80 00       	ld.sh	r0,r0[0x0]
8000375a:	34 94       	mov	r4,73
8000375c:	00 00       	add	r0,r0
8000375e:	07 fd       	ld.ub	sp,r3[0x7]

80003760 <udi_cdc_comm_disable>:


void udi_cdc_comm_disable(void)
{
80003760:	d4 01       	pushm	lr
	udi_cdc_running = false;
80003762:	30 09       	mov	r9,0
80003764:	48 38       	lddpc	r8,80003770 <udi_cdc_comm_disable+0x10>
80003766:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
80003768:	f0 1f 00 03 	mcall	80003774 <udi_cdc_comm_disable+0x14>
}
8000376c:	d8 02       	popm	pc
8000376e:	00 00       	add	r0,r0
80003770:	00 00       	add	r0,r0
80003772:	07 fd       	ld.ub	sp,r3[0x7]
80003774:	80 00       	ld.sh	r0,r0[0x0]
80003776:	3f 28       	mov	r8,-14

80003778 <udi_cdc_comm_enable>:

//@}


bool udi_cdc_comm_enable(void)
{
80003778:	d4 01       	pushm	lr
	// Initialize control signal management
	udi_cdc_state = CPU_TO_LE16(0);
8000377a:	30 0a       	mov	r10,0
8000377c:	48 a8       	lddpc	r8,800037a4 <udi_cdc_comm_enable+0x2c>
8000377e:	b0 0a       	st.h	r8[0x0],r10
	uid_cdc_state_msg.value = CPU_TO_LE16(0);
80003780:	48 a8       	lddpc	r8,800037a8 <udi_cdc_comm_enable+0x30>
80003782:	b0 4a       	st.h	r8[0x8],r10

	udi_cdc_line_coding.dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
80003784:	48 a8       	lddpc	r8,800037ac <udi_cdc_comm_enable+0x34>
80003786:	30 09       	mov	r9,0
80003788:	b0 8a       	st.b	r8[0x0],r10
8000378a:	3c 2a       	mov	r10,-62
8000378c:	b0 9a       	st.b	r8[0x1],r10
8000378e:	30 1a       	mov	r10,1
80003790:	b0 aa       	st.b	r8[0x2],r10
80003792:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding.bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
80003794:	b0 c9       	st.b	r8[0x4],r9
	udi_cdc_line_coding.bParityType = UDI_CDC_DEFAULT_PARITY;
80003796:	b0 d9       	st.b	r8[0x5],r9
	udi_cdc_line_coding.bDataBits = UDI_CDC_DEFAULT_DATABITS;
80003798:	30 89       	mov	r9,8
8000379a:	b0 e9       	st.b	r8[0x6],r9
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));

	// Call application callback
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
8000379c:	f0 1f 00 05 	mcall	800037b0 <udi_cdc_comm_enable+0x38>
}
800037a0:	d8 02       	popm	pc
800037a2:	00 00       	add	r0,r0
800037a4:	00 00       	add	r0,r0
800037a6:	08 82       	andn	r2,r4
800037a8:	00 00       	add	r0,r0
800037aa:	00 44       	or	r4,r0
800037ac:	00 00       	add	r0,r0
800037ae:	07 68       	ld.uh	r8,--r3
800037b0:	80 00       	ld.sh	r0,r0[0x0]
800037b2:	3f 1c       	mov	r12,-15

800037b4 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
800037b4:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800037b8:	49 18       	lddpc	r8,800037fc <udc_sof_notify+0x48>
800037ba:	11 89       	ld.ub	r9,r8[0x0]
800037bc:	30 08       	mov	r8,0
800037be:	f0 09 18 00 	cp.b	r9,r8
800037c2:	c1 b0       	breq	800037f8 <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037c4:	48 f8       	lddpc	r8,80003800 <udc_sof_notify+0x4c>
800037c6:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037c8:	70 09       	ld.w	r9,r8[0x0]
800037ca:	13 ca       	ld.ub	r10,r9[0x4]
800037cc:	30 09       	mov	r9,0
800037ce:	f2 0a 18 00 	cp.b	r10,r9
800037d2:	c1 30       	breq	800037f8 <udc_sof_notify+0x44>
800037d4:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037d6:	48 b6       	lddpc	r6,80003800 <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
800037d8:	70 18       	ld.w	r8,r8[0x4]
800037da:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
800037de:	70 48       	ld.w	r8,r8[0x10]
800037e0:	58 08       	cp.w	r8,0
800037e2:	c0 20       	breq	800037e6 <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
800037e4:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800037e6:	2f f7       	sub	r7,-1
800037e8:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037ea:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037ec:	70 09       	ld.w	r9,r8[0x0]
800037ee:	13 c9       	ld.ub	r9,r9[0x4]
800037f0:	ee 09 18 00 	cp.b	r9,r7
800037f4:	fe 9b ff f2 	brhi	800037d8 <udc_sof_notify+0x24>
800037f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800037fc:	00 00       	add	r0,r0
800037fe:	08 8c       	andn	r12,r4
80003800:	00 00       	add	r0,r0
80003802:	08 84       	andn	r4,r4

80003804 <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80003804:	48 78       	lddpc	r8,80003820 <udc_get_eof_conf+0x1c>
80003806:	70 08       	ld.w	r8,r8[0x0]
80003808:	70 08       	ld.w	r8,r8[0x0]
8000380a:	11 aa       	ld.ub	r10,r8[0x2]
8000380c:	11 b9       	ld.ub	r9,r8[0x3]
8000380e:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80003812:	5c c9       	swap.bh	r9
80003814:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
80003818:	f0 0c 00 0c 	add	r12,r8,r12
8000381c:	5e fc       	retal	r12
8000381e:	00 00       	add	r0,r0
80003820:	00 00       	add	r0,r0
80003822:	08 84       	andn	r4,r4

80003824 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80003824:	eb cd 40 e0 	pushm	r5-r7,lr
80003828:	18 97       	mov	r7,r12
8000382a:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration)
8000382c:	49 b8       	lddpc	r8,80003898 <udc_update_iface_desc+0x74>
8000382e:	11 89       	ld.ub	r9,r8[0x0]
80003830:	30 08       	mov	r8,0
80003832:	f0 09 18 00 	cp.b	r9,r8
80003836:	c2 f0       	breq	80003894 <udc_update_iface_desc+0x70>
		return false;

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003838:	49 98       	lddpc	r8,8000389c <udc_update_iface_desc+0x78>
8000383a:	70 08       	ld.w	r8,r8[0x0]
8000383c:	70 08       	ld.w	r8,r8[0x0]
8000383e:	11 c9       	ld.ub	r9,r8[0x4]
80003840:	18 9e       	mov	lr,r12
80003842:	f8 09 18 00 	cp.b	r9,r12
80003846:	e0 88 00 27 	brls	80003894 <udc_update_iface_desc+0x70>
		return false;

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
8000384a:	49 65       	lddpc	r5,800038a0 <udc_update_iface_desc+0x7c>
8000384c:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
8000384e:	f0 1f 00 16 	mcall	800038a4 <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
80003852:	6a 08       	ld.w	r8,r5[0x0]
80003854:	10 3c       	cp.w	r12,r8
80003856:	e0 88 00 1f 	brls	80003894 <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
8000385a:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
8000385c:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
8000385e:	11 9a       	ld.ub	r10,r8[0x1]
80003860:	f6 0a 18 00 	cp.b	r10,r11
80003864:	c0 a1       	brne	80003878 <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber)
80003866:	11 aa       	ld.ub	r10,r8[0x2]
80003868:	0e 9e       	mov	lr,r7
8000386a:	ee 0a 18 00 	cp.b	r10,r7
8000386e:	c0 51       	brne	80003878 <udc_update_iface_desc+0x54>
					&& (setting_num ==
							udc_ptr_iface->
80003870:	11 ba       	ld.ub	r10,r8[0x3]
80003872:	ec 0a 18 00 	cp.b	r10,r6
80003876:	c0 b0       	breq	8000388c <udc_update_iface_desc+0x68>
							bAlternateSetting))
				return true;	// Interface found
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t
80003878:	13 88       	ld.ub	r8,r9[0x0]
8000387a:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
8000387e:	10 3c       	cp.w	r12,r8
80003880:	fe 9b ff ee 	brhi	8000385c <udc_update_iface_desc+0x38>
80003884:	48 79       	lddpc	r9,800038a0 <udc_update_iface_desc+0x7c>
80003886:	93 08       	st.w	r9[0x0],r8
80003888:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000388c:	48 59       	lddpc	r9,800038a0 <udc_update_iface_desc+0x7c>
8000388e:	93 08       	st.w	r9[0x0],r8
80003890:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003894:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003898:	00 00       	add	r0,r0
8000389a:	08 8c       	andn	r12,r4
8000389c:	00 00       	add	r0,r0
8000389e:	08 84       	andn	r4,r4
800038a0:	00 00       	add	r0,r0
800038a2:	08 90       	mov	r0,r4
800038a4:	80 00       	ld.sh	r0,r0[0x0]
800038a6:	38 04       	mov	r4,-128

800038a8 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
800038a8:	eb cd 40 c0 	pushm	r6-r7,lr
800038ac:	18 96       	mov	r6,r12
800038ae:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
800038b0:	f0 1f 00 11 	mcall	800038f4 <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800038b4:	0d 88       	ld.ub	r8,r6[0x0]
800038b6:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038b8:	0c 3c       	cp.w	r12,r6
800038ba:	e0 88 00 19 	brls	800038ec <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038be:	0d 98       	ld.ub	r8,r6[0x1]
800038c0:	30 49       	mov	r9,4
800038c2:	f2 08 18 00 	cp.b	r8,r9
800038c6:	c1 30       	breq	800038ec <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038c8:	ee 08 18 00 	cp.b	r8,r7
800038cc:	c0 a1       	brne	800038e0 <udc_next_desc_in_iface+0x38>
800038ce:	c1 08       	rjmp	800038ee <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038d0:	0d 98       	ld.ub	r8,r6[0x1]
800038d2:	f2 08 18 00 	cp.b	r8,r9
800038d6:	c0 b0       	breq	800038ec <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038d8:	ee 08 18 00 	cp.b	r8,r7
800038dc:	c0 31       	brne	800038e2 <udc_next_desc_in_iface+0x3a>
800038de:	c0 88       	rjmp	800038ee <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038e0:	30 49       	mov	r9,4
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
			return desc;	// Specific descriptor found
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800038e2:	0d 88       	ld.ub	r8,r6[0x0]
800038e4:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038e6:	0c 3c       	cp.w	r12,r6
800038e8:	fe 9b ff f4 	brhi	800038d0 <udc_next_desc_in_iface+0x28>
800038ec:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL;	// No specific descriptor found
}
800038ee:	0c 9c       	mov	r12,r6
800038f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	38 04       	mov	r4,-128

800038f8 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
800038f8:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
800038fa:	48 48       	lddpc	r8,80003908 <udc_valid_address+0x10>
800038fc:	11 bc       	ld.ub	r12,r8[0x3]
800038fe:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80003902:	f0 1f 00 03 	mcall	8000390c <udc_valid_address+0x14>
}
80003906:	d8 02       	popm	pc
80003908:	00 00       	add	r0,r0
8000390a:	0a 0c       	add	r12,r5
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	23 c4       	sub	r4,60

80003910 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
80003910:	eb cd 40 e0 	pushm	r5-r7,lr
80003914:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num))
80003916:	f0 1f 00 12 	mcall	8000395c <udc_iface_enable+0x4c>
8000391a:	c1 f0       	breq	80003958 <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
8000391c:	49 18       	lddpc	r8,80003960 <udc_iface_enable+0x50>
8000391e:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003920:	30 56       	mov	r6,5
80003922:	0c 9b       	mov	r11,r6
80003924:	0e 9c       	mov	r12,r7
80003926:	f0 1f 00 10 	mcall	80003964 <udc_iface_enable+0x54>
8000392a:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
8000392c:	c0 d0       	breq	80003946 <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
						ep_desc->bmAttributes,
						le16_to_cpu
8000392e:	19 ca       	ld.ub	r10,r12[0x4]
80003930:	19 d8       	ld.ub	r8,r12[0x5]
80003932:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
80003936:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80003938:	5c 7a       	castu.h	r10
8000393a:	19 bb       	ld.ub	r11,r12[0x3]
8000393c:	19 ac       	ld.ub	r12,r12[0x2]
8000393e:	f0 1f 00 0b 	mcall	80003968 <udc_iface_enable+0x58>
80003942:	cf 01       	brne	80003922 <udc_iface_enable+0x12>
80003944:	c0 a8       	rjmp	80003958 <udc_iface_enable+0x48>
						(ep_desc->wMaxPacketSize)))
			return false;
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
80003946:	48 a8       	lddpc	r8,8000396c <udc_iface_enable+0x5c>
80003948:	70 08       	ld.w	r8,r8[0x0]
8000394a:	70 18       	ld.w	r8,r8[0x4]
8000394c:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
80003950:	70 0c       	ld.w	r12,r8[0x0]
80003952:	5d 1c       	icall	r12
80003954:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003958:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	38 24       	mov	r4,-126
80003960:	00 00       	add	r0,r0
80003962:	08 90       	mov	r0,r4
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	38 a8       	mov	r8,-118
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	25 b8       	sub	r8,91
8000396c:	00 00       	add	r0,r0
8000396e:	08 84       	andn	r4,r4

80003970 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
80003970:	eb cd 40 e0 	pushm	r5-r7,lr
80003974:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003976:	18 97       	mov	r7,r12
80003978:	30 0b       	mov	r11,0
8000397a:	f0 1f 00 12 	mcall	800039c0 <udc_iface_disable+0x50>
8000397e:	c1 e0       	breq	800039ba <udc_iface_disable+0x4a>
		return false;

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003980:	49 18       	lddpc	r8,800039c4 <udc_iface_disable+0x54>
80003982:	70 08       	ld.w	r8,r8[0x0]
80003984:	70 18       	ld.w	r8,r8[0x4]
80003986:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
8000398a:	6a 3c       	ld.w	r12,r5[0xc]
8000398c:	5d 1c       	icall	r12
8000398e:	18 9b       	mov	r11,r12
80003990:	0c 9c       	mov	r12,r6
80003992:	f0 1f 00 0c 	mcall	800039c0 <udc_iface_disable+0x50>
80003996:	c1 20       	breq	800039ba <udc_iface_disable+0x4a>
		return false;

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003998:	48 c8       	lddpc	r8,800039c8 <udc_iface_disable+0x58>
8000399a:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
8000399c:	30 56       	mov	r6,5
8000399e:	0c 9b       	mov	r11,r6
800039a0:	0e 9c       	mov	r12,r7
800039a2:	f0 1f 00 0b 	mcall	800039cc <udc_iface_disable+0x5c>
800039a6:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
							usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc)
800039a8:	c0 50       	breq	800039b2 <udc_iface_disable+0x42>
				break;
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
800039aa:	19 ac       	ld.ub	r12,r12[0x2]
800039ac:	f0 1f 00 09 	mcall	800039d0 <udc_iface_disable+0x60>
		}
800039b0:	cf 7b       	rjmp	8000399e <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
800039b2:	6a 18       	ld.w	r8,r5[0x4]
800039b4:	5d 18       	icall	r8
800039b6:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
800039ba:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800039be:	00 00       	add	r0,r0
800039c0:	80 00       	ld.sh	r0,r0[0x0]
800039c2:	38 24       	mov	r4,-126
800039c4:	00 00       	add	r0,r0
800039c6:	08 84       	andn	r4,r4
800039c8:	00 00       	add	r0,r0
800039ca:	08 90       	mov	r0,r4
800039cc:	80 00       	ld.sh	r0,r0[0x0]
800039ce:	38 a8       	mov	r8,-118
800039d0:	80 00       	ld.sh	r0,r0[0x0]
800039d2:	25 88       	sub	r8,88

800039d4 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device, 
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
800039d4:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800039d8:	49 38       	lddpc	r8,80003a24 <udc_reset+0x50>
800039da:	11 89       	ld.ub	r9,r8[0x0]
800039dc:	30 08       	mov	r8,0
800039de:	f0 09 18 00 	cp.b	r9,r8
800039e2:	c1 70       	breq	80003a10 <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800039e4:	49 18       	lddpc	r8,80003a28 <udc_reset+0x54>
800039e6:	70 08       	ld.w	r8,r8[0x0]
800039e8:	70 08       	ld.w	r8,r8[0x0]
800039ea:	11 c9       	ld.ub	r9,r8[0x4]
800039ec:	30 08       	mov	r8,0
800039ee:	f0 09 18 00 	cp.b	r9,r8
800039f2:	c0 f0       	breq	80003a10 <udc_reset+0x3c>
800039f4:	30 07       	mov	r7,0
800039f6:	48 d6       	lddpc	r6,80003a28 <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
800039f8:	0e 9c       	mov	r12,r7
800039fa:	f0 1f 00 0d 	mcall	80003a2c <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800039fe:	2f f7       	sub	r7,-1
80003a00:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a02:	6c 08       	ld.w	r8,r6[0x0]
80003a04:	70 08       	ld.w	r8,r8[0x0]
80003a06:	11 c8       	ld.ub	r8,r8[0x4]
80003a08:	ee 08 18 00 	cp.b	r8,r7
80003a0c:	fe 9b ff f6 	brhi	800039f8 <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80003a10:	30 09       	mov	r9,0
80003a12:	48 58       	lddpc	r8,80003a24 <udc_reset+0x50>
80003a14:	b0 89       	st.b	r8[0x0],r9
	if (0 != (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status)) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80003a16:	e0 69 01 00 	mov	r9,256
80003a1a:	48 68       	lddpc	r8,80003a30 <udc_reset+0x5c>
80003a1c:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
80003a1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a22:	00 00       	add	r0,r0
80003a24:	00 00       	add	r0,r0
80003a26:	08 8c       	andn	r12,r4
80003a28:	00 00       	add	r0,r0
80003a2a:	08 84       	andn	r4,r4
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	39 70       	mov	r0,-105
80003a30:	00 00       	add	r0,r0
80003a32:	08 8a       	andn	r10,r4

80003a34 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
80003a34:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
80003a38:	fe f8 04 3c 	ld.w	r8,pc[1084]
80003a3c:	30 09       	mov	r9,0
80003a3e:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
80003a40:	30 0a       	mov	r10,0
80003a42:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003a44:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003a46:	11 88       	ld.ub	r8,r8[0x0]
80003a48:	10 9a       	mov	r10,r8
80003a4a:	f2 08 18 00 	cp.b	r8,r9
80003a4e:	c0 94       	brge	80003a60 <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0)
80003a50:	fe f9 04 24 	ld.w	r9,pc[1060]
80003a54:	92 3b       	ld.sh	r11,r9[0x6]
80003a56:	30 09       	mov	r9,0
80003a58:	f2 0b 19 00 	cp.h	r11,r9
80003a5c:	e0 80 02 0a 	breq	80003e70 <udc_process_setup+0x43c>
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003a60:	10 99       	mov	r9,r8
80003a62:	e2 19 00 60 	andl	r9,0x60,COH
80003a66:	e0 81 01 d9 	brne	80003e18 <udc_process_setup+0x3e4>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003a6a:	f2 0a 18 00 	cp.b	r10,r9
80003a6e:	e0 84 01 01 	brge	80003c70 <udc_process_setup+0x23c>
		// GET Standard Requests 
		if (udd_g_ctrlreq.req.wLength == 0)
80003a72:	fe f9 04 02 	ld.w	r9,pc[1026]
80003a76:	92 39       	ld.sh	r9,r9[0x6]
80003a78:	58 09       	cp.w	r9,0
80003a7a:	e0 80 01 cf 	breq	80003e18 <udc_process_setup+0x3e4>
			return false;	// Error for USB host

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003a7e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003a82:	e0 81 00 9e 	brne	80003bbe <udc_process_setup+0x18a>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003a86:	fe fa 03 ee 	ld.w	r10,pc[1006]
80003a8a:	15 9a       	ld.ub	r10,r10[0x1]
80003a8c:	30 6b       	mov	r11,6
80003a8e:	f6 0a 18 00 	cp.b	r10,r11
80003a92:	c1 a0       	breq	80003ac6 <udc_process_setup+0x92>
80003a94:	30 8b       	mov	r11,8
80003a96:	f6 0a 18 00 	cp.b	r10,r11
80003a9a:	e0 80 00 85 	breq	80003ba4 <udc_process_setup+0x170>
80003a9e:	30 0b       	mov	r11,0
80003aa0:	f6 0a 18 00 	cp.b	r10,r11
80003aa4:	e0 81 00 8d 	brne	80003bbe <udc_process_setup+0x18a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status))
80003aa8:	30 28       	mov	r8,2
80003aaa:	f0 09 19 00 	cp.h	r9,r8
80003aae:	c0 40       	breq	80003ab6 <udc_process_setup+0x82>
80003ab0:	30 0c       	mov	r12,0
80003ab2:	e0 8f 01 af 	bral	80003e10 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(
80003ab6:	30 2b       	mov	r11,2
80003ab8:	fe fc 03 c0 	ld.w	r12,pc[960]
80003abc:	f0 1f 00 f0 	mcall	80003e7c <udc_process_setup+0x448>
80003ac0:	30 1c       	mov	r12,1
80003ac2:	e0 8f 01 a7 	bral	80003e10 <udc_process_setup+0x3dc>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003ac6:	fe f8 03 ae 	ld.w	r8,pc[942]
80003aca:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003acc:	f2 08 16 08 	lsr	r8,r9,0x8
80003ad0:	30 2a       	mov	r10,2
80003ad2:	f4 08 18 00 	cp.b	r8,r10
80003ad6:	c1 00       	breq	80003af6 <udc_process_setup+0xc2>
80003ad8:	30 3a       	mov	r10,3
80003ada:	f4 08 18 00 	cp.b	r8,r10
80003ade:	c2 a0       	breq	80003b32 <udc_process_setup+0xfe>
80003ae0:	30 19       	mov	r9,1
80003ae2:	f2 08 18 00 	cp.b	r8,r9
80003ae6:	c5 d1       	brne	80003ba0 <udc_process_setup+0x16c>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003ae8:	fe f8 03 98 	ld.w	r8,pc[920]
80003aec:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003aee:	19 8b       	ld.ub	r11,r12[0x0]
80003af0:	f0 1f 00 e3 	mcall	80003e7c <udc_process_setup+0x448>
80003af4:	c4 78       	rjmp	80003b82 <udc_process_setup+0x14e>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003af6:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003af8:	fe f8 03 88 	ld.w	r8,pc[904]
80003afc:	70 08       	ld.w	r8,r8[0x0]
80003afe:	f1 38 00 11 	ld.ub	r8,r8[17]
80003b02:	f2 08 18 00 	cp.b	r8,r9
80003b06:	e0 88 00 4d 	brls	80003ba0 <udc_process_setup+0x16c>
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003b0a:	fe f8 03 76 	ld.w	r8,pc[886]
80003b0e:	70 18       	ld.w	r8,r8[0x4]
80003b10:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003b14:	19 a9       	ld.ub	r9,r12[0x2]
80003b16:	19 b8       	ld.ub	r8,r12[0x3]
80003b18:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003b1c:	5c c8       	swap.bh	r8
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
80003b1e:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003b22:	f0 1f 00 d7 	mcall	80003e7c <udc_process_setup+0x448>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003b26:	fe f8 03 4e 	ld.w	r8,pc[846]
80003b2a:	70 28       	ld.w	r8,r8[0x8]
80003b2c:	30 29       	mov	r9,2
80003b2e:	b0 99       	st.b	r8[0x1],r9
80003b30:	c2 98       	rjmp	80003b82 <udc_process_setup+0x14e>
	uint8_t i;
	uint8_t *str;
	uint8_t str_lgt=0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003b32:	5c 59       	castu.b	r9
80003b34:	58 19       	cp.w	r9,1
80003b36:	c1 00       	breq	80003b56 <udc_process_setup+0x122>
80003b38:	58 29       	cp.w	r9,2
80003b3a:	c0 40       	breq	80003b42 <udc_process_setup+0x10e>
80003b3c:	58 09       	cp.w	r9,0
80003b3e:	c0 60       	breq	80003b4a <udc_process_setup+0x116>
80003b40:	c3 08       	rjmp	80003ba0 <udc_process_setup+0x16c>
80003b42:	fe fc 03 42 	ld.w	r12,pc[834]
80003b46:	30 3b       	mov	r11,3
80003b48:	c0 a8       	rjmp	80003b5c <udc_process_setup+0x128>
	case 0:
		udd_set_setup_payload(
80003b4a:	30 4b       	mov	r11,4
80003b4c:	fe fc 03 3c 	ld.w	r12,pc[828]
80003b50:	f0 1f 00 cb 	mcall	80003e7c <udc_process_setup+0x448>
80003b54:	c1 78       	rjmp	80003b82 <udc_process_setup+0x14e>
80003b56:	fe fc 03 36 	ld.w	r12,pc[822]
80003b5a:	30 9b       	mov	r11,9
80003b5c:	fe fa 03 34 	ld.w	r10,pc[820]
80003b60:	2f ea       	sub	r10,-2
80003b62:	18 98       	mov	r8,r12
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80003b64:	11 39       	ld.ub	r9,r8++
80003b66:	5c c9       	swap.bh	r9
80003b68:	14 b9       	st.h	r10++,r9
#endif
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
80003b6a:	f0 0c 01 09 	sub	r9,r8,r12
80003b6e:	f6 09 18 00 	cp.b	r9,r11
80003b72:	cf 93       	brcs	80003b64 <udc_process_setup+0x130>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}
		
		udc_string_desc.header.bLength = 2 + (str_lgt) * 2;
80003b74:	a1 7b       	lsl	r11,0x1
80003b76:	2f eb       	sub	r11,-2
80003b78:	fe fc 03 18 	ld.w	r12,pc[792]
80003b7c:	b8 8b       	st.b	r12[0x0],r11
		udd_set_setup_payload(
80003b7e:	f0 1f 00 c0 	mcall	80003e7c <udc_process_setup+0x448>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size)
80003b82:	fe f8 02 f2 	ld.w	r8,pc[754]
80003b86:	90 39       	ld.sh	r9,r8[0x6]
80003b88:	90 68       	ld.sh	r8,r8[0xc]
80003b8a:	f2 08 19 00 	cp.h	r8,r9
80003b8e:	e0 8b 00 04 	brhi	80003b96 <udc_process_setup+0x162>
80003b92:	30 1c       	mov	r12,1
80003b94:	c3 e9       	rjmp	80003e10 <udc_process_setup+0x3dc>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003b96:	fe f8 02 de 	ld.w	r8,pc[734]
80003b9a:	b0 69       	st.h	r8[0xc],r9
80003b9c:	30 1c       	mov	r12,1
80003b9e:	c3 99       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003ba0:	30 0c       	mov	r12,0
80003ba2:	c3 79       	rjmp	80003e10 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1)
80003ba4:	30 18       	mov	r8,1
80003ba6:	f0 09 19 00 	cp.h	r9,r8
80003baa:	c0 30       	breq	80003bb0 <udc_process_setup+0x17c>
80003bac:	30 0c       	mov	r12,0
80003bae:	c3 19       	rjmp	80003e10 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(&udc_num_configuration,1);
80003bb0:	30 1b       	mov	r11,1
80003bb2:	fe fc 02 e2 	ld.w	r12,pc[738]
80003bb6:	f0 1f 00 b2 	mcall	80003e7c <udc_process_setup+0x448>
80003bba:	30 1c       	mov	r12,1
80003bbc:	c2 a9       	rjmp	80003e10 <udc_process_setup+0x3dc>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003bbe:	58 18       	cp.w	r8,1
80003bc0:	c3 61       	brne	80003c2c <udc_process_setup+0x1f8>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003bc2:	fe fa 02 b2 	ld.w	r10,pc[690]
80003bc6:	15 9b       	ld.ub	r11,r10[0x1]
80003bc8:	30 aa       	mov	r10,10
80003bca:	f4 0b 18 00 	cp.b	r11,r10
80003bce:	c2 f1       	brne	80003c2c <udc_process_setup+0x1f8>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1)
80003bd0:	f0 09 19 00 	cp.h	r9,r8
80003bd4:	c2 a1       	brne	80003c28 <udc_process_setup+0x1f4>
		return false;	// Error in request
	if (!udc_num_configuration)
80003bd6:	fe f8 02 be 	ld.w	r8,pc[702]
80003bda:	11 89       	ld.ub	r9,r8[0x0]
80003bdc:	30 08       	mov	r8,0
80003bde:	f0 09 18 00 	cp.b	r9,r8
80003be2:	c2 30       	breq	80003c28 <udc_process_setup+0x1f4>
		return false;	// The device is not is configured state yet

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003be4:	fe f8 02 90 	ld.w	r8,pc[656]
80003be8:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003bea:	fe f8 02 ae 	ld.w	r8,pc[686]
80003bee:	70 08       	ld.w	r8,r8[0x0]
80003bf0:	70 08       	ld.w	r8,r8[0x0]
80003bf2:	11 c8       	ld.ub	r8,r8[0x4]
80003bf4:	ee 08 18 00 	cp.b	r8,r7
80003bf8:	e0 88 00 18 	brls	80003c28 <udc_process_setup+0x1f4>
		return false;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003bfc:	30 0b       	mov	r11,0
80003bfe:	0e 9c       	mov	r12,r7
80003c00:	f0 1f 00 a7 	mcall	80003e9c <udc_process_setup+0x468>
80003c04:	c1 20       	breq	80003c28 <udc_process_setup+0x1f4>
		return false;
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003c06:	fe f8 02 92 	ld.w	r8,pc[658]
80003c0a:	70 08       	ld.w	r8,r8[0x0]
80003c0c:	70 18       	ld.w	r8,r8[0x4]
80003c0e:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003c12:	70 3c       	ld.w	r12,r8[0xc]
80003c14:	5d 1c       	icall	r12
80003c16:	fe f8 02 8a 	ld.w	r8,pc[650]
80003c1a:	b0 8c       	st.b	r8[0x0],r12
	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003c1c:	30 1b       	mov	r11,1
80003c1e:	10 9c       	mov	r12,r8
80003c20:	f0 1f 00 97 	mcall	80003e7c <udc_process_setup+0x448>
80003c24:	30 1c       	mov	r12,1
80003c26:	cf 58       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003c28:	30 0c       	mov	r12,0
80003c2a:	cf 38       	rjmp	80003e10 <udc_process_setup+0x3dc>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003c2c:	58 28       	cp.w	r8,2
80003c2e:	e0 81 00 f5 	brne	80003e18 <udc_process_setup+0x3e4>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c32:	fe f8 02 42 	ld.w	r8,pc[578]
80003c36:	11 9a       	ld.ub	r10,r8[0x1]
80003c38:	30 08       	mov	r8,0
80003c3a:	f0 0a 18 00 	cp.b	r10,r8
80003c3e:	e0 81 00 e8 	brne	80003e0e <udc_process_setup+0x3da>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status))
80003c42:	30 28       	mov	r8,2
80003c44:	f0 09 19 00 	cp.h	r9,r8
80003c48:	c0 30       	breq	80003c4e <udc_process_setup+0x21a>
80003c4a:	30 0c       	mov	r12,0
80003c4c:	ce 28       	rjmp	80003e10 <udc_process_setup+0x3dc>
		return false;

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003c4e:	fe f8 02 26 	ld.w	r8,pc[550]
80003c52:	11 dc       	ld.ub	r12,r8[0x5]
80003c54:	f0 1f 00 94 	mcall	80003ea4 <udc_process_setup+0x470>
80003c58:	e0 68 01 00 	mov	r8,256
80003c5c:	f9 b8 00 00 	moveq	r8,0
80003c60:	fe fc 02 48 	ld.w	r12,pc[584]
80003c64:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload(
80003c66:	30 2b       	mov	r11,2
80003c68:	f0 1f 00 85 	mcall	80003e7c <udc_process_setup+0x448>
80003c6c:	30 1c       	mov	r12,1
80003c6e:	cd 18       	rjmp	80003e10 <udc_process_setup+0x3dc>
			}
		}
#endif
	} else {
		// SET Standard Requests  
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003c70:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003c74:	c7 71       	brne	80003d62 <udc_process_setup+0x32e>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c76:	fe f9 01 fe 	ld.w	r9,pc[510]
80003c7a:	13 99       	ld.ub	r9,r9[0x1]
80003c7c:	30 3a       	mov	r10,3
80003c7e:	f4 09 18 00 	cp.b	r9,r10
80003c82:	e0 80 00 c6 	breq	80003e0e <udc_process_setup+0x3da>
80003c86:	e0 8b 00 07 	brhi	80003c94 <udc_process_setup+0x260>
80003c8a:	30 1a       	mov	r10,1
80003c8c:	f4 09 18 00 	cp.b	r9,r10
80003c90:	c6 91       	brne	80003d62 <udc_process_setup+0x32e>
80003c92:	c1 78       	rjmp	80003cc0 <udc_process_setup+0x28c>
80003c94:	30 5a       	mov	r10,5
80003c96:	f4 09 18 00 	cp.b	r9,r10
80003c9a:	c0 60       	breq	80003ca6 <udc_process_setup+0x272>
80003c9c:	30 9a       	mov	r10,9
80003c9e:	f4 09 18 00 	cp.b	r9,r10
80003ca2:	c6 01       	brne	80003d62 <udc_process_setup+0x32e>
80003ca4:	c2 28       	rjmp	80003ce8 <udc_process_setup+0x2b4>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003ca6:	4f 48       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003ca8:	90 39       	ld.sh	r9,r8[0x6]
80003caa:	30 08       	mov	r8,0
80003cac:	f0 09 19 00 	cp.h	r9,r8
80003cb0:	c0 30       	breq	80003cb6 <udc_process_setup+0x282>
80003cb2:	30 0c       	mov	r12,0
80003cb4:	ca e8       	rjmp	80003e10 <udc_process_setup+0x3dc>
		return false;

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003cb6:	4f e9       	lddpc	r9,80003eac <udc_process_setup+0x478>
80003cb8:	4e f8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003cba:	91 49       	st.w	r8[0x10],r9
80003cbc:	30 1c       	mov	r12,1
80003cbe:	ca 98       	rjmp	80003e10 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003cc0:	4e d8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003cc2:	90 39       	ld.sh	r9,r8[0x6]
80003cc4:	30 08       	mov	r8,0
80003cc6:	f0 09 19 00 	cp.h	r9,r8
80003cca:	c0 d1       	brne	80003ce4 <udc_process_setup+0x2b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003ccc:	4e a8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003cce:	90 19       	ld.sh	r9,r8[0x2]
80003cd0:	30 18       	mov	r8,1
80003cd2:	f0 09 19 00 	cp.h	r9,r8
80003cd6:	c0 71       	brne	80003ce4 <udc_process_setup+0x2b0>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003cd8:	4e 88       	lddpc	r8,80003e78 <udc_process_setup+0x444>
80003cda:	90 09       	ld.sh	r9,r8[0x0]
80003cdc:	a9 d9       	cbr	r9,0x9
80003cde:	b0 09       	st.h	r8[0x0],r9
80003ce0:	30 1c       	mov	r12,1
80003ce2:	c9 78       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003ce4:	30 0c       	mov	r12,0
80003ce6:	c9 58       	rjmp	80003e10 <udc_process_setup+0x3dc>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength != 0)
80003ce8:	4e 38       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003cea:	90 39       	ld.sh	r9,r8[0x6]
80003cec:	30 08       	mov	r8,0
80003cee:	f0 09 19 00 	cp.h	r9,r8
80003cf2:	c3 41       	brne	80003d5a <udc_process_setup+0x326>
		return false;
	// Authorize configuration only if the address is valid
	if (!udd_getaddress())
80003cf4:	f0 1f 00 6f 	mcall	80003eb0 <udc_process_setup+0x47c>
80003cf8:	c3 10       	breq	80003d5a <udc_process_setup+0x326>
			return false;
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003cfa:	4d f8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003cfc:	11 b9       	ld.ub	r9,r8[0x3]
80003cfe:	4e 18       	lddpc	r8,80003e80 <udc_process_setup+0x44c>
80003d00:	70 08       	ld.w	r8,r8[0x0]
80003d02:	f1 38 00 11 	ld.ub	r8,r8[17]
80003d06:	10 39       	cp.w	r9,r8
80003d08:	e0 89 00 29 	brgt	80003d5a <udc_process_setup+0x326>
				udc_config.confdev_lsfs->bNumConfigurations)
			return false;
	}

	// Reset current configuration
	udc_reset();
80003d0c:	f0 1f 00 6a 	mcall	80003eb4 <udc_process_setup+0x480>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003d10:	4d 98       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003d12:	11 b8       	ld.ub	r8,r8[0x3]
80003d14:	4e 09       	lddpc	r9,80003e94 <udc_process_setup+0x460>
80003d16:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003d18:	58 08       	cp.w	r8,0
80003d1a:	c2 20       	breq	80003d5e <udc_process_setup+0x32a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003d1c:	20 18       	sub	r8,1
80003d1e:	4d 99       	lddpc	r9,80003e80 <udc_process_setup+0x44c>
80003d20:	72 19       	ld.w	r9,r9[0x4]
80003d22:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003d26:	4d d9       	lddpc	r9,80003e98 <udc_process_setup+0x464>
80003d28:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d2a:	70 08       	ld.w	r8,r8[0x0]
80003d2c:	11 c9       	ld.ub	r9,r8[0x4]
80003d2e:	30 08       	mov	r8,0
80003d30:	f0 09 18 00 	cp.b	r9,r8
80003d34:	c1 50       	breq	80003d5e <udc_process_setup+0x32a>
80003d36:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d38:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d3a:	4d 86       	lddpc	r6,80003e98 <udc_process_setup+0x464>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d3c:	0a 9b       	mov	r11,r5
80003d3e:	0e 9c       	mov	r12,r7
80003d40:	f0 1f 00 5e 	mcall	80003eb8 <udc_process_setup+0x484>
80003d44:	c0 b0       	breq	80003d5a <udc_process_setup+0x326>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003d46:	2f f7       	sub	r7,-1
80003d48:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d4a:	6c 08       	ld.w	r8,r6[0x0]
80003d4c:	70 08       	ld.w	r8,r8[0x0]
80003d4e:	11 c8       	ld.ub	r8,r8[0x4]
80003d50:	ee 08 18 00 	cp.b	r8,r7
80003d54:	fe 9b ff f4 	brhi	80003d3c <udc_process_setup+0x308>
80003d58:	c0 38       	rjmp	80003d5e <udc_process_setup+0x32a>
80003d5a:	30 0c       	mov	r12,0
80003d5c:	c5 a8       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003d5e:	30 1c       	mov	r12,1
80003d60:	c5 88       	rjmp	80003e10 <udc_process_setup+0x3dc>
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003d62:	58 18       	cp.w	r8,1
80003d64:	c2 21       	brne	80003da8 <udc_process_setup+0x374>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d66:	4c 49       	lddpc	r9,80003e74 <udc_process_setup+0x440>
80003d68:	13 9a       	ld.ub	r10,r9[0x1]
80003d6a:	30 b9       	mov	r9,11
80003d6c:	f2 0a 18 00 	cp.b	r10,r9
80003d70:	c1 c1       	brne	80003da8 <udc_process_setup+0x374>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength != 0)
80003d72:	4c 18       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003d74:	90 39       	ld.sh	r9,r8[0x6]
80003d76:	30 08       	mov	r8,0
80003d78:	f0 09 19 00 	cp.h	r9,r8
80003d7c:	c1 41       	brne	80003da4 <udc_process_setup+0x370>
		return false;	// Error in request
	if (!udc_num_configuration)
80003d7e:	4c 68       	lddpc	r8,80003e94 <udc_process_setup+0x460>
80003d80:	11 89       	ld.ub	r9,r8[0x0]
80003d82:	30 08       	mov	r8,0
80003d84:	f0 09 18 00 	cp.b	r9,r8
80003d88:	c0 e0       	breq	80003da4 <udc_process_setup+0x370>
		return false;	// The device is not is configured state yet


	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003d8a:	4b b8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003d8c:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num))
80003d8e:	11 d7       	ld.ub	r7,r8[0x5]
80003d90:	0e 9c       	mov	r12,r7
80003d92:	f0 1f 00 4b 	mcall	80003ebc <udc_process_setup+0x488>
80003d96:	c0 70       	breq	80003da4 <udc_process_setup+0x370>
		return false;

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003d98:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003d9c:	0e 9c       	mov	r12,r7
80003d9e:	f0 1f 00 47 	mcall	80003eb8 <udc_process_setup+0x484>
80003da2:	c3 78       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003da4:	30 0c       	mov	r12,0
80003da6:	c3 58       	rjmp	80003e10 <udc_process_setup+0x3dc>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003da8:	58 28       	cp.w	r8,2
80003daa:	c3 71       	brne	80003e18 <udc_process_setup+0x3e4>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003dac:	4b 28       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003dae:	11 98       	ld.ub	r8,r8[0x1]
80003db0:	30 19       	mov	r9,1
80003db2:	f2 08 18 00 	cp.b	r8,r9
80003db6:	c0 60       	breq	80003dc2 <udc_process_setup+0x38e>
80003db8:	30 39       	mov	r9,3
80003dba:	f2 08 18 00 	cp.b	r8,r9
80003dbe:	c2 81       	brne	80003e0e <udc_process_setup+0x3da>
80003dc0:	c1 48       	rjmp	80003de8 <udc_process_setup+0x3b4>
 *
 * \return true if success 
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003dc2:	4a d8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003dc4:	90 39       	ld.sh	r9,r8[0x6]
80003dc6:	30 08       	mov	r8,0
80003dc8:	f0 09 19 00 	cp.h	r9,r8
80003dcc:	c0 c1       	brne	80003de4 <udc_process_setup+0x3b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003dce:	4a a8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003dd0:	90 19       	ld.sh	r9,r8[0x2]
80003dd2:	30 08       	mov	r8,0
80003dd4:	f0 09 19 00 	cp.h	r9,r8
80003dd8:	c0 61       	brne	80003de4 <udc_process_setup+0x3b0>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003dda:	4a 78       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003ddc:	11 dc       	ld.ub	r12,r8[0x5]
80003dde:	f0 1f 00 39 	mcall	80003ec0 <udc_process_setup+0x48c>
80003de2:	c1 78       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003de4:	30 0c       	mov	r12,0
80003de6:	c1 58       	rjmp	80003e10 <udc_process_setup+0x3dc>
 * \return true if success 
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003de8:	4a 38       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003dea:	90 39       	ld.sh	r9,r8[0x6]
80003dec:	30 08       	mov	r8,0
80003dee:	f0 09 19 00 	cp.h	r9,r8
80003df2:	c0 c1       	brne	80003e0a <udc_process_setup+0x3d6>
		return false;
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003df4:	4a 08       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003df6:	90 19       	ld.sh	r9,r8[0x2]
80003df8:	30 08       	mov	r8,0
80003dfa:	f0 09 19 00 	cp.h	r9,r8
80003dfe:	c0 61       	brne	80003e0a <udc_process_setup+0x3d6>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e00:	49 d8       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003e02:	11 dc       	ld.ub	r12,r8[0x5]
80003e04:	f0 1f 00 30 	mcall	80003ec4 <udc_process_setup+0x490>
80003e08:	c0 48       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003e0a:	30 0c       	mov	r12,0
80003e0c:	c0 28       	rjmp	80003e10 <udc_process_setup+0x3dc>
80003e0e:	30 0c       	mov	r12,0
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd())
80003e10:	58 0c       	cp.w	r12,0
80003e12:	c0 30       	breq	80003e18 <udc_process_setup+0x3e4>
80003e14:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003e18:	49 78       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003e1a:	11 88       	ld.ub	r8,r8[0x0]
80003e1c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e20:	58 18       	cp.w	r8,1
80003e22:	c2 71       	brne	80003e70 <udc_process_setup+0x43c>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration)
80003e24:	49 c8       	lddpc	r8,80003e94 <udc_process_setup+0x460>
80003e26:	11 89       	ld.ub	r9,r8[0x0]
80003e28:	30 08       	mov	r8,0
80003e2a:	f0 09 18 00 	cp.b	r9,r8
80003e2e:	c2 10       	breq	80003e70 <udc_process_setup+0x43c>
		return false;	// The device is not is configured state yet
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003e30:	49 18       	lddpc	r8,80003e74 <udc_process_setup+0x440>
80003e32:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003e34:	49 98       	lddpc	r8,80003e98 <udc_process_setup+0x464>
80003e36:	70 08       	ld.w	r8,r8[0x0]
80003e38:	70 08       	ld.w	r8,r8[0x0]
80003e3a:	11 c8       	ld.ub	r8,r8[0x4]
80003e3c:	ee 08 18 00 	cp.b	r8,r7
80003e40:	e0 88 00 18 	brls	80003e70 <udc_process_setup+0x43c>
		return false;

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003e44:	0e 96       	mov	r6,r7
80003e46:	30 0b       	mov	r11,0
80003e48:	0e 9c       	mov	r12,r7
80003e4a:	f0 1f 00 15 	mcall	80003e9c <udc_process_setup+0x468>
80003e4e:	c1 10       	breq	80003e70 <udc_process_setup+0x43c>
		return false;
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003e50:	49 28       	lddpc	r8,80003e98 <udc_process_setup+0x464>
80003e52:	70 08       	ld.w	r8,r8[0x0]
80003e54:	70 18       	ld.w	r8,r8[0x4]
80003e56:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003e5a:	6e 3c       	ld.w	r12,r7[0xc]
80003e5c:	5d 1c       	icall	r12
80003e5e:	18 9b       	mov	r11,r12
80003e60:	0c 9c       	mov	r12,r6
80003e62:	f0 1f 00 0f 	mcall	80003e9c <udc_process_setup+0x468>
80003e66:	c0 50       	breq	80003e70 <udc_process_setup+0x43c>
		return false;

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003e68:	6e 2c       	ld.w	r12,r7[0x8]
80003e6a:	5d 1c       	icall	r12
80003e6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e70:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003e74:	00 00       	add	r0,r0
80003e76:	0a 0c       	add	r12,r5
80003e78:	00 00       	add	r0,r0
80003e7a:	08 8a       	andn	r10,r4
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	24 0c       	sub	r12,64
80003e80:	00 00       	add	r0,r0
80003e82:	00 a4       	st.w	r0++,r4
80003e84:	00 00       	add	r0,r0
80003e86:	00 c0       	st.b	r0++,r0
80003e88:	00 00       	add	r0,r0
80003e8a:	00 e4       	st.h	--r0,r4
80003e8c:	00 00       	add	r0,r0
80003e8e:	00 c4       	st.b	r0++,r4
80003e90:	00 00       	add	r0,r0
80003e92:	00 d0       	st.w	--r0,r0
80003e94:	00 00       	add	r0,r0
80003e96:	08 8c       	andn	r12,r4
80003e98:	00 00       	add	r0,r0
80003e9a:	08 84       	andn	r4,r4
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	38 24       	mov	r4,-126
80003ea0:	00 00       	add	r0,r0
80003ea2:	08 88       	andn	r8,r4
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	24 18       	sub	r8,65
80003ea8:	00 00       	add	r0,r0
80003eaa:	08 94       	mov	r4,r4
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	38 f8       	mov	r8,-113
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	23 e6       	sub	r6,62
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	39 d4       	mov	r4,-99
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	39 10       	mov	r0,-111
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	39 70       	mov	r0,-105
80003ec0:	80 00       	ld.sh	r0,r0[0x0]
80003ec2:	24 a8       	sub	r8,74
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	24 2c       	sub	r12,66

80003ec8 <_read>:
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80003ec8:	eb cd 40 fc 	pushm	r2-r7,lr
80003ecc:	20 1d       	sub	sp,4
80003ece:	16 94       	mov	r4,r11
80003ed0:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0)
80003ed2:	58 0c       	cp.w	r12,0
80003ed4:	c0 30       	breq	80003eda <_read+0x12>
80003ed6:	3f f7       	mov	r7,-1
80003ed8:	c1 98       	rjmp	80003f0a <_read+0x42>
		return -1;

	for (; len > 0; --len) {
80003eda:	58 0a       	cp.w	r10,0
80003edc:	e0 89 00 04 	brgt	80003ee4 <_read+0x1c>
80003ee0:	30 07       	mov	r7,0
80003ee2:	c1 48       	rjmp	80003f0a <_read+0x42>
80003ee4:	30 07       	mov	r7,0
		int c;
		ptr_get(stdio_base,&c);
80003ee6:	48 c3       	lddpc	r3,80003f14 <_read+0x4c>
80003ee8:	48 c6       	lddpc	r6,80003f18 <_read+0x50>
80003eea:	1a 92       	mov	r2,sp
80003eec:	66 0c       	ld.w	r12,r3[0x0]
80003eee:	6c 08       	ld.w	r8,r6[0x0]
80003ef0:	1a 9b       	mov	r11,sp
80003ef2:	5d 18       	icall	r8
		if (c < 0)
80003ef4:	40 08       	lddsp	r8,sp[0x0]
80003ef6:	58 08       	cp.w	r8,0
80003ef8:	c0 95       	brlt	80003f0a <_read+0x42>
		break;
		*ptr++ = c;
80003efa:	e8 07 0b 08 	st.b	r4[r7],r8
		++nChars;
80003efe:	2f f7       	sub	r7,-1
// GCC AVR32 implementation
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
80003f00:	ea 07 01 08 	sub	r8,r5,r7
	int nChars = 0;

	if (file != 0)
		return -1;

	for (; len > 0; --len) {
80003f04:	58 08       	cp.w	r8,0
80003f06:	fe 99 ff f3 	brgt	80003eec <_read+0x24>
		break;
		*ptr++ = c;
		++nChars;
	}
	return nChars;
}
80003f0a:	0e 9c       	mov	r12,r7
80003f0c:	2f fd       	sub	sp,-4
80003f0e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003f12:	00 00       	add	r0,r0
80003f14:	00 00       	add	r0,r0
80003f16:	0a 34       	cp.w	r4,r5
80003f18:	00 00       	add	r0,r0
80003f1a:	0a 2c       	rsub	r12,r5

80003f1c <stdio_usb_enable>:
	}
}

bool stdio_usb_enable(void)
{
	stdio_usb_interface_enable = true;
80003f1c:	30 19       	mov	r9,1
80003f1e:	48 28       	lddpc	r8,80003f24 <stdio_usb_enable+0x8>
80003f20:	b0 89       	st.b	r8[0x0],r9
	return true;
}
80003f22:	5e ff       	retal	1
80003f24:	00 00       	add	r0,r0
80003f26:	08 96       	mov	r6,r4

80003f28 <stdio_usb_disable>:

void stdio_usb_disable(void)
{
	stdio_usb_interface_enable = false;
80003f28:	30 09       	mov	r9,0
80003f2a:	48 28       	lddpc	r8,80003f30 <stdio_usb_disable+0x8>
80003f2c:	b0 89       	st.b	r8[0x0],r9
}
80003f2e:	5e fc       	retal	r12
80003f30:	00 00       	add	r0,r0
80003f32:	08 96       	mov	r6,r4

80003f34 <stdio_usb_vbus_event>:
	
	*data = udi_cdc_getc ();
}

void stdio_usb_vbus_event(bool b_high)
{
80003f34:	d4 01       	pushm	lr
	if (b_high) {
80003f36:	58 0c       	cp.w	r12,0
80003f38:	c0 40       	breq	80003f40 <stdio_usb_vbus_event+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003f3a:	f0 1f 00 04 	mcall	80003f48 <stdio_usb_vbus_event+0x14>
80003f3e:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003f40:	f0 1f 00 03 	mcall	80003f4c <stdio_usb_vbus_event+0x18>
80003f44:	d8 02       	popm	pc
80003f46:	00 00       	add	r0,r0
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	28 1c       	sub	r12,-127
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	27 2c       	sub	r12,114

80003f50 <stdio_usb_init>:
{
	stdio_usb_interface_enable = false;
}

void stdio_usb_init (volatile void * usart)
{
80003f50:	d4 01       	pushm	lr
	stdio_base = usart;
80003f52:	48 98       	lddpc	r8,80003f74 <stdio_usb_init+0x24>
80003f54:	91 0c       	st.w	r8[0x0],r12
	ptr_put = stdio_usb_putchar;
80003f56:	48 99       	lddpc	r9,80003f78 <stdio_usb_init+0x28>
80003f58:	48 98       	lddpc	r8,80003f7c <stdio_usb_init+0x2c>
80003f5a:	91 09       	st.w	r8[0x0],r9
	ptr_get = stdio_usb_getchar;
80003f5c:	48 99       	lddpc	r9,80003f80 <stdio_usb_init+0x30>
80003f5e:	48 a8       	lddpc	r8,80003f84 <stdio_usb_init+0x34>
80003f60:	91 09       	st.w	r8[0x0],r9

/*! \brief Start the USB Device stack
 */
static inline void udc_start(void)
{
	udd_enable();
80003f62:	f0 1f 00 0a 	mcall	80003f88 <stdio_usb_init+0x38>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003f66:	f0 1f 00 0a 	mcall	80003f8c <stdio_usb_init+0x3c>
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();

	if (! udc_include_vbus_monitoring ()) {
80003f6a:	c0 41       	brne	80003f72 <stdio_usb_init+0x22>
		stdio_usb_vbus_event (true);
80003f6c:	30 1c       	mov	r12,1
80003f6e:	f0 1f 00 09 	mcall	80003f90 <stdio_usb_init+0x40>
80003f72:	d8 02       	popm	pc
80003f74:	00 00       	add	r0,r0
80003f76:	0a 34       	cp.w	r4,r5
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	3f c0       	mov	r0,-4
80003f7c:	00 00       	add	r0,r0
80003f7e:	0a 30       	cp.w	r0,r5
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3f 94       	mov	r4,-7
80003f84:	00 00       	add	r0,r0
80003f86:	0a 2c       	rsub	r12,r5
80003f88:	80 00       	ld.sh	r0,r0[0x0]
80003f8a:	29 c8       	sub	r8,-100
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	23 c0       	sub	r0,60
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	3f 34       	mov	r4,-13

80003f94 <stdio_usb_getchar>:

	return udi_cdc_putc (data) ? 0 : -1;
}

void stdio_usb_getchar (void volatile * usart, int * data)
{
80003f94:	eb cd 40 80 	pushm	r7,lr
80003f98:	16 97       	mov	r7,r11
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003f9a:	48 88       	lddpc	r8,80003fb8 <stdio_usb_getchar+0x24>
80003f9c:	11 89       	ld.ub	r9,r8[0x0]
80003f9e:	30 08       	mov	r8,0
80003fa0:	f0 09 18 00 	cp.b	r9,r8
80003fa4:	c0 51       	brne	80003fae <stdio_usb_getchar+0x1a>
		*data = 0;  // -1
80003fa6:	30 08       	mov	r8,0
80003fa8:	97 08       	st.w	r11[0x0],r8
		return;
80003faa:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	
	*data = udi_cdc_getc ();
80003fae:	f0 1f 00 04 	mcall	80003fbc <stdio_usb_getchar+0x28>
80003fb2:	8f 0c       	st.w	r7[0x0],r12
80003fb4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fb8:	00 00       	add	r0,r0
80003fba:	08 96       	mov	r6,r4
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	35 18       	mov	r8,81

80003fc0 <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * usart, int data)
{
80003fc0:	d4 01       	pushm	lr
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003fc2:	48 78       	lddpc	r8,80003fdc <stdio_usb_putchar+0x1c>
80003fc4:	11 89       	ld.ub	r9,r8[0x0]
80003fc6:	30 08       	mov	r8,0
80003fc8:	f0 09 18 00 	cp.b	r9,r8
80003fcc:	c0 60       	breq	80003fd8 <stdio_usb_putchar+0x18>
		return 0;  // -1
	}

	return udi_cdc_putc (data) ? 0 : -1;
80003fce:	16 9c       	mov	r12,r11
80003fd0:	f0 1f 00 04 	mcall	80003fe0 <stdio_usb_putchar+0x20>
80003fd4:	c0 21       	brne	80003fd8 <stdio_usb_putchar+0x18>
80003fd6:	dc 0a       	popm	pc,r12=-1
80003fd8:	d8 0a       	popm	pc,r12=0
80003fda:	00 00       	add	r0,r0
80003fdc:	00 00       	add	r0,r0
80003fde:	08 96       	mov	r6,r4
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	34 18       	mov	r8,65

80003fe4 <_write>:

#elif (defined(__GNUC__) && !defined(XMEGA))

	int __attribute__((weak))
	_write (int file, char * ptr, int len)
	{
80003fe4:	eb cd 40 f8 	pushm	r3-r7,lr
80003fe8:	16 94       	mov	r4,r11
80003fea:	14 95       	mov	r5,r10
		int nChars = 0;
	
		if ( (file != 1)
80003fec:	20 1c       	sub	r12,1
80003fee:	58 2c       	cp.w	r12,2
80003ff0:	e0 8b 00 13 	brhi	80004016 <_write+0x32>
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80003ff4:	58 0a       	cp.w	r10,0
80003ff6:	c0 31       	brne	80003ffc <_write+0x18>
80003ff8:	30 07       	mov	r7,0
80003ffa:	c0 f8       	rjmp	80004018 <_write+0x34>
80003ffc:	30 07       	mov	r7,0
			if (ptr_put(stdio_base, *ptr++) < 0) {
80003ffe:	48 93       	lddpc	r3,80004020 <_write+0x3c>
80004000:	48 96       	lddpc	r6,80004024 <_write+0x40>
80004002:	66 0c       	ld.w	r12,r3[0x0]
80004004:	6c 08       	ld.w	r8,r6[0x0]
80004006:	e8 07 07 0b 	ld.ub	r11,r4[r7]
8000400a:	5d 18       	icall	r8
8000400c:	c0 55       	brlt	80004016 <_write+0x32>
				return -1;
			}
			++nChars;
8000400e:	2f f7       	sub	r7,-1
	
		if ( (file != 1)
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80004010:	0e 35       	cp.w	r5,r7
80004012:	cf 81       	brne	80004002 <_write+0x1e>
80004014:	c0 28       	rjmp	80004018 <_write+0x34>
80004016:	3f f7       	mov	r7,-1
				return -1;
			}
			++nChars;
		}
		return nChars;
	}
80004018:	0e 9c       	mov	r12,r7
8000401a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000401e:	00 00       	add	r0,r0
80004020:	00 00       	add	r0,r0
80004022:	0a 34       	cp.w	r4,r5
80004024:	00 00       	add	r0,r0
80004026:	0a 30       	cp.w	r0,r5

80004028 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004028:	f8 c8 ff f8 	sub	r8,r12,-8
8000402c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000402e:	3f f9       	mov	r9,-1
80004030:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004032:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004034:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004036:	30 08       	mov	r8,0
80004038:	99 08       	st.w	r12[0x0],r8
}
8000403a:	5e fc       	retal	r12

8000403c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000403c:	30 08       	mov	r8,0
8000403e:	99 48       	st.w	r12[0x10],r8
}
80004040:	5e fc       	retal	r12

80004042 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004042:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004044:	70 19       	ld.w	r9,r8[0x4]
80004046:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004048:	78 19       	ld.w	r9,r12[0x4]
8000404a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000404c:	70 19       	ld.w	r9,r8[0x4]
8000404e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004050:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004052:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004054:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004056:	78 08       	ld.w	r8,r12[0x0]
80004058:	2f f8       	sub	r8,-1
8000405a:	99 08       	st.w	r12[0x0],r8
}
8000405c:	5e fc       	retal	r12

8000405e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000405e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004060:	5b fa       	cp.w	r10,-1
80004062:	c0 31       	brne	80004068 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004064:	78 48       	ld.w	r8,r12[0x10]
80004066:	c0 c8       	rjmp	8000407e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004068:	f8 c8 ff f8 	sub	r8,r12,-8
8000406c:	70 19       	ld.w	r9,r8[0x4]
8000406e:	72 09       	ld.w	r9,r9[0x0]
80004070:	12 3a       	cp.w	r10,r9
80004072:	c0 63       	brcs	8000407e <vListInsert+0x20>
80004074:	70 18       	ld.w	r8,r8[0x4]
80004076:	70 19       	ld.w	r9,r8[0x4]
80004078:	72 09       	ld.w	r9,r9[0x0]
8000407a:	12 3a       	cp.w	r10,r9
8000407c:	cf c2       	brcc	80004074 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000407e:	70 19       	ld.w	r9,r8[0x4]
80004080:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004082:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004084:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004086:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004088:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000408a:	78 08       	ld.w	r8,r12[0x0]
8000408c:	2f f8       	sub	r8,-1
8000408e:	99 08       	st.w	r12[0x0],r8
}
80004090:	5e fc       	retal	r12

80004092 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004092:	78 18       	ld.w	r8,r12[0x4]
80004094:	78 29       	ld.w	r9,r12[0x8]
80004096:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004098:	78 28       	ld.w	r8,r12[0x8]
8000409a:	78 19       	ld.w	r9,r12[0x4]
8000409c:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000409e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800040a0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800040a2:	18 39       	cp.w	r9,r12
800040a4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800040a8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800040ac:	30 09       	mov	r9,0
800040ae:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800040b0:	70 09       	ld.w	r9,r8[0x0]
800040b2:	20 19       	sub	r9,1
800040b4:	91 09       	st.w	r8[0x0],r9
}
800040b6:	5e fc       	retal	r12

800040b8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800040b8:	e0 68 08 08 	mov	r8,2056
800040bc:	ea 18 08 08 	orh	r8,0x808
800040c0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800040c2:	e0 68 09 09 	mov	r8,2313
800040c6:	ea 18 09 09 	orh	r8,0x909
800040ca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800040cc:	e0 68 0a 0a 	mov	r8,2570
800040d0:	ea 18 0a 0a 	orh	r8,0xa0a
800040d4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800040d6:	e0 68 0b 0b 	mov	r8,2827
800040da:	ea 18 0b 0b 	orh	r8,0xb0b
800040de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800040e0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800040e2:	e0 68 be ef 	mov	r8,48879
800040e6:	ea 18 de ad 	orh	r8,0xdead
800040ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800040ec:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800040ee:	fc 18 00 40 	movh	r8,0x40
800040f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800040f4:	e0 68 00 ff 	mov	r8,255
800040f8:	ea 18 ff 00 	orh	r8,0xff00
800040fc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800040fe:	e0 68 01 01 	mov	r8,257
80004102:	ea 18 01 01 	orh	r8,0x101
80004106:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004108:	e0 68 02 02 	mov	r8,514
8000410c:	ea 18 02 02 	orh	r8,0x202
80004110:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004112:	e0 68 03 03 	mov	r8,771
80004116:	ea 18 03 03 	orh	r8,0x303
8000411a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000411c:	e0 68 04 04 	mov	r8,1028
80004120:	ea 18 04 04 	orh	r8,0x404
80004124:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004126:	e0 68 05 05 	mov	r8,1285
8000412a:	ea 18 05 05 	orh	r8,0x505
8000412e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004130:	e0 68 06 06 	mov	r8,1542
80004134:	ea 18 06 06 	orh	r8,0x606
80004138:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000413a:	e0 68 07 07 	mov	r8,1799
8000413e:	ea 18 07 07 	orh	r8,0x707
80004142:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004144:	30 08       	mov	r8,0
80004146:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004148:	5e fc       	retal	r12
8000414a:	d7 03       	nop

8000414c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000414c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000414e:	48 38       	lddpc	r8,80004158 <vPortEnterCritical+0xc>
80004150:	70 09       	ld.w	r9,r8[0x0]
80004152:	2f f9       	sub	r9,-1
80004154:	91 09       	st.w	r8[0x0],r9
}
80004156:	5e fc       	retal	r12
80004158:	00 00       	add	r0,r0
8000415a:	00 e8       	st.h	--r0,r8

8000415c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000415c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000415e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004160:	30 0a       	mov	r10,0
80004162:	14 9b       	mov	r11,r10
80004164:	49 2c       	lddpc	r12,800041ac <xPortStartScheduler+0x50>
80004166:	f0 1f 00 13 	mcall	800041b0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000416a:	e0 68 2e e0 	mov	r8,12000
8000416e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004172:	30 08       	mov	r8,0
80004174:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004178:	e0 68 09 68 	mov	r8,2408
8000417c:	ea 18 00 00 	orh	r8,0x0
80004180:	70 00       	ld.w	r0,r8[0x0]
80004182:	60 0d       	ld.w	sp,r0[0x0]
80004184:	1b 00       	ld.w	r0,sp++
80004186:	e0 68 00 e8 	mov	r8,232
8000418a:	ea 18 00 00 	orh	r8,0x0
8000418e:	91 00       	st.w	r8[0x0],r0
80004190:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004194:	2f ed       	sub	sp,-8
80004196:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000419a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000419e:	e3 b0 00 00 	mtsr	0x0,r0
800041a2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800041a6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800041aa:	d8 0a       	popm	pc,r12=0
800041ac:	80 00       	ld.sh	r0,r0[0x0]
800041ae:	42 78       	lddsp	r8,sp[0x9c]
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	22 30       	sub	r0,35

800041b4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800041b4:	20 6d       	sub	sp,24
800041b6:	eb cd 00 ff 	pushm	r0-r7
800041ba:	fa c7 ff c0 	sub	r7,sp,-64
800041be:	ee f0 ff f8 	ld.w	r0,r7[-8]
800041c2:	ef 40 ff e0 	st.w	r7[-32],r0
800041c6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800041ca:	ef 40 ff e4 	st.w	r7[-28],r0
800041ce:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800041d2:	e0 68 00 e8 	mov	r8,232
800041d6:	ea 18 00 00 	orh	r8,0x0
800041da:	70 00       	ld.w	r0,r8[0x0]
800041dc:	1a d0       	st.w	--sp,r0
800041de:	f0 1f 00 1a 	mcall	80004244 <LABEL_RET_SCALL_266+0x14>
800041e2:	e0 68 09 68 	mov	r8,2408
800041e6:	ea 18 00 00 	orh	r8,0x0
800041ea:	70 00       	ld.w	r0,r8[0x0]
800041ec:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800041ee:	f0 1f 00 17 	mcall	80004248 <LABEL_RET_SCALL_266+0x18>
	portRESTORE_CONTEXT_SCALL();
800041f2:	e0 68 09 68 	mov	r8,2408
800041f6:	ea 18 00 00 	orh	r8,0x0
800041fa:	70 00       	ld.w	r0,r8[0x0]
800041fc:	60 0d       	ld.w	sp,r0[0x0]
800041fe:	1b 00       	ld.w	r0,sp++
80004200:	e0 68 00 e8 	mov	r8,232
80004204:	ea 18 00 00 	orh	r8,0x0
80004208:	91 00       	st.w	r8[0x0],r0
8000420a:	fa c7 ff d8 	sub	r7,sp,-40
8000420e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004212:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004216:	e0 61 00 e8 	mov	r1,232
8000421a:	ea 11 00 00 	orh	r1,0x0
8000421e:	62 02       	ld.w	r2,r1[0x0]
80004220:	58 02       	cp.w	r2,0
80004222:	c0 70       	breq	80004230 <LABEL_RET_SCALL_266>
80004224:	e4 c2 00 01 	sub	r2,r2,1
80004228:	83 02       	st.w	r1[0x0],r2
8000422a:	58 02       	cp.w	r2,0
8000422c:	c0 21       	brne	80004230 <LABEL_RET_SCALL_266>
8000422e:	b1 c0       	cbr	r0,0x10

80004230 <LABEL_RET_SCALL_266>:
80004230:	ef 40 ff f8 	st.w	r7[-8],r0
80004234:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004238:	ef 40 ff fc 	st.w	r7[-4],r0
8000423c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004240:	2f ad       	sub	sp,-24
80004242:	d6 13       	rets
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	41 4c       	lddsp	r12,sp[0x50]
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	43 8c       	lddsp	r12,sp[0xe0]

8000424c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000424c:	e1 b8 00 43 	mfsr	r8,0x10c
80004250:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004254:	5e fc       	retal	r12
80004256:	d7 03       	nop

80004258 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004258:	48 78       	lddpc	r8,80004274 <vPortExitCritical+0x1c>
8000425a:	70 08       	ld.w	r8,r8[0x0]
8000425c:	58 08       	cp.w	r8,0
8000425e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004260:	48 58       	lddpc	r8,80004274 <vPortExitCritical+0x1c>
80004262:	70 09       	ld.w	r9,r8[0x0]
80004264:	20 19       	sub	r9,1
80004266:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004268:	70 08       	ld.w	r8,r8[0x0]
8000426a:	58 08       	cp.w	r8,0
8000426c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000426e:	d5 03       	csrf	0x10
80004270:	5e fc       	retal	r12
80004272:	00 00       	add	r0,r0
80004274:	00 00       	add	r0,r0
80004276:	00 e8       	st.h	--r0,r8

80004278 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004278:	eb cd 00 ff 	pushm	r0-r7
8000427c:	e0 68 00 e8 	mov	r8,232
80004280:	ea 18 00 00 	orh	r8,0x0
80004284:	70 00       	ld.w	r0,r8[0x0]
80004286:	1a d0       	st.w	--sp,r0
80004288:	7a 90       	ld.w	r0,sp[0x24]
8000428a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000428e:	58 10       	cp.w	r0,1
80004290:	e0 8b 00 08 	brhi	800042a0 <LABEL_INT_SKIP_SAVE_CONTEXT_240>
80004294:	e0 68 09 68 	mov	r8,2408
80004298:	ea 18 00 00 	orh	r8,0x0
8000429c:	70 00       	ld.w	r0,r8[0x0]
8000429e:	81 0d       	st.w	r0[0x0],sp

800042a0 <LABEL_INT_SKIP_SAVE_CONTEXT_240>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800042a0:	f0 1f 00 12 	mcall	800042e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800042a4:	f0 1f 00 12 	mcall	800042ec <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
		vTaskIncrementTick();
800042a8:	f0 1f 00 12 	mcall	800042f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x1c>
	portEXIT_CRITICAL();
800042ac:	f0 1f 00 12 	mcall	800042f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800042b0:	7a 90       	ld.w	r0,sp[0x24]
800042b2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800042b6:	58 10       	cp.w	r0,1
800042b8:	e0 8b 00 0e 	brhi	800042d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>
800042bc:	f0 1f 00 0c 	mcall	800042ec <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
800042c0:	f0 1f 00 0e 	mcall	800042f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x24>
800042c4:	f0 1f 00 0c 	mcall	800042f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>
800042c8:	e0 68 09 68 	mov	r8,2408
800042cc:	ea 18 00 00 	orh	r8,0x0
800042d0:	70 00       	ld.w	r0,r8[0x0]
800042d2:	60 0d       	ld.w	sp,r0[0x0]

800042d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>:
800042d4:	1b 00       	ld.w	r0,sp++
800042d6:	e0 68 00 e8 	mov	r8,232
800042da:	ea 18 00 00 	orh	r8,0x0
800042de:	91 00       	st.w	r8[0x0],r0
800042e0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800042e4:	d6 03       	rete
800042e6:	00 00       	add	r0,r0
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	42 4c       	lddsp	r12,sp[0x90]
800042ec:	80 00       	ld.sh	r0,r0[0x0]
800042ee:	41 4c       	lddsp	r12,sp[0x50]
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	44 08       	lddsp	r8,sp[0x100]
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	42 58       	lddsp	r8,sp[0x94]
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	43 8c       	lddsp	r12,sp[0xe0]

800042fc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800042fc:	d4 01       	pushm	lr
	vTaskSuspendAll();
800042fe:	f0 1f 00 02 	mcall	80004304 <__malloc_lock+0x8>
}
80004302:	d8 02       	popm	pc
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	43 7c       	lddsp	r12,sp[0xdc]

80004308 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004308:	d4 01       	pushm	lr
	xTaskResumeAll();
8000430a:	f0 1f 00 02 	mcall	80004310 <__malloc_unlock+0x8>
}
8000430e:	d8 02       	popm	pc
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	45 20       	lddsp	r0,sp[0x148]

80004314 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004314:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004316:	48 48       	lddpc	r8,80004324 <_init_startup+0x10>
80004318:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
8000431c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
8000431e:	f0 1f 00 03 	mcall	80004328 <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80004322:	da 0a       	popm	pc,r12=1
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	64 00       	ld.w	r0,r2[0x0]
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	22 60       	sub	r0,38

8000432c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000432c:	eb cd 40 80 	pushm	r7,lr
80004330:	18 97       	mov	r7,r12
	if( pv )
80004332:	58 0c       	cp.w	r12,0
80004334:	c0 80       	breq	80004344 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004336:	f0 1f 00 05 	mcall	80004348 <vPortFree+0x1c>
		{
			free( pv );
8000433a:	0e 9c       	mov	r12,r7
8000433c:	f0 1f 00 04 	mcall	8000434c <vPortFree+0x20>
		}
		xTaskResumeAll();
80004340:	f0 1f 00 04 	mcall	80004350 <vPortFree+0x24>
80004344:	e3 cd 80 80 	ldm	sp++,r7,pc
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	43 7c       	lddsp	r12,sp[0xdc]
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	4b 78       	lddpc	r8,80004428 <vTaskIncrementTick+0x20>
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	45 20       	lddsp	r0,sp[0x148]

80004354 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004354:	eb cd 40 80 	pushm	r7,lr
80004358:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000435a:	f0 1f 00 06 	mcall	80004370 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000435e:	0e 9c       	mov	r12,r7
80004360:	f0 1f 00 05 	mcall	80004374 <pvPortMalloc+0x20>
80004364:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004366:	f0 1f 00 05 	mcall	80004378 <pvPortMalloc+0x24>
		}
	}
	#endif
	
	return pvReturn;
}
8000436a:	0e 9c       	mov	r12,r7
8000436c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	43 7c       	lddsp	r12,sp[0xdc]
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	4b 8c       	lddpc	r12,80004454 <vTaskIncrementTick+0x4c>
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	45 20       	lddsp	r0,sp[0x148]

8000437c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000437c:	48 38       	lddpc	r8,80004388 <vTaskSuspendAll+0xc>
8000437e:	70 09       	ld.w	r9,r8[0x0]
80004380:	2f f9       	sub	r9,-1
80004382:	91 09       	st.w	r8[0x0],r9
}
80004384:	5e fc       	retal	r12
80004386:	00 00       	add	r0,r0
80004388:	00 00       	add	r0,r0
8000438a:	09 98       	ld.ub	r8,r4[0x1]

8000438c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000438c:	49 a8       	lddpc	r8,800043f4 <vTaskSwitchContext+0x68>
8000438e:	70 08       	ld.w	r8,r8[0x0]
80004390:	58 08       	cp.w	r8,0
80004392:	c0 b1       	brne	800043a8 <vTaskSwitchContext+0x1c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004394:	49 98       	lddpc	r8,800043f8 <vTaskSwitchContext+0x6c>
80004396:	70 08       	ld.w	r8,r8[0x0]
80004398:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000439c:	49 89       	lddpc	r9,800043fc <vTaskSwitchContext+0x70>
8000439e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800043a2:	58 08       	cp.w	r8,0
800043a4:	c0 60       	breq	800043b0 <vTaskSwitchContext+0x24>
800043a6:	c1 18       	rjmp	800043c8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800043a8:	30 19       	mov	r9,1
800043aa:	49 68       	lddpc	r8,80004400 <vTaskSwitchContext+0x74>
800043ac:	91 09       	st.w	r8[0x0],r9
800043ae:	5e fc       	retal	r12
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800043b0:	49 28       	lddpc	r8,800043f8 <vTaskSwitchContext+0x6c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043b2:	49 3a       	lddpc	r10,800043fc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800043b4:	70 09       	ld.w	r9,r8[0x0]
800043b6:	20 19       	sub	r9,1
800043b8:	91 09       	st.w	r8[0x0],r9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043ba:	70 09       	ld.w	r9,r8[0x0]
800043bc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800043c0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800043c4:	58 09       	cp.w	r9,0
800043c6:	cf 70       	breq	800043b4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800043c8:	48 c8       	lddpc	r8,800043f8 <vTaskSwitchContext+0x6c>
800043ca:	70 08       	ld.w	r8,r8[0x0]
800043cc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043d0:	48 b9       	lddpc	r9,800043fc <vTaskSwitchContext+0x70>
800043d2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800043d6:	70 19       	ld.w	r9,r8[0x4]
800043d8:	72 19       	ld.w	r9,r9[0x4]
800043da:	91 19       	st.w	r8[0x4],r9
800043dc:	f0 ca ff f8 	sub	r10,r8,-8
800043e0:	14 39       	cp.w	r9,r10
800043e2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800043e6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800043ea:	70 18       	ld.w	r8,r8[0x4]
800043ec:	70 39       	ld.w	r9,r8[0xc]
800043ee:	48 68       	lddpc	r8,80004404 <vTaskSwitchContext+0x78>
800043f0:	91 09       	st.w	r8[0x0],r9
800043f2:	5e fc       	retal	r12
800043f4:	00 00       	add	r0,r0
800043f6:	09 98       	ld.ub	r8,r4[0x1]
800043f8:	00 00       	add	r0,r0
800043fa:	09 d0       	ld.ub	r0,r4[0x5]
800043fc:	00 00       	add	r0,r0
800043fe:	08 b4       	st.h	r4++,r4
80004400:	00 00       	add	r0,r0
80004402:	09 b8       	ld.ub	r8,r4[0x3]
80004404:	00 00       	add	r0,r0
80004406:	09 68       	ld.uh	r8,--r4

80004408 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80004408:	eb cd 40 fe 	pushm	r1-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000440c:	4b a8       	lddpc	r8,800044f4 <vTaskIncrementTick+0xec>
8000440e:	70 08       	ld.w	r8,r8[0x0]
80004410:	58 08       	cp.w	r8,0
80004412:	c6 a1       	brne	800044e6 <vTaskIncrementTick+0xde>
	{
		++xTickCount;
80004414:	4b 98       	lddpc	r8,800044f8 <vTaskIncrementTick+0xf0>
80004416:	70 09       	ld.w	r9,r8[0x0]
80004418:	2f f9       	sub	r9,-1
8000441a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000441c:	70 08       	ld.w	r8,r8[0x0]
8000441e:	58 08       	cp.w	r8,0
80004420:	c1 a1       	brne	80004454 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
80004422:	4b 78       	lddpc	r8,800044fc <vTaskIncrementTick+0xf4>
80004424:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80004426:	4b 79       	lddpc	r9,80004500 <vTaskIncrementTick+0xf8>
80004428:	72 0b       	ld.w	r11,r9[0x0]
8000442a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000442c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000442e:	4b 69       	lddpc	r9,80004504 <vTaskIncrementTick+0xfc>
80004430:	72 0a       	ld.w	r10,r9[0x0]
80004432:	2f fa       	sub	r10,-1
80004434:	93 0a       	st.w	r9[0x0],r10
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80004436:	70 08       	ld.w	r8,r8[0x0]
80004438:	70 08       	ld.w	r8,r8[0x0]
8000443a:	58 08       	cp.w	r8,0
8000443c:	c0 51       	brne	80004446 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000443e:	3f f9       	mov	r9,-1
80004440:	4b 28       	lddpc	r8,80004508 <vTaskIncrementTick+0x100>
80004442:	91 09       	st.w	r8[0x0],r9
80004444:	c0 88       	rjmp	80004454 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80004446:	4a e8       	lddpc	r8,800044fc <vTaskIncrementTick+0xf4>
80004448:	70 08       	ld.w	r8,r8[0x0]
8000444a:	70 38       	ld.w	r8,r8[0xc]
8000444c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000444e:	70 19       	ld.w	r9,r8[0x4]
80004450:	4a e8       	lddpc	r8,80004508 <vTaskIncrementTick+0x100>
80004452:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80004454:	4a 98       	lddpc	r8,800044f8 <vTaskIncrementTick+0xf0>
80004456:	70 09       	ld.w	r9,r8[0x0]
80004458:	4a c8       	lddpc	r8,80004508 <vTaskIncrementTick+0x100>
8000445a:	70 08       	ld.w	r8,r8[0x0]
8000445c:	10 39       	cp.w	r9,r8
8000445e:	c4 83       	brcs	800044ee <vTaskIncrementTick+0xe6>
80004460:	4a 78       	lddpc	r8,800044fc <vTaskIncrementTick+0xf4>
80004462:	70 08       	ld.w	r8,r8[0x0]
80004464:	70 08       	ld.w	r8,r8[0x0]
80004466:	58 08       	cp.w	r8,0
80004468:	c0 c0       	breq	80004480 <vTaskIncrementTick+0x78>
8000446a:	4a 58       	lddpc	r8,800044fc <vTaskIncrementTick+0xf4>
8000446c:	70 08       	ld.w	r8,r8[0x0]
8000446e:	70 38       	ld.w	r8,r8[0xc]
80004470:	70 37       	ld.w	r7,r8[0xc]
80004472:	6e 18       	ld.w	r8,r7[0x4]
80004474:	4a 19       	lddpc	r9,800044f8 <vTaskIncrementTick+0xf0>
80004476:	72 09       	ld.w	r9,r9[0x0]
80004478:	12 38       	cp.w	r8,r9
8000447a:	e0 88 00 14 	brls	800044a2 <vTaskIncrementTick+0x9a>
8000447e:	c0 e8       	rjmp	8000449a <vTaskIncrementTick+0x92>
80004480:	3f f9       	mov	r9,-1
80004482:	4a 28       	lddpc	r8,80004508 <vTaskIncrementTick+0x100>
80004484:	91 09       	st.w	r8[0x0],r9
80004486:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000448a:	6a 08       	ld.w	r8,r5[0x0]
8000448c:	70 38       	ld.w	r8,r8[0xc]
8000448e:	70 37       	ld.w	r7,r8[0xc]
80004490:	6e 18       	ld.w	r8,r7[0x4]
80004492:	64 09       	ld.w	r9,r2[0x0]
80004494:	12 38       	cp.w	r8,r9
80004496:	e0 88 00 0b 	brls	800044ac <vTaskIncrementTick+0xa4>
8000449a:	49 c9       	lddpc	r9,80004508 <vTaskIncrementTick+0x100>
8000449c:	93 08       	st.w	r9[0x0],r8
8000449e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044a2:	49 b4       	lddpc	r4,8000450c <vTaskIncrementTick+0x104>
800044a4:	08 91       	mov	r1,r4
800044a6:	49 b3       	lddpc	r3,80004510 <vTaskIncrementTick+0x108>
800044a8:	49 55       	lddpc	r5,800044fc <vTaskIncrementTick+0xf4>
800044aa:	49 42       	lddpc	r2,800044f8 <vTaskIncrementTick+0xf0>
800044ac:	ee c6 ff fc 	sub	r6,r7,-4
800044b0:	0c 9c       	mov	r12,r6
800044b2:	f0 1f 00 19 	mcall	80004514 <vTaskIncrementTick+0x10c>
800044b6:	6e a8       	ld.w	r8,r7[0x28]
800044b8:	58 08       	cp.w	r8,0
800044ba:	c0 50       	breq	800044c4 <vTaskIncrementTick+0xbc>
800044bc:	ee cc ff e8 	sub	r12,r7,-24
800044c0:	f0 1f 00 15 	mcall	80004514 <vTaskIncrementTick+0x10c>
800044c4:	6e bc       	ld.w	r12,r7[0x2c]
800044c6:	68 08       	ld.w	r8,r4[0x0]
800044c8:	10 3c       	cp.w	r12,r8
800044ca:	e3 fc ba 00 	st.whi	r1[0x0],r12
800044ce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800044d2:	0c 9b       	mov	r11,r6
800044d4:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800044d8:	f0 1f 00 10 	mcall	80004518 <vTaskIncrementTick+0x110>
800044dc:	6a 08       	ld.w	r8,r5[0x0]
800044de:	70 08       	ld.w	r8,r8[0x0]
800044e0:	58 08       	cp.w	r8,0
800044e2:	cd 41       	brne	8000448a <vTaskIncrementTick+0x82>
800044e4:	cc eb       	rjmp	80004480 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800044e6:	48 e8       	lddpc	r8,8000451c <vTaskIncrementTick+0x114>
800044e8:	70 09       	ld.w	r9,r8[0x0]
800044ea:	2f f9       	sub	r9,-1
800044ec:	91 09       	st.w	r8[0x0],r9
800044ee:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044f2:	00 00       	add	r0,r0
800044f4:	00 00       	add	r0,r0
800044f6:	09 98       	ld.ub	r8,r4[0x1]
800044f8:	00 00       	add	r0,r0
800044fa:	09 94       	ld.ub	r4,r4[0x1]
800044fc:	00 00       	add	r0,r0
800044fe:	08 a0       	st.w	r4++,r0
80004500:	00 00       	add	r0,r0
80004502:	08 b0       	st.h	r4++,r0
80004504:	00 00       	add	r0,r0
80004506:	08 ac       	st.w	r4++,r12
80004508:	00 00       	add	r0,r0
8000450a:	00 ec       	st.h	--r0,r12
8000450c:	00 00       	add	r0,r0
8000450e:	09 d0       	ld.ub	r0,r4[0x5]
80004510:	00 00       	add	r0,r0
80004512:	08 b4       	st.h	r4++,r4
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	40 92       	lddsp	r2,sp[0x24]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	40 42       	lddsp	r2,sp[0x10]
8000451c:	00 00       	add	r0,r0
8000451e:	08 98       	mov	r8,r4

80004520 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80004520:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80004522:	f0 1f 00 2c 	mcall	800045d0 <xTaskResumeAll+0xb0>
	{
		--uxSchedulerSuspended;
80004526:	4a c8       	lddpc	r8,800045d4 <xTaskResumeAll+0xb4>
80004528:	70 09       	ld.w	r9,r8[0x0]
8000452a:	20 19       	sub	r9,1
8000452c:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000452e:	70 08       	ld.w	r8,r8[0x0]
80004530:	58 08       	cp.w	r8,0
80004532:	c4 a1       	brne	800045c6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80004534:	4a 98       	lddpc	r8,800045d8 <xTaskResumeAll+0xb8>
80004536:	70 08       	ld.w	r8,r8[0x0]
80004538:	58 08       	cp.w	r8,0
8000453a:	c4 60       	breq	800045c6 <xTaskResumeAll+0xa6>
8000453c:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000453e:	4a 85       	lddpc	r5,800045dc <xTaskResumeAll+0xbc>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80004540:	4a 83       	lddpc	r3,800045e0 <xTaskResumeAll+0xc0>
80004542:	06 90       	mov	r0,r3
80004544:	4a 82       	lddpc	r2,800045e4 <xTaskResumeAll+0xc4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004546:	4a 91       	lddpc	r1,800045e8 <xTaskResumeAll+0xc8>
80004548:	c1 e8       	rjmp	80004584 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000454a:	6a 38       	ld.w	r8,r5[0xc]
8000454c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000454e:	ee cc ff e8 	sub	r12,r7,-24
80004552:	f0 1f 00 27 	mcall	800045ec <xTaskResumeAll+0xcc>
					vListRemove( &( pxTCB->xGenericListItem ) );
80004556:	ee c6 ff fc 	sub	r6,r7,-4
8000455a:	0c 9c       	mov	r12,r6
8000455c:	f0 1f 00 24 	mcall	800045ec <xTaskResumeAll+0xcc>
					prvAddTaskToReadyQueue( pxTCB );
80004560:	6e bc       	ld.w	r12,r7[0x2c]
80004562:	66 08       	ld.w	r8,r3[0x0]
80004564:	10 3c       	cp.w	r12,r8
80004566:	e1 fc ba 00 	st.whi	r0[0x0],r12
8000456a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000456e:	0c 9b       	mov	r11,r6
80004570:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80004574:	f0 1f 00 1f 	mcall	800045f0 <xTaskResumeAll+0xd0>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004578:	62 08       	ld.w	r8,r1[0x0]
8000457a:	6e b9       	ld.w	r9,r7[0x2c]
8000457c:	70 b8       	ld.w	r8,r8[0x2c]
8000457e:	10 39       	cp.w	r9,r8
80004580:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004584:	6a 08       	ld.w	r8,r5[0x0]
80004586:	58 08       	cp.w	r8,0
80004588:	ce 11       	brne	8000454a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000458a:	49 b8       	lddpc	r8,800045f4 <xTaskResumeAll+0xd4>
8000458c:	70 08       	ld.w	r8,r8[0x0]
8000458e:	58 08       	cp.w	r8,0
80004590:	c0 f0       	breq	800045ae <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004592:	49 98       	lddpc	r8,800045f4 <xTaskResumeAll+0xd4>
80004594:	70 08       	ld.w	r8,r8[0x0]
80004596:	58 08       	cp.w	r8,0
80004598:	c1 10       	breq	800045ba <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000459a:	49 77       	lddpc	r7,800045f4 <xTaskResumeAll+0xd4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000459c:	f0 1f 00 17 	mcall	800045f8 <xTaskResumeAll+0xd8>
						--uxMissedTicks;
800045a0:	6e 08       	ld.w	r8,r7[0x0]
800045a2:	20 18       	sub	r8,1
800045a4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800045a6:	6e 08       	ld.w	r8,r7[0x0]
800045a8:	58 08       	cp.w	r8,0
800045aa:	cf 91       	brne	8000459c <xTaskResumeAll+0x7c>
800045ac:	c0 78       	rjmp	800045ba <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800045ae:	58 14       	cp.w	r4,1
800045b0:	c0 50       	breq	800045ba <xTaskResumeAll+0x9a>
800045b2:	49 38       	lddpc	r8,800045fc <xTaskResumeAll+0xdc>
800045b4:	70 08       	ld.w	r8,r8[0x0]
800045b6:	58 18       	cp.w	r8,1
800045b8:	c0 71       	brne	800045c6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800045ba:	30 09       	mov	r9,0
800045bc:	49 08       	lddpc	r8,800045fc <xTaskResumeAll+0xdc>
800045be:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800045c0:	d7 33       	scall
800045c2:	30 17       	mov	r7,1
800045c4:	c0 28       	rjmp	800045c8 <xTaskResumeAll+0xa8>
800045c6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800045c8:	f0 1f 00 0e 	mcall	80004600 <xTaskResumeAll+0xe0>

	return xAlreadyYielded;
}
800045cc:	0e 9c       	mov	r12,r7
800045ce:	d8 32       	popm	r0-r7,pc
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	41 4c       	lddsp	r12,sp[0x50]
800045d4:	00 00       	add	r0,r0
800045d6:	09 98       	ld.ub	r8,r4[0x1]
800045d8:	00 00       	add	r0,r0
800045da:	09 b4       	ld.ub	r4,r4[0x3]
800045dc:	00 00       	add	r0,r0
800045de:	09 6c       	ld.uh	r12,--r4
800045e0:	00 00       	add	r0,r0
800045e2:	09 d0       	ld.ub	r0,r4[0x5]
800045e4:	00 00       	add	r0,r0
800045e6:	08 b4       	st.h	r4++,r4
800045e8:	00 00       	add	r0,r0
800045ea:	09 68       	ld.uh	r8,--r4
800045ec:	80 00       	ld.sh	r0,r0[0x0]
800045ee:	40 92       	lddsp	r2,sp[0x24]
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	40 42       	lddsp	r2,sp[0x10]
800045f4:	00 00       	add	r0,r0
800045f6:	08 98       	mov	r8,r4
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	44 08       	lddsp	r8,sp[0x100]
800045fc:	00 00       	add	r0,r0
800045fe:	09 b8       	ld.ub	r8,r4[0x3]
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	42 58       	lddsp	r8,sp[0x94]

80004604 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004604:	eb cd 40 80 	pushm	r7,lr
80004608:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000460a:	49 08       	lddpc	r8,80004648 <prvAddCurrentTaskToDelayedList+0x44>
8000460c:	70 08       	ld.w	r8,r8[0x0]
8000460e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80004610:	48 f8       	lddpc	r8,8000464c <prvAddCurrentTaskToDelayedList+0x48>
80004612:	70 08       	ld.w	r8,r8[0x0]
80004614:	10 3c       	cp.w	r12,r8
80004616:	c0 a2       	brcc	8000462a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004618:	48 c8       	lddpc	r8,80004648 <prvAddCurrentTaskToDelayedList+0x44>
8000461a:	70 0b       	ld.w	r11,r8[0x0]
8000461c:	48 d8       	lddpc	r8,80004650 <prvAddCurrentTaskToDelayedList+0x4c>
8000461e:	70 0c       	ld.w	r12,r8[0x0]
80004620:	2f cb       	sub	r11,-4
80004622:	f0 1f 00 0d 	mcall	80004654 <prvAddCurrentTaskToDelayedList+0x50>
80004626:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000462a:	48 88       	lddpc	r8,80004648 <prvAddCurrentTaskToDelayedList+0x44>
8000462c:	70 0b       	ld.w	r11,r8[0x0]
8000462e:	48 b8       	lddpc	r8,80004658 <prvAddCurrentTaskToDelayedList+0x54>
80004630:	70 0c       	ld.w	r12,r8[0x0]
80004632:	2f cb       	sub	r11,-4
80004634:	f0 1f 00 08 	mcall	80004654 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80004638:	48 98       	lddpc	r8,8000465c <prvAddCurrentTaskToDelayedList+0x58>
8000463a:	70 08       	ld.w	r8,r8[0x0]
8000463c:	10 37       	cp.w	r7,r8
8000463e:	c0 32       	brcc	80004644 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004640:	48 78       	lddpc	r8,8000465c <prvAddCurrentTaskToDelayedList+0x58>
80004642:	91 07       	st.w	r8[0x0],r7
80004644:	e3 cd 80 80 	ldm	sp++,r7,pc
80004648:	00 00       	add	r0,r0
8000464a:	09 68       	ld.uh	r8,--r4
8000464c:	00 00       	add	r0,r0
8000464e:	09 94       	ld.ub	r4,r4[0x1]
80004650:	00 00       	add	r0,r0
80004652:	08 b0       	st.h	r4++,r0
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	40 5e       	lddsp	lr,sp[0x14]
80004658:	00 00       	add	r0,r0
8000465a:	08 a0       	st.w	r4++,r0
8000465c:	00 00       	add	r0,r0
8000465e:	00 ec       	st.h	--r0,r12

80004660 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80004660:	eb cd 40 c0 	pushm	r6-r7,lr
80004664:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80004666:	58 0c       	cp.w	r12,0
80004668:	c1 10       	breq	8000468a <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000466a:	f0 1f 00 0a 	mcall	80004690 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000466e:	48 a8       	lddpc	r8,80004694 <vTaskDelay+0x34>
80004670:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004672:	48 a8       	lddpc	r8,80004698 <vTaskDelay+0x38>
80004674:	70 0c       	ld.w	r12,r8[0x0]
80004676:	2f cc       	sub	r12,-4
80004678:	f0 1f 00 09 	mcall	8000469c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000467c:	ee 06 00 0c 	add	r12,r7,r6
80004680:	f0 1f 00 08 	mcall	800046a0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80004684:	f0 1f 00 08 	mcall	800046a4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004688:	c0 21       	brne	8000468c <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000468a:	d7 33       	scall
8000468c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004690:	80 00       	ld.sh	r0,r0[0x0]
80004692:	43 7c       	lddsp	r12,sp[0xdc]
80004694:	00 00       	add	r0,r0
80004696:	09 94       	ld.ub	r4,r4[0x1]
80004698:	00 00       	add	r0,r0
8000469a:	09 68       	ld.uh	r8,--r4
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	40 92       	lddsp	r2,sp[0x24]
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	46 04       	lddsp	r4,sp[0x180]
800046a4:	80 00       	ld.sh	r0,r0[0x0]
800046a6:	45 20       	lddsp	r0,sp[0x148]

800046a8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800046a8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800046ac:	49 57       	lddpc	r7,80004700 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800046ae:	49 64       	lddpc	r4,80004704 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800046b0:	49 63       	lddpc	r3,80004708 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800046b2:	49 75       	lddpc	r5,8000470c <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800046b4:	6e 08       	ld.w	r8,r7[0x0]
800046b6:	58 08       	cp.w	r8,0
800046b8:	c1 e0       	breq	800046f4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800046ba:	f0 1f 00 16 	mcall	80004710 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800046be:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800046c0:	f0 1f 00 15 	mcall	80004714 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
800046c4:	58 06       	cp.w	r6,0
800046c6:	c1 70       	breq	800046f4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800046c8:	f0 1f 00 14 	mcall	80004718 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800046cc:	68 38       	ld.w	r8,r4[0xc]
800046ce:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800046d0:	ec cc ff fc 	sub	r12,r6,-4
800046d4:	f0 1f 00 12 	mcall	8000471c <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
800046d8:	66 08       	ld.w	r8,r3[0x0]
800046da:	20 18       	sub	r8,1
800046dc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800046de:	6e 08       	ld.w	r8,r7[0x0]
800046e0:	20 18       	sub	r8,1
800046e2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800046e4:	f0 1f 00 0f 	mcall	80004720 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800046e8:	6c cc       	ld.w	r12,r6[0x30]
800046ea:	f0 1f 00 0f 	mcall	80004724 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
800046ee:	0c 9c       	mov	r12,r6
800046f0:	f0 1f 00 0d 	mcall	80004724 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800046f4:	6a 08       	ld.w	r8,r5[0x0]
800046f6:	58 18       	cp.w	r8,1
800046f8:	fe 98 ff de 	brls	800046b4 <prvIdleTask+0xc>
			{
				taskYIELD();
800046fc:	d7 33       	scall
800046fe:	cd bb       	rjmp	800046b4 <prvIdleTask+0xc>
80004700:	00 00       	add	r0,r0
80004702:	08 a8       	st.w	r4++,r8
80004704:	00 00       	add	r0,r0
80004706:	09 54       	ld.sh	r4,--r4
80004708:	00 00       	add	r0,r0
8000470a:	09 b4       	ld.ub	r4,r4[0x3]
8000470c:	00 00       	add	r0,r0
8000470e:	08 b4       	st.h	r4++,r4
80004710:	80 00       	ld.sh	r0,r0[0x0]
80004712:	43 7c       	lddsp	r12,sp[0xdc]
80004714:	80 00       	ld.sh	r0,r0[0x0]
80004716:	45 20       	lddsp	r0,sp[0x148]
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	41 4c       	lddsp	r12,sp[0x50]
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	40 92       	lddsp	r2,sp[0x24]
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	42 58       	lddsp	r8,sp[0x94]
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	43 2c       	lddsp	r12,sp[0xc8]

80004728 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004728:	d4 31       	pushm	r0-r7,lr
8000472a:	20 1d       	sub	sp,4
8000472c:	fa c4 ff d8 	sub	r4,sp,-40
80004730:	50 0c       	stdsp	sp[0x0],r12
80004732:	16 91       	mov	r1,r11
80004734:	14 97       	mov	r7,r10
80004736:	12 90       	mov	r0,r9
80004738:	10 93       	mov	r3,r8
8000473a:	68 02       	ld.w	r2,r4[0x0]
8000473c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000473e:	34 4c       	mov	r12,68
80004740:	f0 1f 00 5b 	mcall	800048ac <xTaskGenericCreate+0x184>
80004744:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004746:	c0 31       	brne	8000474c <xTaskGenericCreate+0x24>
80004748:	3f fc       	mov	r12,-1
8000474a:	ca d8       	rjmp	800048a4 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000474c:	58 06       	cp.w	r6,0
8000474e:	e0 81 00 ad 	brne	800048a8 <xTaskGenericCreate+0x180>
80004752:	0e 9c       	mov	r12,r7
80004754:	5c 7c       	castu.h	r12
80004756:	a3 6c       	lsl	r12,0x2
80004758:	f0 1f 00 55 	mcall	800048ac <xTaskGenericCreate+0x184>
8000475c:	18 96       	mov	r6,r12
8000475e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004760:	c0 61       	brne	8000476c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004762:	0a 9c       	mov	r12,r5
80004764:	f0 1f 00 53 	mcall	800048b0 <xTaskGenericCreate+0x188>
80004768:	3f fc       	mov	r12,-1
8000476a:	c9 d8       	rjmp	800048a4 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000476c:	5c 77       	castu.h	r7
8000476e:	ee 0a 15 02 	lsl	r10,r7,0x2
80004772:	e0 6b 00 a5 	mov	r11,165
80004776:	0c 9c       	mov	r12,r6
80004778:	f0 1f 00 4f 	mcall	800048b4 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000477c:	ee c6 00 01 	sub	r6,r7,1
80004780:	6a c8       	ld.w	r8,r5[0x30]
80004782:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004786:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000478a:	31 0a       	mov	r10,16
8000478c:	02 9b       	mov	r11,r1
8000478e:	ea cc ff cc 	sub	r12,r5,-52
80004792:	f0 1f 00 4a 	mcall	800048b8 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004796:	30 08       	mov	r8,0
80004798:	eb 68 00 43 	st.b	r5[67],r8
8000479c:	58 73       	cp.w	r3,7
8000479e:	e6 07 17 80 	movls	r7,r3
800047a2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800047a6:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800047a8:	ea c4 ff fc 	sub	r4,r5,-4
800047ac:	08 9c       	mov	r12,r4
800047ae:	f0 1f 00 44 	mcall	800048bc <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800047b2:	ea cc ff e8 	sub	r12,r5,-24
800047b6:	f0 1f 00 42 	mcall	800048bc <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800047ba:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800047bc:	ee 07 11 08 	rsub	r7,r7,8
800047c0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800047c2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800047c4:	00 9a       	mov	r10,r0
800047c6:	40 0b       	lddsp	r11,sp[0x0]
800047c8:	0c 9c       	mov	r12,r6
800047ca:	f0 1f 00 3e 	mcall	800048c0 <xTaskGenericCreate+0x198>
800047ce:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800047d0:	58 02       	cp.w	r2,0
800047d2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800047d6:	f0 1f 00 3c 	mcall	800048c4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
800047da:	4b c8       	lddpc	r8,800048c8 <xTaskGenericCreate+0x1a0>
800047dc:	70 09       	ld.w	r9,r8[0x0]
800047de:	2f f9       	sub	r9,-1
800047e0:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800047e2:	4b b8       	lddpc	r8,800048cc <xTaskGenericCreate+0x1a4>
800047e4:	70 08       	ld.w	r8,r8[0x0]
800047e6:	58 08       	cp.w	r8,0
800047e8:	c2 61       	brne	80004834 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800047ea:	4b 98       	lddpc	r8,800048cc <xTaskGenericCreate+0x1a4>
800047ec:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800047ee:	4b 78       	lddpc	r8,800048c8 <xTaskGenericCreate+0x1a0>
800047f0:	70 08       	ld.w	r8,r8[0x0]
800047f2:	58 18       	cp.w	r8,1
800047f4:	c2 b1       	brne	8000484a <xTaskGenericCreate+0x122>
800047f6:	4b 77       	lddpc	r7,800048d0 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800047f8:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800047fc:	0e 9c       	mov	r12,r7
800047fe:	f0 1f 00 36 	mcall	800048d4 <xTaskGenericCreate+0x1ac>
80004802:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004804:	0c 37       	cp.w	r7,r6
80004806:	cf b1       	brne	800047fc <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004808:	4b 47       	lddpc	r7,800048d8 <xTaskGenericCreate+0x1b0>
8000480a:	0e 9c       	mov	r12,r7
8000480c:	f0 1f 00 32 	mcall	800048d4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004810:	4b 36       	lddpc	r6,800048dc <xTaskGenericCreate+0x1b4>
80004812:	0c 9c       	mov	r12,r6
80004814:	f0 1f 00 30 	mcall	800048d4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004818:	4b 2c       	lddpc	r12,800048e0 <xTaskGenericCreate+0x1b8>
8000481a:	f0 1f 00 2f 	mcall	800048d4 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000481e:	4b 2c       	lddpc	r12,800048e4 <xTaskGenericCreate+0x1bc>
80004820:	f0 1f 00 2d 	mcall	800048d4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004824:	4b 1c       	lddpc	r12,800048e8 <xTaskGenericCreate+0x1c0>
80004826:	f0 1f 00 2c 	mcall	800048d4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000482a:	4b 18       	lddpc	r8,800048ec <xTaskGenericCreate+0x1c4>
8000482c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000482e:	4b 18       	lddpc	r8,800048f0 <xTaskGenericCreate+0x1c8>
80004830:	91 06       	st.w	r8[0x0],r6
80004832:	c0 c8       	rjmp	8000484a <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004834:	4b 08       	lddpc	r8,800048f4 <xTaskGenericCreate+0x1cc>
80004836:	70 08       	ld.w	r8,r8[0x0]
80004838:	58 08       	cp.w	r8,0
8000483a:	c0 81       	brne	8000484a <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000483c:	4a 48       	lddpc	r8,800048cc <xTaskGenericCreate+0x1a4>
8000483e:	70 08       	ld.w	r8,r8[0x0]
80004840:	70 b8       	ld.w	r8,r8[0x2c]
80004842:	10 33       	cp.w	r3,r8
80004844:	c0 33       	brcs	8000484a <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004846:	4a 28       	lddpc	r8,800048cc <xTaskGenericCreate+0x1a4>
80004848:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000484a:	6a b8       	ld.w	r8,r5[0x2c]
8000484c:	4a b9       	lddpc	r9,800048f8 <xTaskGenericCreate+0x1d0>
8000484e:	72 09       	ld.w	r9,r9[0x0]
80004850:	12 38       	cp.w	r8,r9
80004852:	e0 88 00 04 	brls	8000485a <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004856:	4a 99       	lddpc	r9,800048f8 <xTaskGenericCreate+0x1d0>
80004858:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000485a:	4a 98       	lddpc	r8,800048fc <xTaskGenericCreate+0x1d4>
8000485c:	70 09       	ld.w	r9,r8[0x0]
8000485e:	2f f9       	sub	r9,-1
80004860:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004862:	6a b8       	ld.w	r8,r5[0x2c]
80004864:	4a 79       	lddpc	r9,80004900 <xTaskGenericCreate+0x1d8>
80004866:	72 09       	ld.w	r9,r9[0x0]
80004868:	12 38       	cp.w	r8,r9
8000486a:	e0 88 00 04 	brls	80004872 <xTaskGenericCreate+0x14a>
8000486e:	4a 59       	lddpc	r9,80004900 <xTaskGenericCreate+0x1d8>
80004870:	93 08       	st.w	r9[0x0],r8
80004872:	6a bc       	ld.w	r12,r5[0x2c]
80004874:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004878:	08 9b       	mov	r11,r4
8000487a:	49 68       	lddpc	r8,800048d0 <xTaskGenericCreate+0x1a8>
8000487c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004880:	f0 1f 00 21 	mcall	80004904 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80004884:	f0 1f 00 21 	mcall	80004908 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80004888:	49 b8       	lddpc	r8,800048f4 <xTaskGenericCreate+0x1cc>
8000488a:	70 08       	ld.w	r8,r8[0x0]
8000488c:	58 08       	cp.w	r8,0
8000488e:	c0 a0       	breq	800048a2 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80004890:	48 f8       	lddpc	r8,800048cc <xTaskGenericCreate+0x1a4>
80004892:	70 08       	ld.w	r8,r8[0x0]
80004894:	70 b8       	ld.w	r8,r8[0x2c]
80004896:	10 33       	cp.w	r3,r8
80004898:	e0 88 00 05 	brls	800048a2 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
8000489c:	d7 33       	scall
8000489e:	30 1c       	mov	r12,1
800048a0:	c0 28       	rjmp	800048a4 <xTaskGenericCreate+0x17c>
800048a2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800048a4:	2f fd       	sub	sp,-4
800048a6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800048a8:	99 c6       	st.w	r12[0x30],r6
800048aa:	c6 1b       	rjmp	8000476c <xTaskGenericCreate+0x44>
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	43 54       	lddsp	r4,sp[0xd4]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	43 2c       	lddsp	r12,sp[0xc8]
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	51 1c       	stdsp	sp[0x44],r12
800048b8:	80 00       	ld.sh	r0,r0[0x0]
800048ba:	55 ac       	stdsp	sp[0x168],r12
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	40 3c       	lddsp	r12,sp[0xc]
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	40 b8       	lddsp	r8,sp[0x2c]
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	41 4c       	lddsp	r12,sp[0x50]
800048c8:	00 00       	add	r0,r0
800048ca:	09 b4       	ld.ub	r4,r4[0x3]
800048cc:	00 00       	add	r0,r0
800048ce:	09 68       	ld.uh	r8,--r4
800048d0:	00 00       	add	r0,r0
800048d2:	08 b4       	st.h	r4++,r4
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	40 28       	lddsp	r8,sp[0x8]
800048d8:	00 00       	add	r0,r0
800048da:	09 80       	ld.ub	r0,r4[0x0]
800048dc:	00 00       	add	r0,r0
800048de:	09 9c       	ld.ub	r12,r4[0x1]
800048e0:	00 00       	add	r0,r0
800048e2:	09 6c       	ld.uh	r12,--r4
800048e4:	00 00       	add	r0,r0
800048e6:	09 54       	ld.sh	r4,--r4
800048e8:	00 00       	add	r0,r0
800048ea:	09 bc       	ld.ub	r12,r4[0x3]
800048ec:	00 00       	add	r0,r0
800048ee:	08 a0       	st.w	r4++,r0
800048f0:	00 00       	add	r0,r0
800048f2:	08 b0       	st.h	r4++,r0
800048f4:	00 00       	add	r0,r0
800048f6:	08 a4       	st.w	r4++,r4
800048f8:	00 00       	add	r0,r0
800048fa:	08 9c       	mov	r12,r4
800048fc:	00 00       	add	r0,r0
800048fe:	09 b0       	ld.ub	r0,r4[0x3]
80004900:	00 00       	add	r0,r0
80004902:	09 d0       	ld.ub	r0,r4[0x5]
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	40 42       	lddsp	r2,sp[0x10]
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	42 58       	lddsp	r8,sp[0x94]

8000490c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000490c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000490e:	30 09       	mov	r9,0
80004910:	1a d9       	st.w	--sp,r9
80004912:	1a d9       	st.w	--sp,r9
80004914:	1a d9       	st.w	--sp,r9
80004916:	12 98       	mov	r8,r9
80004918:	e0 6a 01 00 	mov	r10,256
8000491c:	48 9b       	lddpc	r11,80004940 <vTaskStartScheduler+0x34>
8000491e:	48 ac       	lddpc	r12,80004944 <vTaskStartScheduler+0x38>
80004920:	f0 1f 00 0a 	mcall	80004948 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80004924:	2f dd       	sub	sp,-12
80004926:	58 1c       	cp.w	r12,1
80004928:	c0 a1       	brne	8000493c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000492a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000492c:	30 19       	mov	r9,1
8000492e:	48 88       	lddpc	r8,8000494c <vTaskStartScheduler+0x40>
80004930:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80004932:	30 09       	mov	r9,0
80004934:	48 78       	lddpc	r8,80004950 <vTaskStartScheduler+0x44>
80004936:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80004938:	f0 1f 00 07 	mcall	80004954 <vTaskStartScheduler+0x48>
8000493c:	d8 02       	popm	pc
8000493e:	00 00       	add	r0,r0
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	67 08       	ld.w	r8,r3[0x40]
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	46 a8       	lddsp	r8,sp[0x1a8]
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	47 28       	lddsp	r8,sp[0x1c8]
8000494c:	00 00       	add	r0,r0
8000494e:	08 a4       	st.w	r4++,r4
80004950:	00 00       	add	r0,r0
80004952:	09 94       	ld.ub	r4,r4[0x1]
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	41 5c       	lddsp	r12,sp[0x54]

80004958 <taskC>:
			gpio_set_pin_high(RESPONSE_B);
		}
	}
};

void taskC(){
80004958:	eb cd 40 e0 	pushm	r5-r7,lr
	while(1){
		if (gpio_pin_is_low(TEST_C)){
8000495c:	31 b7       	mov	r7,27
			gpio_set_pin_low(RESPONSE_C);
8000495e:	32 06       	mov	r6,32
			vTaskDelay(5/portTICK_RATE_MS);
80004960:	30 55       	mov	r5,5
	}
};

void taskC(){
	while(1){
		if (gpio_pin_is_low(TEST_C)){
80004962:	0e 9c       	mov	r12,r7
80004964:	f0 1f 00 07 	mcall	80004980 <taskC+0x28>
80004968:	cf d1       	brne	80004962 <taskC+0xa>
			gpio_set_pin_low(RESPONSE_C);
8000496a:	0c 9c       	mov	r12,r6
8000496c:	f0 1f 00 06 	mcall	80004984 <taskC+0x2c>
			vTaskDelay(5/portTICK_RATE_MS);
80004970:	0a 9c       	mov	r12,r5
80004972:	f0 1f 00 06 	mcall	80004988 <taskC+0x30>
			gpio_set_pin_high(RESPONSE_C);
80004976:	0c 9c       	mov	r12,r6
80004978:	f0 1f 00 05 	mcall	8000498c <taskC+0x34>
8000497c:	cf 3b       	rjmp	80004962 <taskC+0xa>
8000497e:	00 00       	add	r0,r0
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	21 d4       	sub	r4,29
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	22 00       	sub	r0,32
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	46 60       	lddsp	r0,sp[0x198]
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	21 ea       	sub	r10,30

80004990 <taskB>:
			gpio_set_pin_high(RESPONSE_A);
		}
	}
};

void taskB(){
80004990:	eb cd 40 e0 	pushm	r5-r7,lr
	while(1){
		if(gpio_pin_is_low(TEST_B)){
80004994:	31 d7       	mov	r7,29
			gpio_set_pin_low(RESPONSE_B);
80004996:	31 c6       	mov	r6,28
			vTaskDelay(5/portTICK_RATE_MS);
80004998:	30 55       	mov	r5,5
	}
};

void taskB(){
	while(1){
		if(gpio_pin_is_low(TEST_B)){
8000499a:	0e 9c       	mov	r12,r7
8000499c:	f0 1f 00 07 	mcall	800049b8 <taskB+0x28>
800049a0:	cf d1       	brne	8000499a <taskB+0xa>
			gpio_set_pin_low(RESPONSE_B);
800049a2:	0c 9c       	mov	r12,r6
800049a4:	f0 1f 00 06 	mcall	800049bc <taskB+0x2c>
			vTaskDelay(5/portTICK_RATE_MS);
800049a8:	0a 9c       	mov	r12,r5
800049aa:	f0 1f 00 06 	mcall	800049c0 <taskB+0x30>
			gpio_set_pin_high(RESPONSE_B);
800049ae:	0c 9c       	mov	r12,r6
800049b0:	f0 1f 00 05 	mcall	800049c4 <taskB+0x34>
800049b4:	cf 3b       	rjmp	8000499a <taskB+0xa>
800049b6:	00 00       	add	r0,r0
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	21 d4       	sub	r4,29
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	22 00       	sub	r0,32
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	46 60       	lddsp	r0,sp[0x198]
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	21 ea       	sub	r10,30

800049c8 <taskA>:
		vTaskDelay(xDelay);
	}
}
///////////////// Egen kode ////////////////////////////

void taskA(){
800049c8:	eb cd 40 e0 	pushm	r5-r7,lr
	while(1){
		if(gpio_pin_is_low(TEST_A))
800049cc:	31 f7       	mov	r7,31
		{
			gpio_set_pin_low(RESPONSE_A);
800049ce:	31 e6       	mov	r6,30
			vTaskDelay(5/portTICK_RATE_MS);
800049d0:	30 55       	mov	r5,5
}
///////////////// Egen kode ////////////////////////////

void taskA(){
	while(1){
		if(gpio_pin_is_low(TEST_A))
800049d2:	0e 9c       	mov	r12,r7
800049d4:	f0 1f 00 07 	mcall	800049f0 <taskA+0x28>
800049d8:	cf d1       	brne	800049d2 <taskA+0xa>
		{
			gpio_set_pin_low(RESPONSE_A);
800049da:	0c 9c       	mov	r12,r6
800049dc:	f0 1f 00 06 	mcall	800049f4 <taskA+0x2c>
			vTaskDelay(5/portTICK_RATE_MS);
800049e0:	0a 9c       	mov	r12,r5
800049e2:	f0 1f 00 06 	mcall	800049f8 <taskA+0x30>
			gpio_set_pin_high(RESPONSE_A);
800049e6:	0c 9c       	mov	r12,r6
800049e8:	f0 1f 00 05 	mcall	800049fc <taskA+0x34>
800049ec:	cf 3b       	rjmp	800049d2 <taskA+0xa>
800049ee:	00 00       	add	r0,r0
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	21 d4       	sub	r4,29
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	22 00       	sub	r0,32
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	46 60       	lddsp	r0,sp[0x198]
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	21 ea       	sub	r10,30

80004a00 <vBasicTask>:
	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
}

static void vBasicTask(void *pvParameters)
{
80004a00:	eb cd 40 e0 	pushm	r5-r7,lr
	const portTickType xDelay = 1000 / portTICK_RATE_MS;
	
	while(1)
	{
		gpio_toggle_pin(LED0_GPIO);
80004a04:	32 36       	mov	r6,35
		printf("tick\n");
80004a06:	48 77       	lddpc	r7,80004a20 <vBasicTask+0x20>
		
		vTaskDelay(xDelay);
80004a08:	e0 65 03 e8 	mov	r5,1000
{
	const portTickType xDelay = 1000 / portTICK_RATE_MS;
	
	while(1)
	{
		gpio_toggle_pin(LED0_GPIO);
80004a0c:	0c 9c       	mov	r12,r6
80004a0e:	f0 1f 00 06 	mcall	80004a24 <vBasicTask+0x24>
		printf("tick\n");
80004a12:	0e 9c       	mov	r12,r7
80004a14:	f0 1f 00 05 	mcall	80004a28 <vBasicTask+0x28>
		
		vTaskDelay(xDelay);
80004a18:	0a 9c       	mov	r12,r5
80004a1a:	f0 1f 00 05 	mcall	80004a2c <vBasicTask+0x2c>
80004a1e:	cf 7b       	rjmp	80004a0c <vBasicTask+0xc>
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	67 10       	ld.w	r0,r3[0x44]
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	22 16       	sub	r6,33
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	51 80       	stdsp	sp[0x60],r0
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	46 60       	lddsp	r0,sp[0x198]

80004a30 <init>:
#define RESPONSE_B AVR32_PIN_PA28
#define TEST_C AVR32_PIN_PA27
#define RESPONSE_C AVR32_PIN_PB00

void init()
{
80004a30:	eb cd 40 80 	pushm	r7,lr
	// board init
	board_init();
80004a34:	f0 1f 00 0e 	mcall	80004a6c <init+0x3c>
		.dfll_f       = EXAMPLE_TARGET_DFLL_FREQ_HZ,
		.pextra_params = &gc_dfllif_ref_opt
	};
	pcl_configure_clocks(&pcl_dfll_freq_param);
#else
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
80004a38:	30 3a       	mov	r10,3
80004a3a:	e0 6b 1b 00 	mov	r11,6912
80004a3e:	ea 1b 00 b7 	orh	r11,0xb7
80004a42:	30 0c       	mov	r12,0
80004a44:	f0 1f 00 0b 	mcall	80004a70 <init+0x40>
#endif	
	
	// stdio init
	stdio_usb_init(&CONFIG_USART_IF);
80004a48:	fe 7c 1c 00 	mov	r12,-58368
80004a4c:	f0 1f 00 0a 	mcall	80004a74 <init+0x44>

	// Specify that stdout and stdin should not be buffered.

#if defined(__GNUC__) && defined(__AVR32__)
	setbuf(stdout, NULL);
80004a50:	48 a7       	lddpc	r7,80004a78 <init+0x48>
80004a52:	6e 08       	ld.w	r8,r7[0x0]
80004a54:	30 0b       	mov	r11,0
80004a56:	70 1c       	ld.w	r12,r8[0x4]
80004a58:	f0 1f 00 09 	mcall	80004a7c <init+0x4c>
	setbuf(stdin,  NULL);
80004a5c:	6e 08       	ld.w	r8,r7[0x0]
80004a5e:	30 0b       	mov	r11,0
80004a60:	70 0c       	ld.w	r12,r8[0x0]
80004a62:	f0 1f 00 07 	mcall	80004a7c <init+0x4c>
#endif
}
80004a66:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a6a:	00 00       	add	r0,r0
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	20 ec       	sub	r12,14
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	23 a4       	sub	r4,58
80004a74:	80 00       	ld.sh	r0,r0[0x0]
80004a76:	3f 50       	mov	r0,-11
80004a78:	00 00       	add	r0,r0
80004a7a:	01 e0       	ld.ub	r0,r0[0x6]
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	54 74       	stdsp	sp[0x11c],r4

80004a80 <main>:

/*********************************************************************
Functions
*********************************************************************/
int main()
{
80004a80:	eb cd 40 c0 	pushm	r6-r7,lr
	// initialize
	init();
80004a84:	f0 1f 00 28 	mcall	80004b24 <main+0xa4>
	gpio_configure_pin(TEST_A, GPIO_DIR_INPUT | GPIO_INIT_HIGH);
80004a88:	30 2b       	mov	r11,2
80004a8a:	31 fc       	mov	r12,31
80004a8c:	f0 1f 00 27 	mcall	80004b28 <main+0xa8>
	gpio_configure_pin(RESPONSE_A, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004a90:	30 3b       	mov	r11,3
80004a92:	31 ec       	mov	r12,30
80004a94:	f0 1f 00 25 	mcall	80004b28 <main+0xa8>
	gpio_configure_pin(TEST_B, GPIO_DIR_INPUT | GPIO_INIT_HIGH);
80004a98:	30 2b       	mov	r11,2
80004a9a:	31 dc       	mov	r12,29
80004a9c:	f0 1f 00 23 	mcall	80004b28 <main+0xa8>
	gpio_configure_pin(RESPONSE_B, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004aa0:	30 3b       	mov	r11,3
80004aa2:	31 cc       	mov	r12,28
80004aa4:	f0 1f 00 21 	mcall	80004b28 <main+0xa8>
	gpio_configure_pin(TEST_C, GPIO_DIR_INPUT | GPIO_INIT_HIGH);
80004aa8:	30 2b       	mov	r11,2
80004aaa:	31 bc       	mov	r12,27
80004aac:	f0 1f 00 1f 	mcall	80004b28 <main+0xa8>
	gpio_configure_pin(RESPONSE_C, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004ab0:	30 3b       	mov	r11,3
80004ab2:	32 0c       	mov	r12,32
80004ab4:	f0 1f 00 1d 	mcall	80004b28 <main+0xa8>
	// start code from here
	
	// start basic task
	xTaskCreate( taskB, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
80004ab8:	49 d6       	lddpc	r6,80004b2c <main+0xac>
80004aba:	30 07       	mov	r7,0
80004abc:	1a d7       	st.w	--sp,r7
80004abe:	1a d7       	st.w	--sp,r7
80004ac0:	1a d7       	st.w	--sp,r7
80004ac2:	30 18       	mov	r8,1
80004ac4:	0e 99       	mov	r9,r7
80004ac6:	e0 6a 01 00 	mov	r10,256
80004aca:	0c 9b       	mov	r11,r6
80004acc:	49 9c       	lddpc	r12,80004b30 <main+0xb0>
80004ace:	f0 1f 00 1a 	mcall	80004b34 <main+0xb4>
	xTaskCreate( taskA, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
80004ad2:	1a d7       	st.w	--sp,r7
80004ad4:	1a d7       	st.w	--sp,r7
80004ad6:	1a d7       	st.w	--sp,r7
80004ad8:	30 18       	mov	r8,1
80004ada:	0e 99       	mov	r9,r7
80004adc:	e0 6a 01 00 	mov	r10,256
80004ae0:	0c 9b       	mov	r11,r6
80004ae2:	49 6c       	lddpc	r12,80004b38 <main+0xb8>
80004ae4:	f0 1f 00 14 	mcall	80004b34 <main+0xb4>
	xTaskCreate( taskC, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
80004ae8:	1a d7       	st.w	--sp,r7
80004aea:	1a d7       	st.w	--sp,r7
80004aec:	1a d7       	st.w	--sp,r7
80004aee:	30 18       	mov	r8,1
80004af0:	0e 99       	mov	r9,r7
80004af2:	e0 6a 01 00 	mov	r10,256
80004af6:	0c 9b       	mov	r11,r6
80004af8:	49 1c       	lddpc	r12,80004b3c <main+0xbc>
80004afa:	f0 1f 00 0f 	mcall	80004b34 <main+0xb4>
	xTaskCreate( vBasicTask, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 0, NULL);
80004afe:	2f 7d       	sub	sp,-36
80004b00:	1a d7       	st.w	--sp,r7
80004b02:	1a d7       	st.w	--sp,r7
80004b04:	1a d7       	st.w	--sp,r7
80004b06:	0e 98       	mov	r8,r7
80004b08:	0e 99       	mov	r9,r7
80004b0a:	e0 6a 01 00 	mov	r10,256
80004b0e:	0c 9b       	mov	r11,r6
80004b10:	48 cc       	lddpc	r12,80004b40 <main+0xc0>
80004b12:	f0 1f 00 09 	mcall	80004b34 <main+0xb4>
	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
80004b16:	f0 1f 00 0c 	mcall	80004b44 <main+0xc4>
80004b1a:	2f dd       	sub	sp,-12
}
80004b1c:	0e 9c       	mov	r12,r7
80004b1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b22:	00 00       	add	r0,r0
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	4a 30       	lddpc	r0,80004bb0 <_malloc_r+0x14>
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	21 1c       	sub	r12,17
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	67 18       	ld.w	r8,r3[0x44]
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	49 90       	lddpc	r0,80004b94 <malloc+0x8>
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	47 28       	lddsp	r8,sp[0x1c8]
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	49 c8       	lddpc	r8,80004ba8 <_malloc_r+0xc>
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	49 58       	lddpc	r8,80004b90 <malloc+0x4>
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	4a 00       	lddpc	r0,80004bc0 <_malloc_r+0x24>
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	49 0c       	lddpc	r12,80004b84 <free+0xc>

80004b48 <atexit>:
80004b48:	d4 01       	pushm	lr
80004b4a:	30 09       	mov	r9,0
80004b4c:	18 9b       	mov	r11,r12
80004b4e:	12 9a       	mov	r10,r9
80004b50:	12 9c       	mov	r12,r9
80004b52:	e0 a0 05 bb 	rcall	800056c8 <__register_exitproc>
80004b56:	d8 02       	popm	pc

80004b58 <exit>:
80004b58:	d4 21       	pushm	r4-r7,lr
80004b5a:	30 0b       	mov	r11,0
80004b5c:	18 97       	mov	r7,r12
80004b5e:	e0 a0 06 09 	rcall	80005770 <__call_exitprocs>
80004b62:	48 58       	lddpc	r8,80004b74 <exit+0x1c>
80004b64:	70 0c       	ld.w	r12,r8[0x0]
80004b66:	78 a8       	ld.w	r8,r12[0x28]
80004b68:	58 08       	cp.w	r8,0
80004b6a:	c0 20       	breq	80004b6e <exit+0x16>
80004b6c:	5d 18       	icall	r8
80004b6e:	0e 9c       	mov	r12,r7
80004b70:	e0 a0 05 33 	rcall	800055d6 <_exit>
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	67 20       	ld.w	r0,r3[0x48]

80004b78 <free>:
80004b78:	d4 01       	pushm	lr
80004b7a:	48 48       	lddpc	r8,80004b88 <free+0x10>
80004b7c:	18 9b       	mov	r11,r12
80004b7e:	70 0c       	ld.w	r12,r8[0x0]
80004b80:	e0 a0 07 de 	rcall	80005b3c <_free_r>
80004b84:	d8 02       	popm	pc
80004b86:	d7 03       	nop
80004b88:	00 00       	add	r0,r0
80004b8a:	01 e0       	ld.ub	r0,r0[0x6]

80004b8c <malloc>:
80004b8c:	d4 01       	pushm	lr
80004b8e:	48 38       	lddpc	r8,80004b98 <malloc+0xc>
80004b90:	18 9b       	mov	r11,r12
80004b92:	70 0c       	ld.w	r12,r8[0x0]
80004b94:	c0 4c       	rcall	80004b9c <_malloc_r>
80004b96:	d8 02       	popm	pc
80004b98:	00 00       	add	r0,r0
80004b9a:	01 e0       	ld.ub	r0,r0[0x6]

80004b9c <_malloc_r>:
80004b9c:	d4 31       	pushm	r0-r7,lr
80004b9e:	f6 c8 ff f5 	sub	r8,r11,-11
80004ba2:	18 95       	mov	r5,r12
80004ba4:	10 97       	mov	r7,r8
80004ba6:	e0 17 ff f8 	andl	r7,0xfff8
80004baa:	59 68       	cp.w	r8,22
80004bac:	f9 b7 08 10 	movls	r7,16
80004bb0:	16 37       	cp.w	r7,r11
80004bb2:	5f 38       	srlo	r8
80004bb4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004bb8:	c0 50       	breq	80004bc2 <_malloc_r+0x26>
80004bba:	30 c8       	mov	r8,12
80004bbc:	99 38       	st.w	r12[0xc],r8
80004bbe:	e0 8f 01 ef 	bral	80004f9c <_malloc_r+0x400>
80004bc2:	fe b0 fb 9d 	rcall	800042fc <__malloc_lock>
80004bc6:	e0 47 01 f7 	cp.w	r7,503
80004bca:	e0 8b 00 1c 	brhi	80004c02 <_malloc_r+0x66>
80004bce:	ee 03 16 03 	lsr	r3,r7,0x3
80004bd2:	4c c8       	lddpc	r8,80004d00 <_malloc_r+0x164>
80004bd4:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004bd8:	70 36       	ld.w	r6,r8[0xc]
80004bda:	10 36       	cp.w	r6,r8
80004bdc:	c0 61       	brne	80004be8 <_malloc_r+0x4c>
80004bde:	ec c8 ff f8 	sub	r8,r6,-8
80004be2:	70 36       	ld.w	r6,r8[0xc]
80004be4:	10 36       	cp.w	r6,r8
80004be6:	c0 c0       	breq	80004bfe <_malloc_r+0x62>
80004be8:	6c 18       	ld.w	r8,r6[0x4]
80004bea:	e0 18 ff fc 	andl	r8,0xfffc
80004bee:	6c 3a       	ld.w	r10,r6[0xc]
80004bf0:	ec 08 00 09 	add	r9,r6,r8
80004bf4:	0a 9c       	mov	r12,r5
80004bf6:	6c 28       	ld.w	r8,r6[0x8]
80004bf8:	95 28       	st.w	r10[0x8],r8
80004bfa:	91 3a       	st.w	r8[0xc],r10
80004bfc:	c4 68       	rjmp	80004c88 <_malloc_r+0xec>
80004bfe:	2f e3       	sub	r3,-2
80004c00:	c4 c8       	rjmp	80004c98 <_malloc_r+0xfc>
80004c02:	ee 03 16 09 	lsr	r3,r7,0x9
80004c06:	c0 41       	brne	80004c0e <_malloc_r+0x72>
80004c08:	ee 03 16 03 	lsr	r3,r7,0x3
80004c0c:	c2 68       	rjmp	80004c58 <_malloc_r+0xbc>
80004c0e:	58 43       	cp.w	r3,4
80004c10:	e0 8b 00 06 	brhi	80004c1c <_malloc_r+0x80>
80004c14:	ee 03 16 06 	lsr	r3,r7,0x6
80004c18:	2c 83       	sub	r3,-56
80004c1a:	c1 f8       	rjmp	80004c58 <_malloc_r+0xbc>
80004c1c:	59 43       	cp.w	r3,20
80004c1e:	e0 8b 00 04 	brhi	80004c26 <_malloc_r+0x8a>
80004c22:	2a 53       	sub	r3,-91
80004c24:	c1 a8       	rjmp	80004c58 <_malloc_r+0xbc>
80004c26:	e0 43 00 54 	cp.w	r3,84
80004c2a:	e0 8b 00 06 	brhi	80004c36 <_malloc_r+0x9a>
80004c2e:	ee 03 16 0c 	lsr	r3,r7,0xc
80004c32:	29 23       	sub	r3,-110
80004c34:	c1 28       	rjmp	80004c58 <_malloc_r+0xbc>
80004c36:	e0 43 01 54 	cp.w	r3,340
80004c3a:	e0 8b 00 06 	brhi	80004c46 <_malloc_r+0xaa>
80004c3e:	ee 03 16 0f 	lsr	r3,r7,0xf
80004c42:	28 93       	sub	r3,-119
80004c44:	c0 a8       	rjmp	80004c58 <_malloc_r+0xbc>
80004c46:	e0 43 05 54 	cp.w	r3,1364
80004c4a:	e0 88 00 04 	brls	80004c52 <_malloc_r+0xb6>
80004c4e:	37 e3       	mov	r3,126
80004c50:	c0 48       	rjmp	80004c58 <_malloc_r+0xbc>
80004c52:	ee 03 16 12 	lsr	r3,r7,0x12
80004c56:	28 43       	sub	r3,-124
80004c58:	4a aa       	lddpc	r10,80004d00 <_malloc_r+0x164>
80004c5a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004c5e:	74 36       	ld.w	r6,r10[0xc]
80004c60:	c1 98       	rjmp	80004c92 <_malloc_r+0xf6>
80004c62:	6c 19       	ld.w	r9,r6[0x4]
80004c64:	e0 19 ff fc 	andl	r9,0xfffc
80004c68:	f2 07 01 0b 	sub	r11,r9,r7
80004c6c:	58 fb       	cp.w	r11,15
80004c6e:	e0 8a 00 04 	brle	80004c76 <_malloc_r+0xda>
80004c72:	20 13       	sub	r3,1
80004c74:	c1 18       	rjmp	80004c96 <_malloc_r+0xfa>
80004c76:	6c 38       	ld.w	r8,r6[0xc]
80004c78:	58 0b       	cp.w	r11,0
80004c7a:	c0 b5       	brlt	80004c90 <_malloc_r+0xf4>
80004c7c:	6c 2a       	ld.w	r10,r6[0x8]
80004c7e:	ec 09 00 09 	add	r9,r6,r9
80004c82:	0a 9c       	mov	r12,r5
80004c84:	91 2a       	st.w	r8[0x8],r10
80004c86:	95 38       	st.w	r10[0xc],r8
80004c88:	72 18       	ld.w	r8,r9[0x4]
80004c8a:	a1 a8       	sbr	r8,0x0
80004c8c:	93 18       	st.w	r9[0x4],r8
80004c8e:	cb a8       	rjmp	80004e02 <_malloc_r+0x266>
80004c90:	10 96       	mov	r6,r8
80004c92:	14 36       	cp.w	r6,r10
80004c94:	ce 71       	brne	80004c62 <_malloc_r+0xc6>
80004c96:	2f f3       	sub	r3,-1
80004c98:	49 aa       	lddpc	r10,80004d00 <_malloc_r+0x164>
80004c9a:	f4 cc ff f8 	sub	r12,r10,-8
80004c9e:	78 26       	ld.w	r6,r12[0x8]
80004ca0:	18 36       	cp.w	r6,r12
80004ca2:	c6 c0       	breq	80004d7a <_malloc_r+0x1de>
80004ca4:	6c 19       	ld.w	r9,r6[0x4]
80004ca6:	e0 19 ff fc 	andl	r9,0xfffc
80004caa:	f2 07 01 08 	sub	r8,r9,r7
80004cae:	58 f8       	cp.w	r8,15
80004cb0:	e0 89 00 8e 	brgt	80004dcc <_malloc_r+0x230>
80004cb4:	99 3c       	st.w	r12[0xc],r12
80004cb6:	99 2c       	st.w	r12[0x8],r12
80004cb8:	58 08       	cp.w	r8,0
80004cba:	c0 55       	brlt	80004cc4 <_malloc_r+0x128>
80004cbc:	ec 09 00 09 	add	r9,r6,r9
80004cc0:	0a 9c       	mov	r12,r5
80004cc2:	ce 3b       	rjmp	80004c88 <_malloc_r+0xec>
80004cc4:	e0 49 01 ff 	cp.w	r9,511
80004cc8:	e0 8b 00 13 	brhi	80004cee <_malloc_r+0x152>
80004ccc:	a3 99       	lsr	r9,0x3
80004cce:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004cd2:	70 2b       	ld.w	r11,r8[0x8]
80004cd4:	8d 38       	st.w	r6[0xc],r8
80004cd6:	8d 2b       	st.w	r6[0x8],r11
80004cd8:	97 36       	st.w	r11[0xc],r6
80004cda:	91 26       	st.w	r8[0x8],r6
80004cdc:	a3 49       	asr	r9,0x2
80004cde:	74 18       	ld.w	r8,r10[0x4]
80004ce0:	30 1b       	mov	r11,1
80004ce2:	f6 09 09 49 	lsl	r9,r11,r9
80004ce6:	f1 e9 10 09 	or	r9,r8,r9
80004cea:	95 19       	st.w	r10[0x4],r9
80004cec:	c4 78       	rjmp	80004d7a <_malloc_r+0x1de>
80004cee:	f2 0a 16 09 	lsr	r10,r9,0x9
80004cf2:	58 4a       	cp.w	r10,4
80004cf4:	e0 8b 00 08 	brhi	80004d04 <_malloc_r+0x168>
80004cf8:	f2 0a 16 06 	lsr	r10,r9,0x6
80004cfc:	2c 8a       	sub	r10,-56
80004cfe:	c2 18       	rjmp	80004d40 <_malloc_r+0x1a4>
80004d00:	00 00       	add	r0,r0
80004d02:	01 e4       	ld.ub	r4,r0[0x6]
80004d04:	59 4a       	cp.w	r10,20
80004d06:	e0 8b 00 04 	brhi	80004d0e <_malloc_r+0x172>
80004d0a:	2a 5a       	sub	r10,-91
80004d0c:	c1 a8       	rjmp	80004d40 <_malloc_r+0x1a4>
80004d0e:	e0 4a 00 54 	cp.w	r10,84
80004d12:	e0 8b 00 06 	brhi	80004d1e <_malloc_r+0x182>
80004d16:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004d1a:	29 2a       	sub	r10,-110
80004d1c:	c1 28       	rjmp	80004d40 <_malloc_r+0x1a4>
80004d1e:	e0 4a 01 54 	cp.w	r10,340
80004d22:	e0 8b 00 06 	brhi	80004d2e <_malloc_r+0x192>
80004d26:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004d2a:	28 9a       	sub	r10,-119
80004d2c:	c0 a8       	rjmp	80004d40 <_malloc_r+0x1a4>
80004d2e:	e0 4a 05 54 	cp.w	r10,1364
80004d32:	e0 88 00 04 	brls	80004d3a <_malloc_r+0x19e>
80004d36:	37 ea       	mov	r10,126
80004d38:	c0 48       	rjmp	80004d40 <_malloc_r+0x1a4>
80004d3a:	f2 0a 16 12 	lsr	r10,r9,0x12
80004d3e:	28 4a       	sub	r10,-124
80004d40:	4c 8b       	lddpc	r11,80004e60 <_malloc_r+0x2c4>
80004d42:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004d46:	68 28       	ld.w	r8,r4[0x8]
80004d48:	08 38       	cp.w	r8,r4
80004d4a:	c0 e1       	brne	80004d66 <_malloc_r+0x1ca>
80004d4c:	76 19       	ld.w	r9,r11[0x4]
80004d4e:	a3 4a       	asr	r10,0x2
80004d50:	30 1e       	mov	lr,1
80004d52:	fc 0a 09 4a 	lsl	r10,lr,r10
80004d56:	f3 ea 10 0a 	or	r10,r9,r10
80004d5a:	10 99       	mov	r9,r8
80004d5c:	97 1a       	st.w	r11[0x4],r10
80004d5e:	c0 a8       	rjmp	80004d72 <_malloc_r+0x1d6>
80004d60:	70 28       	ld.w	r8,r8[0x8]
80004d62:	08 38       	cp.w	r8,r4
80004d64:	c0 60       	breq	80004d70 <_malloc_r+0x1d4>
80004d66:	70 1a       	ld.w	r10,r8[0x4]
80004d68:	e0 1a ff fc 	andl	r10,0xfffc
80004d6c:	14 39       	cp.w	r9,r10
80004d6e:	cf 93       	brcs	80004d60 <_malloc_r+0x1c4>
80004d70:	70 39       	ld.w	r9,r8[0xc]
80004d72:	8d 39       	st.w	r6[0xc],r9
80004d74:	8d 28       	st.w	r6[0x8],r8
80004d76:	91 36       	st.w	r8[0xc],r6
80004d78:	93 26       	st.w	r9[0x8],r6
80004d7a:	e6 08 14 02 	asr	r8,r3,0x2
80004d7e:	30 1b       	mov	r11,1
80004d80:	4b 84       	lddpc	r4,80004e60 <_malloc_r+0x2c4>
80004d82:	f6 08 09 4b 	lsl	r11,r11,r8
80004d86:	68 18       	ld.w	r8,r4[0x4]
80004d88:	10 3b       	cp.w	r11,r8
80004d8a:	e0 8b 00 6d 	brhi	80004e64 <_malloc_r+0x2c8>
80004d8e:	f7 e8 00 09 	and	r9,r11,r8
80004d92:	c0 b1       	brne	80004da8 <_malloc_r+0x20c>
80004d94:	e0 13 ff fc 	andl	r3,0xfffc
80004d98:	a1 7b       	lsl	r11,0x1
80004d9a:	2f c3       	sub	r3,-4
80004d9c:	c0 38       	rjmp	80004da2 <_malloc_r+0x206>
80004d9e:	2f c3       	sub	r3,-4
80004da0:	a1 7b       	lsl	r11,0x1
80004da2:	f7 e8 00 09 	and	r9,r11,r8
80004da6:	cf c0       	breq	80004d9e <_malloc_r+0x202>
80004da8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004dac:	06 92       	mov	r2,r3
80004dae:	1c 91       	mov	r1,lr
80004db0:	62 36       	ld.w	r6,r1[0xc]
80004db2:	c2 e8       	rjmp	80004e0e <_malloc_r+0x272>
80004db4:	6c 1a       	ld.w	r10,r6[0x4]
80004db6:	e0 1a ff fc 	andl	r10,0xfffc
80004dba:	f4 07 01 08 	sub	r8,r10,r7
80004dbe:	58 f8       	cp.w	r8,15
80004dc0:	e0 8a 00 15 	brle	80004dea <_malloc_r+0x24e>
80004dc4:	6c 3a       	ld.w	r10,r6[0xc]
80004dc6:	6c 29       	ld.w	r9,r6[0x8]
80004dc8:	95 29       	st.w	r10[0x8],r9
80004dca:	93 3a       	st.w	r9[0xc],r10
80004dcc:	0e 99       	mov	r9,r7
80004dce:	ec 07 00 07 	add	r7,r6,r7
80004dd2:	a1 a9       	sbr	r9,0x0
80004dd4:	99 37       	st.w	r12[0xc],r7
80004dd6:	99 27       	st.w	r12[0x8],r7
80004dd8:	8d 19       	st.w	r6[0x4],r9
80004dda:	ee 08 09 08 	st.w	r7[r8],r8
80004dde:	8f 2c       	st.w	r7[0x8],r12
80004de0:	8f 3c       	st.w	r7[0xc],r12
80004de2:	a1 a8       	sbr	r8,0x0
80004de4:	0a 9c       	mov	r12,r5
80004de6:	8f 18       	st.w	r7[0x4],r8
80004de8:	c0 d8       	rjmp	80004e02 <_malloc_r+0x266>
80004dea:	6c 39       	ld.w	r9,r6[0xc]
80004dec:	58 08       	cp.w	r8,0
80004dee:	c0 f5       	brlt	80004e0c <_malloc_r+0x270>
80004df0:	ec 0a 00 0a 	add	r10,r6,r10
80004df4:	74 18       	ld.w	r8,r10[0x4]
80004df6:	a1 a8       	sbr	r8,0x0
80004df8:	0a 9c       	mov	r12,r5
80004dfa:	95 18       	st.w	r10[0x4],r8
80004dfc:	6c 28       	ld.w	r8,r6[0x8]
80004dfe:	93 28       	st.w	r9[0x8],r8
80004e00:	91 39       	st.w	r8[0xc],r9
80004e02:	fe b0 fa 83 	rcall	80004308 <__malloc_unlock>
80004e06:	ec cc ff f8 	sub	r12,r6,-8
80004e0a:	d8 32       	popm	r0-r7,pc
80004e0c:	12 96       	mov	r6,r9
80004e0e:	02 36       	cp.w	r6,r1
80004e10:	cd 21       	brne	80004db4 <_malloc_r+0x218>
80004e12:	2f f2       	sub	r2,-1
80004e14:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004e18:	c0 30       	breq	80004e1e <_malloc_r+0x282>
80004e1a:	2f 81       	sub	r1,-8
80004e1c:	cc ab       	rjmp	80004db0 <_malloc_r+0x214>
80004e1e:	1c 98       	mov	r8,lr
80004e20:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004e24:	c0 81       	brne	80004e34 <_malloc_r+0x298>
80004e26:	68 19       	ld.w	r9,r4[0x4]
80004e28:	f6 08 11 ff 	rsub	r8,r11,-1
80004e2c:	f3 e8 00 08 	and	r8,r9,r8
80004e30:	89 18       	st.w	r4[0x4],r8
80004e32:	c0 78       	rjmp	80004e40 <_malloc_r+0x2a4>
80004e34:	f0 c9 00 08 	sub	r9,r8,8
80004e38:	20 13       	sub	r3,1
80004e3a:	70 08       	ld.w	r8,r8[0x0]
80004e3c:	12 38       	cp.w	r8,r9
80004e3e:	cf 10       	breq	80004e20 <_malloc_r+0x284>
80004e40:	a1 7b       	lsl	r11,0x1
80004e42:	68 18       	ld.w	r8,r4[0x4]
80004e44:	10 3b       	cp.w	r11,r8
80004e46:	e0 8b 00 0f 	brhi	80004e64 <_malloc_r+0x2c8>
80004e4a:	58 0b       	cp.w	r11,0
80004e4c:	c0 c0       	breq	80004e64 <_malloc_r+0x2c8>
80004e4e:	04 93       	mov	r3,r2
80004e50:	c0 38       	rjmp	80004e56 <_malloc_r+0x2ba>
80004e52:	2f c3       	sub	r3,-4
80004e54:	a1 7b       	lsl	r11,0x1
80004e56:	f7 e8 00 09 	and	r9,r11,r8
80004e5a:	ca 71       	brne	80004da8 <_malloc_r+0x20c>
80004e5c:	cf bb       	rjmp	80004e52 <_malloc_r+0x2b6>
80004e5e:	d7 03       	nop
80004e60:	00 00       	add	r0,r0
80004e62:	01 e4       	ld.ub	r4,r0[0x6]
80004e64:	68 23       	ld.w	r3,r4[0x8]
80004e66:	66 12       	ld.w	r2,r3[0x4]
80004e68:	e0 12 ff fc 	andl	r2,0xfffc
80004e6c:	0e 32       	cp.w	r2,r7
80004e6e:	5f 39       	srlo	r9
80004e70:	e4 07 01 08 	sub	r8,r2,r7
80004e74:	58 f8       	cp.w	r8,15
80004e76:	5f aa       	srle	r10
80004e78:	f5 e9 10 09 	or	r9,r10,r9
80004e7c:	e0 80 00 9c 	breq	80004fb4 <_malloc_r+0x418>
80004e80:	4c 88       	lddpc	r8,80004fa0 <_malloc_r+0x404>
80004e82:	70 01       	ld.w	r1,r8[0x0]
80004e84:	4c 88       	lddpc	r8,80004fa4 <_malloc_r+0x408>
80004e86:	2f 01       	sub	r1,-16
80004e88:	70 08       	ld.w	r8,r8[0x0]
80004e8a:	0e 01       	add	r1,r7
80004e8c:	5b f8       	cp.w	r8,-1
80004e8e:	c0 40       	breq	80004e96 <_malloc_r+0x2fa>
80004e90:	28 11       	sub	r1,-127
80004e92:	e0 11 ff 80 	andl	r1,0xff80
80004e96:	02 9b       	mov	r11,r1
80004e98:	0a 9c       	mov	r12,r5
80004e9a:	e0 a0 02 dd 	rcall	80005454 <_sbrk_r>
80004e9e:	18 96       	mov	r6,r12
80004ea0:	5b fc       	cp.w	r12,-1
80004ea2:	c6 e0       	breq	80004f7e <_malloc_r+0x3e2>
80004ea4:	e6 02 00 08 	add	r8,r3,r2
80004ea8:	10 3c       	cp.w	r12,r8
80004eaa:	c0 32       	brcc	80004eb0 <_malloc_r+0x314>
80004eac:	08 33       	cp.w	r3,r4
80004eae:	c6 81       	brne	80004f7e <_malloc_r+0x3e2>
80004eb0:	4b ea       	lddpc	r10,80004fa8 <_malloc_r+0x40c>
80004eb2:	74 09       	ld.w	r9,r10[0x0]
80004eb4:	e2 09 00 09 	add	r9,r1,r9
80004eb8:	95 09       	st.w	r10[0x0],r9
80004eba:	10 36       	cp.w	r6,r8
80004ebc:	c0 a1       	brne	80004ed0 <_malloc_r+0x334>
80004ebe:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004ec2:	c0 71       	brne	80004ed0 <_malloc_r+0x334>
80004ec4:	e2 02 00 02 	add	r2,r1,r2
80004ec8:	68 28       	ld.w	r8,r4[0x8]
80004eca:	a1 a2       	sbr	r2,0x0
80004ecc:	91 12       	st.w	r8[0x4],r2
80004ece:	c4 c8       	rjmp	80004f66 <_malloc_r+0x3ca>
80004ed0:	4b 5a       	lddpc	r10,80004fa4 <_malloc_r+0x408>
80004ed2:	74 0b       	ld.w	r11,r10[0x0]
80004ed4:	5b fb       	cp.w	r11,-1
80004ed6:	c0 31       	brne	80004edc <_malloc_r+0x340>
80004ed8:	95 06       	st.w	r10[0x0],r6
80004eda:	c0 68       	rjmp	80004ee6 <_malloc_r+0x34a>
80004edc:	ec 09 00 09 	add	r9,r6,r9
80004ee0:	4b 2a       	lddpc	r10,80004fa8 <_malloc_r+0x40c>
80004ee2:	10 19       	sub	r9,r8
80004ee4:	95 09       	st.w	r10[0x0],r9
80004ee6:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004eea:	f0 09 11 08 	rsub	r9,r8,8
80004eee:	58 08       	cp.w	r8,0
80004ef0:	f2 08 17 10 	movne	r8,r9
80004ef4:	ed d8 e1 06 	addne	r6,r6,r8
80004ef8:	28 08       	sub	r8,-128
80004efa:	ec 01 00 01 	add	r1,r6,r1
80004efe:	0a 9c       	mov	r12,r5
80004f00:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004f04:	f0 01 01 01 	sub	r1,r8,r1
80004f08:	02 9b       	mov	r11,r1
80004f0a:	e0 a0 02 a5 	rcall	80005454 <_sbrk_r>
80004f0e:	4a 78       	lddpc	r8,80004fa8 <_malloc_r+0x40c>
80004f10:	5b fc       	cp.w	r12,-1
80004f12:	ec 0c 17 00 	moveq	r12,r6
80004f16:	f9 b1 00 00 	moveq	r1,0
80004f1a:	70 09       	ld.w	r9,r8[0x0]
80004f1c:	0c 1c       	sub	r12,r6
80004f1e:	89 26       	st.w	r4[0x8],r6
80004f20:	02 0c       	add	r12,r1
80004f22:	12 01       	add	r1,r9
80004f24:	a1 ac       	sbr	r12,0x0
80004f26:	91 01       	st.w	r8[0x0],r1
80004f28:	8d 1c       	st.w	r6[0x4],r12
80004f2a:	08 33       	cp.w	r3,r4
80004f2c:	c1 d0       	breq	80004f66 <_malloc_r+0x3ca>
80004f2e:	58 f2       	cp.w	r2,15
80004f30:	e0 8b 00 05 	brhi	80004f3a <_malloc_r+0x39e>
80004f34:	30 18       	mov	r8,1
80004f36:	8d 18       	st.w	r6[0x4],r8
80004f38:	c2 38       	rjmp	80004f7e <_malloc_r+0x3e2>
80004f3a:	30 59       	mov	r9,5
80004f3c:	20 c2       	sub	r2,12
80004f3e:	e0 12 ff f8 	andl	r2,0xfff8
80004f42:	e6 02 00 08 	add	r8,r3,r2
80004f46:	91 29       	st.w	r8[0x8],r9
80004f48:	91 19       	st.w	r8[0x4],r9
80004f4a:	66 18       	ld.w	r8,r3[0x4]
80004f4c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004f50:	e5 e8 10 08 	or	r8,r2,r8
80004f54:	87 18       	st.w	r3[0x4],r8
80004f56:	58 f2       	cp.w	r2,15
80004f58:	e0 88 00 07 	brls	80004f66 <_malloc_r+0x3ca>
80004f5c:	e6 cb ff f8 	sub	r11,r3,-8
80004f60:	0a 9c       	mov	r12,r5
80004f62:	e0 a0 05 ed 	rcall	80005b3c <_free_r>
80004f66:	49 29       	lddpc	r9,80004fac <_malloc_r+0x410>
80004f68:	72 0a       	ld.w	r10,r9[0x0]
80004f6a:	49 08       	lddpc	r8,80004fa8 <_malloc_r+0x40c>
80004f6c:	70 08       	ld.w	r8,r8[0x0]
80004f6e:	14 38       	cp.w	r8,r10
80004f70:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004f74:	48 f9       	lddpc	r9,80004fb0 <_malloc_r+0x414>
80004f76:	72 0a       	ld.w	r10,r9[0x0]
80004f78:	14 38       	cp.w	r8,r10
80004f7a:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004f7e:	68 28       	ld.w	r8,r4[0x8]
80004f80:	70 18       	ld.w	r8,r8[0x4]
80004f82:	e0 18 ff fc 	andl	r8,0xfffc
80004f86:	0e 38       	cp.w	r8,r7
80004f88:	5f 39       	srlo	r9
80004f8a:	0e 18       	sub	r8,r7
80004f8c:	58 f8       	cp.w	r8,15
80004f8e:	5f aa       	srle	r10
80004f90:	f5 e9 10 09 	or	r9,r10,r9
80004f94:	c1 00       	breq	80004fb4 <_malloc_r+0x418>
80004f96:	0a 9c       	mov	r12,r5
80004f98:	fe b0 f9 b8 	rcall	80004308 <__malloc_unlock>
80004f9c:	d8 3a       	popm	r0-r7,pc,r12=0
80004f9e:	d7 03       	nop
80004fa0:	00 00       	add	r0,r0
80004fa2:	09 dc       	ld.ub	r12,r4[0x5]
80004fa4:	00 00       	add	r0,r0
80004fa6:	05 f0       	ld.ub	r0,r2[0x7]
80004fa8:	00 00       	add	r0,r0
80004faa:	09 e0       	ld.ub	r0,r4[0x6]
80004fac:	00 00       	add	r0,r0
80004fae:	09 d8       	ld.ub	r8,r4[0x5]
80004fb0:	00 00       	add	r0,r0
80004fb2:	09 d4       	ld.ub	r4,r4[0x5]
80004fb4:	68 26       	ld.w	r6,r4[0x8]
80004fb6:	a1 a8       	sbr	r8,0x0
80004fb8:	0e 99       	mov	r9,r7
80004fba:	a1 a9       	sbr	r9,0x0
80004fbc:	8d 19       	st.w	r6[0x4],r9
80004fbe:	ec 07 00 07 	add	r7,r6,r7
80004fc2:	0a 9c       	mov	r12,r5
80004fc4:	89 27       	st.w	r4[0x8],r7
80004fc6:	8f 18       	st.w	r7[0x4],r8
80004fc8:	fe b0 f9 a0 	rcall	80004308 <__malloc_unlock>
80004fcc:	ec cc ff f8 	sub	r12,r6,-8
80004fd0:	d8 32       	popm	r0-r7,pc
80004fd2:	d7 03       	nop

80004fd4 <memcpy>:
80004fd4:	58 8a       	cp.w	r10,8
80004fd6:	c2 f5       	brlt	80005034 <memcpy+0x60>
80004fd8:	f9 eb 10 09 	or	r9,r12,r11
80004fdc:	e2 19 00 03 	andl	r9,0x3,COH
80004fe0:	e0 81 00 97 	brne	8000510e <memcpy+0x13a>
80004fe4:	e0 4a 00 20 	cp.w	r10,32
80004fe8:	c3 b4       	brge	8000505e <memcpy+0x8a>
80004fea:	f4 08 14 02 	asr	r8,r10,0x2
80004fee:	f0 09 11 08 	rsub	r9,r8,8
80004ff2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004ff6:	76 69       	ld.w	r9,r11[0x18]
80004ff8:	99 69       	st.w	r12[0x18],r9
80004ffa:	76 59       	ld.w	r9,r11[0x14]
80004ffc:	99 59       	st.w	r12[0x14],r9
80004ffe:	76 49       	ld.w	r9,r11[0x10]
80005000:	99 49       	st.w	r12[0x10],r9
80005002:	76 39       	ld.w	r9,r11[0xc]
80005004:	99 39       	st.w	r12[0xc],r9
80005006:	76 29       	ld.w	r9,r11[0x8]
80005008:	99 29       	st.w	r12[0x8],r9
8000500a:	76 19       	ld.w	r9,r11[0x4]
8000500c:	99 19       	st.w	r12[0x4],r9
8000500e:	76 09       	ld.w	r9,r11[0x0]
80005010:	99 09       	st.w	r12[0x0],r9
80005012:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80005016:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000501a:	e0 1a 00 03 	andl	r10,0x3
8000501e:	f4 0a 11 04 	rsub	r10,r10,4
80005022:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005026:	17 a9       	ld.ub	r9,r11[0x2]
80005028:	b0 a9       	st.b	r8[0x2],r9
8000502a:	17 99       	ld.ub	r9,r11[0x1]
8000502c:	b0 99       	st.b	r8[0x1],r9
8000502e:	17 89       	ld.ub	r9,r11[0x0]
80005030:	b0 89       	st.b	r8[0x0],r9
80005032:	5e fc       	retal	r12
80005034:	f4 0a 11 09 	rsub	r10,r10,9
80005038:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000503c:	17 f9       	ld.ub	r9,r11[0x7]
8000503e:	b8 f9       	st.b	r12[0x7],r9
80005040:	17 e9       	ld.ub	r9,r11[0x6]
80005042:	b8 e9       	st.b	r12[0x6],r9
80005044:	17 d9       	ld.ub	r9,r11[0x5]
80005046:	b8 d9       	st.b	r12[0x5],r9
80005048:	17 c9       	ld.ub	r9,r11[0x4]
8000504a:	b8 c9       	st.b	r12[0x4],r9
8000504c:	17 b9       	ld.ub	r9,r11[0x3]
8000504e:	b8 b9       	st.b	r12[0x3],r9
80005050:	17 a9       	ld.ub	r9,r11[0x2]
80005052:	b8 a9       	st.b	r12[0x2],r9
80005054:	17 99       	ld.ub	r9,r11[0x1]
80005056:	b8 99       	st.b	r12[0x1],r9
80005058:	17 89       	ld.ub	r9,r11[0x0]
8000505a:	b8 89       	st.b	r12[0x0],r9
8000505c:	5e fc       	retal	r12
8000505e:	eb cd 40 c0 	pushm	r6-r7,lr
80005062:	18 99       	mov	r9,r12
80005064:	22 0a       	sub	r10,32
80005066:	b7 07       	ld.d	r6,r11++
80005068:	b3 26       	st.d	r9++,r6
8000506a:	b7 07       	ld.d	r6,r11++
8000506c:	b3 26       	st.d	r9++,r6
8000506e:	b7 07       	ld.d	r6,r11++
80005070:	b3 26       	st.d	r9++,r6
80005072:	b7 07       	ld.d	r6,r11++
80005074:	b3 26       	st.d	r9++,r6
80005076:	22 0a       	sub	r10,32
80005078:	cf 74       	brge	80005066 <memcpy+0x92>
8000507a:	2f 0a       	sub	r10,-16
8000507c:	c0 65       	brlt	80005088 <memcpy+0xb4>
8000507e:	b7 07       	ld.d	r6,r11++
80005080:	b3 26       	st.d	r9++,r6
80005082:	b7 07       	ld.d	r6,r11++
80005084:	b3 26       	st.d	r9++,r6
80005086:	21 0a       	sub	r10,16
80005088:	5c 3a       	neg	r10
8000508a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000508e:	d7 03       	nop
80005090:	d7 03       	nop
80005092:	f7 36 00 0e 	ld.ub	r6,r11[14]
80005096:	f3 66 00 0e 	st.b	r9[14],r6
8000509a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000509e:	f3 66 00 0d 	st.b	r9[13],r6
800050a2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800050a6:	f3 66 00 0c 	st.b	r9[12],r6
800050aa:	f7 36 00 0b 	ld.ub	r6,r11[11]
800050ae:	f3 66 00 0b 	st.b	r9[11],r6
800050b2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800050b6:	f3 66 00 0a 	st.b	r9[10],r6
800050ba:	f7 36 00 09 	ld.ub	r6,r11[9]
800050be:	f3 66 00 09 	st.b	r9[9],r6
800050c2:	f7 36 00 08 	ld.ub	r6,r11[8]
800050c6:	f3 66 00 08 	st.b	r9[8],r6
800050ca:	f7 36 00 07 	ld.ub	r6,r11[7]
800050ce:	f3 66 00 07 	st.b	r9[7],r6
800050d2:	f7 36 00 06 	ld.ub	r6,r11[6]
800050d6:	f3 66 00 06 	st.b	r9[6],r6
800050da:	f7 36 00 05 	ld.ub	r6,r11[5]
800050de:	f3 66 00 05 	st.b	r9[5],r6
800050e2:	f7 36 00 04 	ld.ub	r6,r11[4]
800050e6:	f3 66 00 04 	st.b	r9[4],r6
800050ea:	f7 36 00 03 	ld.ub	r6,r11[3]
800050ee:	f3 66 00 03 	st.b	r9[3],r6
800050f2:	f7 36 00 02 	ld.ub	r6,r11[2]
800050f6:	f3 66 00 02 	st.b	r9[2],r6
800050fa:	f7 36 00 01 	ld.ub	r6,r11[1]
800050fe:	f3 66 00 01 	st.b	r9[1],r6
80005102:	f7 36 00 00 	ld.ub	r6,r11[0]
80005106:	f3 66 00 00 	st.b	r9[0],r6
8000510a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000510e:	20 1a       	sub	r10,1
80005110:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80005114:	f8 0a 0b 09 	st.b	r12[r10],r9
80005118:	cf b1       	brne	8000510e <memcpy+0x13a>
8000511a:	5e fc       	retal	r12

8000511c <memset>:
8000511c:	18 98       	mov	r8,r12
8000511e:	c0 38       	rjmp	80005124 <memset+0x8>
80005120:	10 cb       	st.b	r8++,r11
80005122:	20 1a       	sub	r10,1
80005124:	58 0a       	cp.w	r10,0
80005126:	cf d1       	brne	80005120 <memset+0x4>
80005128:	5e fc       	retal	r12
8000512a:	d7 03       	nop

8000512c <_puts_r>:
8000512c:	d4 21       	pushm	r4-r7,lr
8000512e:	20 7d       	sub	sp,28
80005130:	16 96       	mov	r6,r11
80005132:	18 97       	mov	r7,r12
80005134:	16 9c       	mov	r12,r11
80005136:	e0 a0 02 2f 	rcall	80005594 <strlen>
8000513a:	f8 c8 ff ff 	sub	r8,r12,-1
8000513e:	50 68       	stdsp	sp[0x18],r8
80005140:	48 f8       	lddpc	r8,8000517c <_puts_r+0x50>
80005142:	50 28       	stdsp	sp[0x8],r8
80005144:	30 18       	mov	r8,1
80005146:	50 06       	stdsp	sp[0x0],r6
80005148:	50 38       	stdsp	sp[0xc],r8
8000514a:	50 1c       	stdsp	sp[0x4],r12
8000514c:	30 28       	mov	r8,2
8000514e:	50 4d       	stdsp	sp[0x10],sp
80005150:	50 58       	stdsp	sp[0x14],r8
80005152:	58 07       	cp.w	r7,0
80005154:	c0 70       	breq	80005162 <_puts_r+0x36>
80005156:	6e 68       	ld.w	r8,r7[0x18]
80005158:	58 08       	cp.w	r8,0
8000515a:	c0 41       	brne	80005162 <_puts_r+0x36>
8000515c:	0e 9c       	mov	r12,r7
8000515e:	e0 a0 04 53 	rcall	80005a04 <__sinit>
80005162:	0e 9c       	mov	r12,r7
80005164:	fa ca ff f0 	sub	r10,sp,-16
80005168:	6e 1b       	ld.w	r11,r7[0x4]
8000516a:	e0 a0 05 b1 	rcall	80005ccc <__sfvwrite_r>
8000516e:	f9 bc 01 ff 	movne	r12,-1
80005172:	f9 bc 00 0a 	moveq	r12,10
80005176:	2f 9d       	sub	sp,-28
80005178:	d8 22       	popm	r4-r7,pc
8000517a:	d7 03       	nop
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	67 24       	ld.w	r4,r3[0x48]

80005180 <puts>:
80005180:	d4 01       	pushm	lr
80005182:	48 38       	lddpc	r8,8000518c <puts+0xc>
80005184:	18 9b       	mov	r11,r12
80005186:	70 0c       	ld.w	r12,r8[0x0]
80005188:	cd 2f       	rcall	8000512c <_puts_r>
8000518a:	d8 02       	popm	pc
8000518c:	00 00       	add	r0,r0
8000518e:	01 e0       	ld.ub	r0,r0[0x6]

80005190 <_realloc_r>:
80005190:	d4 31       	pushm	r0-r7,lr
80005192:	20 1d       	sub	sp,4
80005194:	16 94       	mov	r4,r11
80005196:	18 92       	mov	r2,r12
80005198:	14 9b       	mov	r11,r10
8000519a:	58 04       	cp.w	r4,0
8000519c:	c0 51       	brne	800051a6 <_realloc_r+0x16>
8000519e:	fe b0 fc ff 	rcall	80004b9c <_malloc_r>
800051a2:	18 95       	mov	r5,r12
800051a4:	c5 59       	rjmp	8000544e <_realloc_r+0x2be>
800051a6:	50 0a       	stdsp	sp[0x0],r10
800051a8:	fe b0 f8 aa 	rcall	800042fc <__malloc_lock>
800051ac:	40 0b       	lddsp	r11,sp[0x0]
800051ae:	f6 c8 ff f5 	sub	r8,r11,-11
800051b2:	e8 c1 00 08 	sub	r1,r4,8
800051b6:	10 96       	mov	r6,r8
800051b8:	62 1c       	ld.w	r12,r1[0x4]
800051ba:	e0 16 ff f8 	andl	r6,0xfff8
800051be:	59 68       	cp.w	r8,22
800051c0:	f9 b6 08 10 	movls	r6,16
800051c4:	16 36       	cp.w	r6,r11
800051c6:	5f 38       	srlo	r8
800051c8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800051cc:	c0 50       	breq	800051d6 <_realloc_r+0x46>
800051ce:	30 c8       	mov	r8,12
800051d0:	30 05       	mov	r5,0
800051d2:	85 38       	st.w	r2[0xc],r8
800051d4:	c3 d9       	rjmp	8000544e <_realloc_r+0x2be>
800051d6:	18 90       	mov	r0,r12
800051d8:	e0 10 ff fc 	andl	r0,0xfffc
800051dc:	0c 30       	cp.w	r0,r6
800051de:	e0 84 01 0d 	brge	800053f8 <_realloc_r+0x268>
800051e2:	4c a8       	lddpc	r8,80005308 <_realloc_r+0x178>
800051e4:	e2 00 00 09 	add	r9,r1,r0
800051e8:	70 25       	ld.w	r5,r8[0x8]
800051ea:	0a 39       	cp.w	r9,r5
800051ec:	c0 90       	breq	800051fe <_realloc_r+0x6e>
800051ee:	72 1a       	ld.w	r10,r9[0x4]
800051f0:	a1 ca       	cbr	r10,0x0
800051f2:	f2 0a 00 0a 	add	r10,r9,r10
800051f6:	74 1a       	ld.w	r10,r10[0x4]
800051f8:	ed ba 00 00 	bld	r10,0x0
800051fc:	c2 20       	breq	80005240 <_realloc_r+0xb0>
800051fe:	72 1a       	ld.w	r10,r9[0x4]
80005200:	e0 1a ff fc 	andl	r10,0xfffc
80005204:	f4 00 00 03 	add	r3,r10,r0
80005208:	0a 39       	cp.w	r9,r5
8000520a:	c1 31       	brne	80005230 <_realloc_r+0xa0>
8000520c:	ec c7 ff f0 	sub	r7,r6,-16
80005210:	0e 33       	cp.w	r3,r7
80005212:	c1 95       	brlt	80005244 <_realloc_r+0xb4>
80005214:	e2 06 00 09 	add	r9,r1,r6
80005218:	0c 13       	sub	r3,r6
8000521a:	a1 a3       	sbr	r3,0x0
8000521c:	93 13       	st.w	r9[0x4],r3
8000521e:	91 29       	st.w	r8[0x8],r9
80005220:	04 9c       	mov	r12,r2
80005222:	62 18       	ld.w	r8,r1[0x4]
80005224:	08 95       	mov	r5,r4
80005226:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000522a:	10 46       	or	r6,r8
8000522c:	83 16       	st.w	r1[0x4],r6
8000522e:	c0 e9       	rjmp	8000544a <_realloc_r+0x2ba>
80005230:	0c 33       	cp.w	r3,r6
80005232:	c0 95       	brlt	80005244 <_realloc_r+0xb4>
80005234:	72 28       	ld.w	r8,r9[0x8]
80005236:	02 97       	mov	r7,r1
80005238:	72 39       	ld.w	r9,r9[0xc]
8000523a:	93 28       	st.w	r9[0x8],r8
8000523c:	91 39       	st.w	r8[0xc],r9
8000523e:	cd f8       	rjmp	800053fc <_realloc_r+0x26c>
80005240:	30 0a       	mov	r10,0
80005242:	14 99       	mov	r9,r10
80005244:	ed bc 00 00 	bld	r12,0x0
80005248:	e0 80 00 98 	breq	80005378 <_realloc_r+0x1e8>
8000524c:	62 07       	ld.w	r7,r1[0x0]
8000524e:	e2 07 01 07 	sub	r7,r1,r7
80005252:	6e 1c       	ld.w	r12,r7[0x4]
80005254:	e0 1c ff fc 	andl	r12,0xfffc
80005258:	58 09       	cp.w	r9,0
8000525a:	c5 90       	breq	8000530c <_realloc_r+0x17c>
8000525c:	f8 00 00 03 	add	r3,r12,r0
80005260:	0a 39       	cp.w	r9,r5
80005262:	c4 81       	brne	800052f2 <_realloc_r+0x162>
80005264:	14 03       	add	r3,r10
80005266:	ec c9 ff f0 	sub	r9,r6,-16
8000526a:	12 33       	cp.w	r3,r9
8000526c:	c5 05       	brlt	8000530c <_realloc_r+0x17c>
8000526e:	6e 3a       	ld.w	r10,r7[0xc]
80005270:	6e 29       	ld.w	r9,r7[0x8]
80005272:	95 29       	st.w	r10[0x8],r9
80005274:	93 3a       	st.w	r9[0xc],r10
80005276:	ee c5 ff f8 	sub	r5,r7,-8
8000527a:	e0 ca 00 04 	sub	r10,r0,4
8000527e:	e0 4a 00 24 	cp.w	r10,36
80005282:	e0 8b 00 25 	brhi	800052cc <_realloc_r+0x13c>
80005286:	0a 99       	mov	r9,r5
80005288:	59 3a       	cp.w	r10,19
8000528a:	e0 88 00 1a 	brls	800052be <_realloc_r+0x12e>
8000528e:	09 09       	ld.w	r9,r4++
80005290:	8b 09       	st.w	r5[0x0],r9
80005292:	09 09       	ld.w	r9,r4++
80005294:	8f 39       	st.w	r7[0xc],r9
80005296:	ee c9 ff f0 	sub	r9,r7,-16
8000529a:	59 ba       	cp.w	r10,27
8000529c:	e0 88 00 11 	brls	800052be <_realloc_r+0x12e>
800052a0:	09 0b       	ld.w	r11,r4++
800052a2:	93 0b       	st.w	r9[0x0],r11
800052a4:	09 09       	ld.w	r9,r4++
800052a6:	8f 59       	st.w	r7[0x14],r9
800052a8:	ee c9 ff e8 	sub	r9,r7,-24
800052ac:	e0 4a 00 24 	cp.w	r10,36
800052b0:	c0 71       	brne	800052be <_realloc_r+0x12e>
800052b2:	09 0a       	ld.w	r10,r4++
800052b4:	93 0a       	st.w	r9[0x0],r10
800052b6:	ee c9 ff e0 	sub	r9,r7,-32
800052ba:	09 0a       	ld.w	r10,r4++
800052bc:	8f 7a       	st.w	r7[0x1c],r10
800052be:	09 0a       	ld.w	r10,r4++
800052c0:	12 aa       	st.w	r9++,r10
800052c2:	68 0a       	ld.w	r10,r4[0x0]
800052c4:	93 0a       	st.w	r9[0x0],r10
800052c6:	68 1a       	ld.w	r10,r4[0x4]
800052c8:	93 1a       	st.w	r9[0x4],r10
800052ca:	c0 78       	rjmp	800052d8 <_realloc_r+0x148>
800052cc:	50 08       	stdsp	sp[0x0],r8
800052ce:	08 9b       	mov	r11,r4
800052d0:	0a 9c       	mov	r12,r5
800052d2:	e0 a0 06 78 	rcall	80005fc2 <memmove>
800052d6:	40 08       	lddsp	r8,sp[0x0]
800052d8:	ee 06 00 09 	add	r9,r7,r6
800052dc:	0c 13       	sub	r3,r6
800052de:	a1 a3       	sbr	r3,0x0
800052e0:	93 13       	st.w	r9[0x4],r3
800052e2:	91 29       	st.w	r8[0x8],r9
800052e4:	04 9c       	mov	r12,r2
800052e6:	6e 18       	ld.w	r8,r7[0x4]
800052e8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800052ec:	10 46       	or	r6,r8
800052ee:	8f 16       	st.w	r7[0x4],r6
800052f0:	ca d8       	rjmp	8000544a <_realloc_r+0x2ba>
800052f2:	14 03       	add	r3,r10
800052f4:	0c 33       	cp.w	r3,r6
800052f6:	c0 b5       	brlt	8000530c <_realloc_r+0x17c>
800052f8:	72 28       	ld.w	r8,r9[0x8]
800052fa:	72 39       	ld.w	r9,r9[0xc]
800052fc:	93 28       	st.w	r9[0x8],r8
800052fe:	91 39       	st.w	r8[0xc],r9
80005300:	6e 28       	ld.w	r8,r7[0x8]
80005302:	6e 39       	ld.w	r9,r7[0xc]
80005304:	c0 a8       	rjmp	80005318 <_realloc_r+0x188>
80005306:	d7 03       	nop
80005308:	00 00       	add	r0,r0
8000530a:	01 e4       	ld.ub	r4,r0[0x6]
8000530c:	f8 00 00 03 	add	r3,r12,r0
80005310:	0c 33       	cp.w	r3,r6
80005312:	c3 35       	brlt	80005378 <_realloc_r+0x1e8>
80005314:	6e 39       	ld.w	r9,r7[0xc]
80005316:	6e 28       	ld.w	r8,r7[0x8]
80005318:	93 28       	st.w	r9[0x8],r8
8000531a:	91 39       	st.w	r8[0xc],r9
8000531c:	e0 ca 00 04 	sub	r10,r0,4
80005320:	ee cc ff f8 	sub	r12,r7,-8
80005324:	e0 4a 00 24 	cp.w	r10,36
80005328:	e0 8b 00 24 	brhi	80005370 <_realloc_r+0x1e0>
8000532c:	59 3a       	cp.w	r10,19
8000532e:	e0 88 00 1a 	brls	80005362 <_realloc_r+0x1d2>
80005332:	09 08       	ld.w	r8,r4++
80005334:	99 08       	st.w	r12[0x0],r8
80005336:	09 08       	ld.w	r8,r4++
80005338:	8f 38       	st.w	r7[0xc],r8
8000533a:	ee cc ff f0 	sub	r12,r7,-16
8000533e:	59 ba       	cp.w	r10,27
80005340:	e0 88 00 11 	brls	80005362 <_realloc_r+0x1d2>
80005344:	09 08       	ld.w	r8,r4++
80005346:	99 08       	st.w	r12[0x0],r8
80005348:	09 08       	ld.w	r8,r4++
8000534a:	8f 58       	st.w	r7[0x14],r8
8000534c:	ee cc ff e8 	sub	r12,r7,-24
80005350:	e0 4a 00 24 	cp.w	r10,36
80005354:	c0 71       	brne	80005362 <_realloc_r+0x1d2>
80005356:	09 08       	ld.w	r8,r4++
80005358:	99 08       	st.w	r12[0x0],r8
8000535a:	ee cc ff e0 	sub	r12,r7,-32
8000535e:	09 08       	ld.w	r8,r4++
80005360:	8f 78       	st.w	r7[0x1c],r8
80005362:	09 08       	ld.w	r8,r4++
80005364:	18 a8       	st.w	r12++,r8
80005366:	68 08       	ld.w	r8,r4[0x0]
80005368:	99 08       	st.w	r12[0x0],r8
8000536a:	68 18       	ld.w	r8,r4[0x4]
8000536c:	99 18       	st.w	r12[0x4],r8
8000536e:	c4 78       	rjmp	800053fc <_realloc_r+0x26c>
80005370:	08 9b       	mov	r11,r4
80005372:	e0 a0 06 28 	rcall	80005fc2 <memmove>
80005376:	c4 38       	rjmp	800053fc <_realloc_r+0x26c>
80005378:	04 9c       	mov	r12,r2
8000537a:	fe b0 fc 11 	rcall	80004b9c <_malloc_r>
8000537e:	18 95       	mov	r5,r12
80005380:	c3 a0       	breq	800053f4 <_realloc_r+0x264>
80005382:	62 18       	ld.w	r8,r1[0x4]
80005384:	f8 c9 00 08 	sub	r9,r12,8
80005388:	a1 c8       	cbr	r8,0x0
8000538a:	e2 08 00 08 	add	r8,r1,r8
8000538e:	10 39       	cp.w	r9,r8
80005390:	c0 71       	brne	8000539e <_realloc_r+0x20e>
80005392:	72 13       	ld.w	r3,r9[0x4]
80005394:	02 97       	mov	r7,r1
80005396:	e0 13 ff fc 	andl	r3,0xfffc
8000539a:	00 03       	add	r3,r0
8000539c:	c3 08       	rjmp	800053fc <_realloc_r+0x26c>
8000539e:	e0 ca 00 04 	sub	r10,r0,4
800053a2:	e0 4a 00 24 	cp.w	r10,36
800053a6:	e0 8b 00 20 	brhi	800053e6 <_realloc_r+0x256>
800053aa:	08 99       	mov	r9,r4
800053ac:	18 98       	mov	r8,r12
800053ae:	59 3a       	cp.w	r10,19
800053b0:	e0 88 00 14 	brls	800053d8 <_realloc_r+0x248>
800053b4:	13 0b       	ld.w	r11,r9++
800053b6:	10 ab       	st.w	r8++,r11
800053b8:	13 0b       	ld.w	r11,r9++
800053ba:	10 ab       	st.w	r8++,r11
800053bc:	59 ba       	cp.w	r10,27
800053be:	e0 88 00 0d 	brls	800053d8 <_realloc_r+0x248>
800053c2:	13 0b       	ld.w	r11,r9++
800053c4:	10 ab       	st.w	r8++,r11
800053c6:	13 0b       	ld.w	r11,r9++
800053c8:	10 ab       	st.w	r8++,r11
800053ca:	e0 4a 00 24 	cp.w	r10,36
800053ce:	c0 51       	brne	800053d8 <_realloc_r+0x248>
800053d0:	13 0a       	ld.w	r10,r9++
800053d2:	10 aa       	st.w	r8++,r10
800053d4:	13 0a       	ld.w	r10,r9++
800053d6:	10 aa       	st.w	r8++,r10
800053d8:	13 0a       	ld.w	r10,r9++
800053da:	10 aa       	st.w	r8++,r10
800053dc:	72 0a       	ld.w	r10,r9[0x0]
800053de:	91 0a       	st.w	r8[0x0],r10
800053e0:	72 19       	ld.w	r9,r9[0x4]
800053e2:	91 19       	st.w	r8[0x4],r9
800053e4:	c0 48       	rjmp	800053ec <_realloc_r+0x25c>
800053e6:	08 9b       	mov	r11,r4
800053e8:	e0 a0 05 ed 	rcall	80005fc2 <memmove>
800053ec:	08 9b       	mov	r11,r4
800053ee:	04 9c       	mov	r12,r2
800053f0:	e0 a0 03 a6 	rcall	80005b3c <_free_r>
800053f4:	04 9c       	mov	r12,r2
800053f6:	c2 a8       	rjmp	8000544a <_realloc_r+0x2ba>
800053f8:	00 93       	mov	r3,r0
800053fa:	02 97       	mov	r7,r1
800053fc:	e6 06 01 09 	sub	r9,r3,r6
80005400:	6e 18       	ld.w	r8,r7[0x4]
80005402:	58 f9       	cp.w	r9,15
80005404:	e0 88 00 16 	brls	80005430 <_realloc_r+0x2a0>
80005408:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000540c:	ed e8 10 08 	or	r8,r6,r8
80005410:	8f 18       	st.w	r7[0x4],r8
80005412:	12 98       	mov	r8,r9
80005414:	a1 a8       	sbr	r8,0x0
80005416:	ee 06 00 0b 	add	r11,r7,r6
8000541a:	f6 09 00 09 	add	r9,r11,r9
8000541e:	97 18       	st.w	r11[0x4],r8
80005420:	72 18       	ld.w	r8,r9[0x4]
80005422:	a1 a8       	sbr	r8,0x0
80005424:	2f 8b       	sub	r11,-8
80005426:	93 18       	st.w	r9[0x4],r8
80005428:	04 9c       	mov	r12,r2
8000542a:	e0 a0 03 89 	rcall	80005b3c <_free_r>
8000542e:	c0 b8       	rjmp	80005444 <_realloc_r+0x2b4>
80005430:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005434:	e7 e8 10 08 	or	r8,r3,r8
80005438:	8f 18       	st.w	r7[0x4],r8
8000543a:	ee 03 00 03 	add	r3,r7,r3
8000543e:	66 18       	ld.w	r8,r3[0x4]
80005440:	a1 a8       	sbr	r8,0x0
80005442:	87 18       	st.w	r3[0x4],r8
80005444:	04 9c       	mov	r12,r2
80005446:	ee c5 ff f8 	sub	r5,r7,-8
8000544a:	fe b0 f7 5f 	rcall	80004308 <__malloc_unlock>
8000544e:	0a 9c       	mov	r12,r5
80005450:	2f fd       	sub	sp,-4
80005452:	d8 32       	popm	r0-r7,pc

80005454 <_sbrk_r>:
80005454:	d4 21       	pushm	r4-r7,lr
80005456:	30 08       	mov	r8,0
80005458:	18 97       	mov	r7,r12
8000545a:	48 66       	lddpc	r6,80005470 <_sbrk_r+0x1c>
8000545c:	16 9c       	mov	r12,r11
8000545e:	8d 08       	st.w	r6[0x0],r8
80005460:	c1 6d       	rcall	8000568c <_sbrk>
80005462:	5b fc       	cp.w	r12,-1
80005464:	c0 51       	brne	8000546e <_sbrk_r+0x1a>
80005466:	6c 08       	ld.w	r8,r6[0x0]
80005468:	58 08       	cp.w	r8,0
8000546a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000546e:	d8 22       	popm	r4-r7,pc
80005470:	00 00       	add	r0,r0
80005472:	0a 38       	cp.w	r8,r5

80005474 <setbuf>:
80005474:	d4 01       	pushm	lr
80005476:	e0 69 04 00 	mov	r9,1024
8000547a:	58 0b       	cp.w	r11,0
8000547c:	f9 ba 00 02 	moveq	r10,2
80005480:	f9 ba 01 00 	movne	r10,0
80005484:	c0 2c       	rcall	80005488 <setvbuf>
80005486:	d8 02       	popm	pc

80005488 <setvbuf>:
80005488:	d4 31       	pushm	r0-r7,lr
8000548a:	4b f8       	lddpc	r8,80005584 <setvbuf+0xfc>
8000548c:	18 97       	mov	r7,r12
8000548e:	16 96       	mov	r6,r11
80005490:	14 95       	mov	r5,r10
80005492:	12 94       	mov	r4,r9
80005494:	70 0c       	ld.w	r12,r8[0x0]
80005496:	58 0c       	cp.w	r12,0
80005498:	c0 60       	breq	800054a4 <setvbuf+0x1c>
8000549a:	78 68       	ld.w	r8,r12[0x18]
8000549c:	58 08       	cp.w	r8,0
8000549e:	c0 31       	brne	800054a4 <setvbuf+0x1c>
800054a0:	e0 a0 02 b2 	rcall	80005a04 <__sinit>
800054a4:	4b 98       	lddpc	r8,80005588 <setvbuf+0x100>
800054a6:	10 37       	cp.w	r7,r8
800054a8:	c0 51       	brne	800054b2 <setvbuf+0x2a>
800054aa:	4b 78       	lddpc	r8,80005584 <setvbuf+0xfc>
800054ac:	70 08       	ld.w	r8,r8[0x0]
800054ae:	70 07       	ld.w	r7,r8[0x0]
800054b0:	c0 e8       	rjmp	800054cc <setvbuf+0x44>
800054b2:	4b 78       	lddpc	r8,8000558c <setvbuf+0x104>
800054b4:	10 37       	cp.w	r7,r8
800054b6:	c0 51       	brne	800054c0 <setvbuf+0x38>
800054b8:	4b 38       	lddpc	r8,80005584 <setvbuf+0xfc>
800054ba:	70 08       	ld.w	r8,r8[0x0]
800054bc:	70 17       	ld.w	r7,r8[0x4]
800054be:	c0 78       	rjmp	800054cc <setvbuf+0x44>
800054c0:	4b 48       	lddpc	r8,80005590 <setvbuf+0x108>
800054c2:	10 37       	cp.w	r7,r8
800054c4:	c0 41       	brne	800054cc <setvbuf+0x44>
800054c6:	4b 08       	lddpc	r8,80005584 <setvbuf+0xfc>
800054c8:	70 08       	ld.w	r8,r8[0x0]
800054ca:	70 27       	ld.w	r7,r8[0x8]
800054cc:	58 25       	cp.w	r5,2
800054ce:	5f b8       	srhi	r8
800054d0:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
800054d4:	c0 20       	breq	800054d8 <setvbuf+0x50>
800054d6:	dc 3a       	popm	r0-r7,pc,r12=-1
800054d8:	4a b3       	lddpc	r3,80005584 <setvbuf+0xfc>
800054da:	0e 9b       	mov	r11,r7
800054dc:	66 0c       	ld.w	r12,r3[0x0]
800054de:	cb 7d       	rcall	8000584c <_fflush_r>
800054e0:	30 08       	mov	r8,0
800054e2:	8f 68       	st.w	r7[0x18],r8
800054e4:	8f 18       	st.w	r7[0x4],r8
800054e6:	8e 68       	ld.sh	r8,r7[0xc]
800054e8:	ed b8 00 07 	bld	r8,0x7
800054ec:	c0 51       	brne	800054f6 <setvbuf+0x6e>
800054ee:	66 0c       	ld.w	r12,r3[0x0]
800054f0:	6e 4b       	ld.w	r11,r7[0x10]
800054f2:	e0 a0 03 25 	rcall	80005b3c <_free_r>
800054f6:	8e 68       	ld.sh	r8,r7[0xc]
800054f8:	e0 18 ff 7c 	andl	r8,0xff7c
800054fc:	ae 68       	st.h	r7[0xc],r8
800054fe:	58 25       	cp.w	r5,2
80005500:	c0 31       	brne	80005506 <setvbuf+0x7e>
80005502:	30 0c       	mov	r12,0
80005504:	c1 38       	rjmp	8000552a <setvbuf+0xa2>
80005506:	58 06       	cp.w	r6,0
80005508:	c2 11       	brne	8000554a <setvbuf+0xc2>
8000550a:	e0 63 04 00 	mov	r3,1024
8000550e:	58 04       	cp.w	r4,0
80005510:	e6 04 17 00 	moveq	r4,r3
80005514:	08 9c       	mov	r12,r4
80005516:	fe b0 fb 3b 	rcall	80004b8c <malloc>
8000551a:	18 96       	mov	r6,r12
8000551c:	c1 41       	brne	80005544 <setvbuf+0xbc>
8000551e:	06 9c       	mov	r12,r3
80005520:	fe b0 fb 36 	rcall	80004b8c <malloc>
80005524:	18 96       	mov	r6,r12
80005526:	c0 e1       	brne	80005542 <setvbuf+0xba>
80005528:	3f fc       	mov	r12,-1
8000552a:	8e 68       	ld.sh	r8,r7[0xc]
8000552c:	a1 b8       	sbr	r8,0x1
8000552e:	ae 68       	st.h	r7[0xc],r8
80005530:	ee c8 ff b9 	sub	r8,r7,-71
80005534:	8f 48       	st.w	r7[0x10],r8
80005536:	8f 08       	st.w	r7[0x0],r8
80005538:	30 08       	mov	r8,0
8000553a:	8f 28       	st.w	r7[0x8],r8
8000553c:	30 18       	mov	r8,1
8000553e:	8f 58       	st.w	r7[0x14],r8
80005540:	d8 32       	popm	r0-r7,pc
80005542:	06 94       	mov	r4,r3
80005544:	8e 68       	ld.sh	r8,r7[0xc]
80005546:	a7 b8       	sbr	r8,0x7
80005548:	ae 68       	st.h	r7[0xc],r8
8000554a:	58 15       	cp.w	r5,1
8000554c:	c0 71       	brne	8000555a <setvbuf+0xd2>
8000554e:	8e 68       	ld.sh	r8,r7[0xc]
80005550:	a1 a8       	sbr	r8,0x0
80005552:	ae 68       	st.h	r7[0xc],r8
80005554:	e8 08 11 00 	rsub	r8,r4,0
80005558:	8f 68       	st.w	r7[0x18],r8
8000555a:	48 b8       	lddpc	r8,80005584 <setvbuf+0xfc>
8000555c:	fe c9 fb fc 	sub	r9,pc,-1028
80005560:	70 08       	ld.w	r8,r8[0x0]
80005562:	8f 46       	st.w	r7[0x10],r6
80005564:	91 a9       	st.w	r8[0x28],r9
80005566:	8f 06       	st.w	r7[0x0],r6
80005568:	8f 54       	st.w	r7[0x14],r4
8000556a:	8e 68       	ld.sh	r8,r7[0xc]
8000556c:	10 9c       	mov	r12,r8
8000556e:	e2 1c 00 08 	andl	r12,0x8,COH
80005572:	c0 70       	breq	80005580 <setvbuf+0xf8>
80005574:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80005578:	30 0c       	mov	r12,0
8000557a:	f9 b4 01 00 	movne	r4,0
8000557e:	8f 24       	st.w	r7[0x8],r4
80005580:	d8 32       	popm	r0-r7,pc
80005582:	d7 03       	nop
80005584:	00 00       	add	r0,r0
80005586:	01 e0       	ld.ub	r0,r0[0x6]
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	67 28       	ld.w	r8,r3[0x48]
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	67 48       	ld.w	r8,r3[0x50]
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	67 68       	ld.w	r8,r3[0x58]

80005594 <strlen>:
80005594:	30 09       	mov	r9,0
80005596:	18 98       	mov	r8,r12
80005598:	c0 28       	rjmp	8000559c <strlen+0x8>
8000559a:	2f f8       	sub	r8,-1
8000559c:	11 8a       	ld.ub	r10,r8[0x0]
8000559e:	f2 0a 18 00 	cp.b	r10,r9
800055a2:	cf c1       	brne	8000559a <strlen+0x6>
800055a4:	f0 0c 01 0c 	sub	r12,r8,r12
800055a8:	5e fc       	retal	r12
800055aa:	d7 03       	nop

800055ac <strncpy>:
800055ac:	30 08       	mov	r8,0
800055ae:	10 3a       	cp.w	r10,r8
800055b0:	5e 0c       	reteq	r12
800055b2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800055b6:	f8 08 0b 09 	st.b	r12[r8],r9
800055ba:	2f f8       	sub	r8,-1
800055bc:	58 09       	cp.w	r9,0
800055be:	cf 81       	brne	800055ae <strncpy+0x2>
800055c0:	10 3a       	cp.w	r10,r8
800055c2:	5e 0c       	reteq	r12
800055c4:	f8 08 0b 09 	st.b	r12[r8],r9
800055c8:	2f f8       	sub	r8,-1
800055ca:	cf bb       	rjmp	800055c0 <strncpy+0x14>

800055cc <_init_argv>:
800055cc:	30 e8       	mov	r8,14
800055ce:	d6 73       	breakpoint
800055d0:	3f fc       	mov	r12,-1
800055d2:	35 8b       	mov	r11,88
800055d4:	5e fc       	retal	r12

800055d6 <_exit>:
800055d6:	30 d8       	mov	r8,13
800055d8:	d6 73       	breakpoint
800055da:	3f fc       	mov	r12,-1
800055dc:	35 8b       	mov	r11,88
800055de:	c0 08       	rjmp	800055de <_exit+0x8>

800055e0 <_close>:
800055e0:	30 28       	mov	r8,2
800055e2:	d6 73       	breakpoint
800055e4:	3f fc       	mov	r12,-1
800055e6:	35 8b       	mov	r11,88
800055e8:	58 0c       	cp.w	r12,0
800055ea:	5e 4c       	retge	r12
800055ec:	48 2a       	lddpc	r10,800055f4 <_close+0x14>
800055ee:	95 0b       	st.w	r10[0x0],r11
800055f0:	5e fc       	retal	r12
800055f2:	d7 03       	nop
800055f4:	00 00       	add	r0,r0
800055f6:	0a 38       	cp.w	r8,r5

800055f8 <_lseek>:
800055f8:	30 58       	mov	r8,5
800055fa:	d6 73       	breakpoint
800055fc:	3f fc       	mov	r12,-1
800055fe:	35 8b       	mov	r11,88
80005600:	58 0c       	cp.w	r12,0
80005602:	5e 4c       	retge	r12
80005604:	48 2a       	lddpc	r10,8000560c <_lseek+0x14>
80005606:	95 0b       	st.w	r10[0x0],r11
80005608:	5e fc       	retal	r12
8000560a:	d7 03       	nop
8000560c:	00 00       	add	r0,r0
8000560e:	0a 38       	cp.w	r8,r5

80005610 <isatty>:
80005610:	30 b8       	mov	r8,11
80005612:	d6 73       	breakpoint
80005614:	3f fc       	mov	r12,-1
80005616:	35 8b       	mov	r11,88
80005618:	58 0c       	cp.w	r12,0
8000561a:	5e 4c       	retge	r12
8000561c:	48 2a       	lddpc	r10,80005624 <isatty+0x14>
8000561e:	95 0b       	st.w	r10[0x0],r11
80005620:	5e fc       	retal	r12
80005622:	d7 03       	nop
80005624:	00 00       	add	r0,r0
80005626:	0a 38       	cp.w	r8,r5

80005628 <_fstat_host>:
80005628:	30 98       	mov	r8,9
8000562a:	d6 73       	breakpoint
8000562c:	3f fc       	mov	r12,-1
8000562e:	35 8b       	mov	r11,88
80005630:	58 0c       	cp.w	r12,0
80005632:	5e 4c       	retge	r12
80005634:	48 2a       	lddpc	r10,8000563c <_fstat_host+0x14>
80005636:	95 0b       	st.w	r10[0x0],r11
80005638:	5e fc       	retal	r12
8000563a:	d7 03       	nop
8000563c:	00 00       	add	r0,r0
8000563e:	0a 38       	cp.w	r8,r5

80005640 <_fstat>:
80005640:	d4 21       	pushm	r4-r7,lr
80005642:	21 0d       	sub	sp,64
80005644:	16 97       	mov	r7,r11
80005646:	1a 9b       	mov	r11,sp
80005648:	cf 0f       	rcall	80005628 <_fstat_host>
8000564a:	c0 34       	brge	80005650 <_fstat+0x10>
8000564c:	3f fc       	mov	r12,-1
8000564e:	c1 c8       	rjmp	80005686 <_fstat+0x46>
80005650:	40 08       	lddsp	r8,sp[0x0]
80005652:	ae 08       	st.h	r7[0x0],r8
80005654:	40 18       	lddsp	r8,sp[0x4]
80005656:	ae 18       	st.h	r7[0x2],r8
80005658:	40 28       	lddsp	r8,sp[0x8]
8000565a:	8f 18       	st.w	r7[0x4],r8
8000565c:	40 38       	lddsp	r8,sp[0xc]
8000565e:	ae 48       	st.h	r7[0x8],r8
80005660:	40 48       	lddsp	r8,sp[0x10]
80005662:	ae 58       	st.h	r7[0xa],r8
80005664:	40 58       	lddsp	r8,sp[0x14]
80005666:	ae 68       	st.h	r7[0xc],r8
80005668:	40 68       	lddsp	r8,sp[0x18]
8000566a:	ae 78       	st.h	r7[0xe],r8
8000566c:	40 88       	lddsp	r8,sp[0x20]
8000566e:	8f 48       	st.w	r7[0x10],r8
80005670:	40 a8       	lddsp	r8,sp[0x28]
80005672:	8f b8       	st.w	r7[0x2c],r8
80005674:	40 c8       	lddsp	r8,sp[0x30]
80005676:	8f c8       	st.w	r7[0x30],r8
80005678:	40 d8       	lddsp	r8,sp[0x34]
8000567a:	8f 58       	st.w	r7[0x14],r8
8000567c:	40 e8       	lddsp	r8,sp[0x38]
8000567e:	30 0c       	mov	r12,0
80005680:	8f 78       	st.w	r7[0x1c],r8
80005682:	40 f8       	lddsp	r8,sp[0x3c]
80005684:	8f 98       	st.w	r7[0x24],r8
80005686:	2f 0d       	sub	sp,-64
80005688:	d8 22       	popm	r4-r7,pc
8000568a:	d7 03       	nop

8000568c <_sbrk>:
8000568c:	d4 01       	pushm	lr
8000568e:	48 c8       	lddpc	r8,800056bc <_sbrk+0x30>
80005690:	70 09       	ld.w	r9,r8[0x0]
80005692:	58 09       	cp.w	r9,0
80005694:	c0 31       	brne	8000569a <_sbrk+0xe>
80005696:	48 b9       	lddpc	r9,800056c0 <_sbrk+0x34>
80005698:	91 09       	st.w	r8[0x0],r9
8000569a:	48 99       	lddpc	r9,800056bc <_sbrk+0x30>
8000569c:	48 aa       	lddpc	r10,800056c4 <_sbrk+0x38>
8000569e:	72 08       	ld.w	r8,r9[0x0]
800056a0:	f0 0c 00 0c 	add	r12,r8,r12
800056a4:	14 3c       	cp.w	r12,r10
800056a6:	e0 8b 00 04 	brhi	800056ae <_sbrk+0x22>
800056aa:	93 0c       	st.w	r9[0x0],r12
800056ac:	c0 58       	rjmp	800056b6 <_sbrk+0x2a>
800056ae:	cc 9c       	rcall	80005840 <__errno>
800056b0:	30 c8       	mov	r8,12
800056b2:	99 08       	st.w	r12[0x0],r8
800056b4:	3f f8       	mov	r8,-1
800056b6:	10 9c       	mov	r12,r8
800056b8:	d8 02       	popm	pc
800056ba:	d7 03       	nop
800056bc:	00 00       	add	r0,r0
800056be:	0a 08       	add	r8,r5
800056c0:	00 00       	add	r0,r0
800056c2:	0a 40       	or	r0,r5
800056c4:	00 00       	add	r0,r0
800056c6:	f0 00       	*unknown*

800056c8 <__register_exitproc>:
800056c8:	d4 31       	pushm	r0-r7,lr
800056ca:	4a 98       	lddpc	r8,8000576c <__register_exitproc+0xa4>
800056cc:	70 03       	ld.w	r3,r8[0x0]
800056ce:	67 24       	ld.w	r4,r3[0x48]
800056d0:	e6 c8 ff b4 	sub	r8,r3,-76
800056d4:	58 04       	cp.w	r4,0
800056d6:	f0 04 17 00 	moveq	r4,r8
800056da:	e7 f4 0a 12 	st.weq	r3[0x48],r4
800056de:	18 97       	mov	r7,r12
800056e0:	16 96       	mov	r6,r11
800056e2:	14 95       	mov	r5,r10
800056e4:	12 92       	mov	r2,r9
800056e6:	68 18       	ld.w	r8,r4[0x4]
800056e8:	59 f8       	cp.w	r8,31
800056ea:	e0 8a 00 0e 	brle	80005706 <__register_exitproc+0x3e>
800056ee:	e0 6c 00 8c 	mov	r12,140
800056f2:	fe b0 fa 4d 	rcall	80004b8c <malloc>
800056f6:	18 94       	mov	r4,r12
800056f8:	c3 80       	breq	80005768 <__register_exitproc+0xa0>
800056fa:	67 28       	ld.w	r8,r3[0x48]
800056fc:	99 08       	st.w	r12[0x0],r8
800056fe:	e7 4c 00 48 	st.w	r3[72],r12
80005702:	30 08       	mov	r8,0
80005704:	99 18       	st.w	r12[0x4],r8
80005706:	58 07       	cp.w	r7,0
80005708:	c2 70       	breq	80005756 <__register_exitproc+0x8e>
8000570a:	e8 fc 00 88 	ld.w	r12,r4[136]
8000570e:	58 0c       	cp.w	r12,0
80005710:	c0 d1       	brne	8000572a <__register_exitproc+0x62>
80005712:	e0 6c 01 08 	mov	r12,264
80005716:	fe b0 fa 3b 	rcall	80004b8c <malloc>
8000571a:	c2 70       	breq	80005768 <__register_exitproc+0xa0>
8000571c:	30 08       	mov	r8,0
8000571e:	e9 4c 00 88 	st.w	r4[136],r12
80005722:	f9 48 01 04 	st.w	r12[260],r8
80005726:	f9 48 01 00 	st.w	r12[256],r8
8000572a:	68 18       	ld.w	r8,r4[0x4]
8000572c:	f0 c9 ff e0 	sub	r9,r8,-32
80005730:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80005734:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80005738:	30 1a       	mov	r10,1
8000573a:	f8 f9 01 00 	ld.w	r9,r12[256]
8000573e:	f4 08 09 48 	lsl	r8,r10,r8
80005742:	10 49       	or	r9,r8
80005744:	f9 49 01 00 	st.w	r12[256],r9
80005748:	58 27       	cp.w	r7,2
8000574a:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
8000574e:	f3 d8 e0 38 	oreq	r8,r9,r8
80005752:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80005756:	68 18       	ld.w	r8,r4[0x4]
80005758:	30 0c       	mov	r12,0
8000575a:	f0 c9 ff ff 	sub	r9,r8,-1
8000575e:	2f e8       	sub	r8,-2
80005760:	89 19       	st.w	r4[0x4],r9
80005762:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80005766:	d8 32       	popm	r0-r7,pc
80005768:	dc 3a       	popm	r0-r7,pc,r12=-1
8000576a:	d7 03       	nop
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	67 20       	ld.w	r0,r3[0x48]

80005770 <__call_exitprocs>:
80005770:	d4 31       	pushm	r0-r7,lr
80005772:	20 3d       	sub	sp,12
80005774:	4b 28       	lddpc	r8,8000583c <__call_exitprocs+0xcc>
80005776:	50 2c       	stdsp	sp[0x8],r12
80005778:	70 08       	ld.w	r8,r8[0x0]
8000577a:	16 91       	mov	r1,r11
8000577c:	50 08       	stdsp	sp[0x0],r8
8000577e:	2b 88       	sub	r8,-72
80005780:	50 18       	stdsp	sp[0x4],r8
80005782:	40 0a       	lddsp	r10,sp[0x0]
80005784:	40 14       	lddsp	r4,sp[0x4]
80005786:	75 27       	ld.w	r7,r10[0x48]
80005788:	c5 58       	rjmp	80005832 <__call_exitprocs+0xc2>
8000578a:	6e 15       	ld.w	r5,r7[0x4]
8000578c:	ee f6 00 88 	ld.w	r6,r7[136]
80005790:	ea c2 ff ff 	sub	r2,r5,-1
80005794:	20 15       	sub	r5,1
80005796:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000579a:	ec 05 00 23 	add	r3,r6,r5<<0x2
8000579e:	c3 58       	rjmp	80005808 <__call_exitprocs+0x98>
800057a0:	58 01       	cp.w	r1,0
800057a2:	c0 70       	breq	800057b0 <__call_exitprocs+0x40>
800057a4:	58 06       	cp.w	r6,0
800057a6:	c2 e0       	breq	80005802 <__call_exitprocs+0x92>
800057a8:	e6 f8 00 80 	ld.w	r8,r3[128]
800057ac:	02 38       	cp.w	r8,r1
800057ae:	c2 a1       	brne	80005802 <__call_exitprocs+0x92>
800057b0:	6e 19       	ld.w	r9,r7[0x4]
800057b2:	64 08       	ld.w	r8,r2[0x0]
800057b4:	20 19       	sub	r9,1
800057b6:	12 35       	cp.w	r5,r9
800057b8:	ef f5 0a 01 	st.weq	r7[0x4],r5
800057bc:	f9 b9 01 00 	movne	r9,0
800057c0:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800057c4:	58 08       	cp.w	r8,0
800057c6:	c1 e0       	breq	80005802 <__call_exitprocs+0x92>
800057c8:	6e 10       	ld.w	r0,r7[0x4]
800057ca:	58 06       	cp.w	r6,0
800057cc:	c0 90       	breq	800057de <__call_exitprocs+0x6e>
800057ce:	30 1a       	mov	r10,1
800057d0:	f4 05 09 49 	lsl	r9,r10,r5
800057d4:	ec fa 01 00 	ld.w	r10,r6[256]
800057d8:	f3 ea 00 0a 	and	r10,r9,r10
800057dc:	c0 31       	brne	800057e2 <__call_exitprocs+0x72>
800057de:	5d 18       	icall	r8
800057e0:	c0 b8       	rjmp	800057f6 <__call_exitprocs+0x86>
800057e2:	ec fa 01 04 	ld.w	r10,r6[260]
800057e6:	66 0b       	ld.w	r11,r3[0x0]
800057e8:	14 69       	and	r9,r10
800057ea:	c0 41       	brne	800057f2 <__call_exitprocs+0x82>
800057ec:	40 2c       	lddsp	r12,sp[0x8]
800057ee:	5d 18       	icall	r8
800057f0:	c0 38       	rjmp	800057f6 <__call_exitprocs+0x86>
800057f2:	16 9c       	mov	r12,r11
800057f4:	5d 18       	icall	r8
800057f6:	6e 18       	ld.w	r8,r7[0x4]
800057f8:	10 30       	cp.w	r0,r8
800057fa:	cc 41       	brne	80005782 <__call_exitprocs+0x12>
800057fc:	68 08       	ld.w	r8,r4[0x0]
800057fe:	0e 38       	cp.w	r8,r7
80005800:	cc 11       	brne	80005782 <__call_exitprocs+0x12>
80005802:	20 15       	sub	r5,1
80005804:	20 43       	sub	r3,4
80005806:	20 42       	sub	r2,4
80005808:	58 05       	cp.w	r5,0
8000580a:	cc b4       	brge	800057a0 <__call_exitprocs+0x30>
8000580c:	6e 18       	ld.w	r8,r7[0x4]
8000580e:	58 08       	cp.w	r8,0
80005810:	c0 f1       	brne	8000582e <__call_exitprocs+0xbe>
80005812:	6e 08       	ld.w	r8,r7[0x0]
80005814:	58 08       	cp.w	r8,0
80005816:	c0 c0       	breq	8000582e <__call_exitprocs+0xbe>
80005818:	89 08       	st.w	r4[0x0],r8
8000581a:	58 06       	cp.w	r6,0
8000581c:	c0 40       	breq	80005824 <__call_exitprocs+0xb4>
8000581e:	0c 9c       	mov	r12,r6
80005820:	fe b0 f9 ac 	rcall	80004b78 <free>
80005824:	0e 9c       	mov	r12,r7
80005826:	fe b0 f9 a9 	rcall	80004b78 <free>
8000582a:	68 07       	ld.w	r7,r4[0x0]
8000582c:	c0 38       	rjmp	80005832 <__call_exitprocs+0xc2>
8000582e:	0e 94       	mov	r4,r7
80005830:	6e 07       	ld.w	r7,r7[0x0]
80005832:	58 07       	cp.w	r7,0
80005834:	ca b1       	brne	8000578a <__call_exitprocs+0x1a>
80005836:	2f dd       	sub	sp,-12
80005838:	d8 32       	popm	r0-r7,pc
8000583a:	d7 03       	nop
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	67 20       	ld.w	r0,r3[0x48]

80005840 <__errno>:
80005840:	48 28       	lddpc	r8,80005848 <__errno+0x8>
80005842:	70 0c       	ld.w	r12,r8[0x0]
80005844:	2f 4c       	sub	r12,-12
80005846:	5e fc       	retal	r12
80005848:	00 00       	add	r0,r0
8000584a:	01 e0       	ld.ub	r0,r0[0x6]

8000584c <_fflush_r>:
8000584c:	d4 21       	pushm	r4-r7,lr
8000584e:	16 97       	mov	r7,r11
80005850:	18 96       	mov	r6,r12
80005852:	76 48       	ld.w	r8,r11[0x10]
80005854:	58 08       	cp.w	r8,0
80005856:	c7 c0       	breq	8000594e <_fflush_r+0x102>
80005858:	58 0c       	cp.w	r12,0
8000585a:	c0 50       	breq	80005864 <_fflush_r+0x18>
8000585c:	78 68       	ld.w	r8,r12[0x18]
8000585e:	58 08       	cp.w	r8,0
80005860:	c0 21       	brne	80005864 <_fflush_r+0x18>
80005862:	cd 1c       	rcall	80005a04 <__sinit>
80005864:	4b b8       	lddpc	r8,80005950 <_fflush_r+0x104>
80005866:	10 37       	cp.w	r7,r8
80005868:	c0 31       	brne	8000586e <_fflush_r+0x22>
8000586a:	6c 07       	ld.w	r7,r6[0x0]
8000586c:	c0 a8       	rjmp	80005880 <_fflush_r+0x34>
8000586e:	4b a8       	lddpc	r8,80005954 <_fflush_r+0x108>
80005870:	10 37       	cp.w	r7,r8
80005872:	c0 31       	brne	80005878 <_fflush_r+0x2c>
80005874:	6c 17       	ld.w	r7,r6[0x4]
80005876:	c0 58       	rjmp	80005880 <_fflush_r+0x34>
80005878:	4b 88       	lddpc	r8,80005958 <_fflush_r+0x10c>
8000587a:	10 37       	cp.w	r7,r8
8000587c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80005880:	8e 6a       	ld.sh	r10,r7[0xc]
80005882:	14 98       	mov	r8,r10
80005884:	ed ba 00 03 	bld	r10,0x3
80005888:	c4 20       	breq	8000590c <_fflush_r+0xc0>
8000588a:	ab ba       	sbr	r10,0xb
8000588c:	ae 6a       	st.h	r7[0xc],r10
8000588e:	6e 18       	ld.w	r8,r7[0x4]
80005890:	58 08       	cp.w	r8,0
80005892:	e0 89 00 06 	brgt	8000589e <_fflush_r+0x52>
80005896:	6f 08       	ld.w	r8,r7[0x40]
80005898:	58 08       	cp.w	r8,0
8000589a:	e0 8a 00 5a 	brle	8000594e <_fflush_r+0x102>
8000589e:	6e b8       	ld.w	r8,r7[0x2c]
800058a0:	58 08       	cp.w	r8,0
800058a2:	c5 60       	breq	8000594e <_fflush_r+0x102>
800058a4:	e2 1a 10 00 	andl	r10,0x1000,COH
800058a8:	c0 30       	breq	800058ae <_fflush_r+0x62>
800058aa:	6f 55       	ld.w	r5,r7[0x54]
800058ac:	c0 f8       	rjmp	800058ca <_fflush_r+0x7e>
800058ae:	30 19       	mov	r9,1
800058b0:	6e 8b       	ld.w	r11,r7[0x20]
800058b2:	0c 9c       	mov	r12,r6
800058b4:	5d 18       	icall	r8
800058b6:	18 95       	mov	r5,r12
800058b8:	5b fc       	cp.w	r12,-1
800058ba:	c0 81       	brne	800058ca <_fflush_r+0x7e>
800058bc:	6c 38       	ld.w	r8,r6[0xc]
800058be:	59 d8       	cp.w	r8,29
800058c0:	c4 70       	breq	8000594e <_fflush_r+0x102>
800058c2:	8e 68       	ld.sh	r8,r7[0xc]
800058c4:	a7 a8       	sbr	r8,0x6
800058c6:	ae 68       	st.h	r7[0xc],r8
800058c8:	d8 22       	popm	r4-r7,pc
800058ca:	8e 68       	ld.sh	r8,r7[0xc]
800058cc:	ed b8 00 02 	bld	r8,0x2
800058d0:	c0 91       	brne	800058e2 <_fflush_r+0x96>
800058d2:	6e 18       	ld.w	r8,r7[0x4]
800058d4:	10 15       	sub	r5,r8
800058d6:	6e d8       	ld.w	r8,r7[0x34]
800058d8:	58 08       	cp.w	r8,0
800058da:	ef f8 10 10 	ld.wne	r8,r7[0x40]
800058de:	eb d8 e1 15 	subne	r5,r5,r8
800058e2:	6e b8       	ld.w	r8,r7[0x2c]
800058e4:	0c 9c       	mov	r12,r6
800058e6:	30 09       	mov	r9,0
800058e8:	0a 9a       	mov	r10,r5
800058ea:	6e 8b       	ld.w	r11,r7[0x20]
800058ec:	5d 18       	icall	r8
800058ee:	8e 68       	ld.sh	r8,r7[0xc]
800058f0:	0a 3c       	cp.w	r12,r5
800058f2:	c2 61       	brne	8000593e <_fflush_r+0xf2>
800058f4:	ab d8       	cbr	r8,0xb
800058f6:	30 0c       	mov	r12,0
800058f8:	6e 49       	ld.w	r9,r7[0x10]
800058fa:	ae 68       	st.h	r7[0xc],r8
800058fc:	8f 1c       	st.w	r7[0x4],r12
800058fe:	8f 09       	st.w	r7[0x0],r9
80005900:	ed b8 00 0c 	bld	r8,0xc
80005904:	c2 51       	brne	8000594e <_fflush_r+0x102>
80005906:	ef 45 00 54 	st.w	r7[84],r5
8000590a:	d8 22       	popm	r4-r7,pc
8000590c:	6e 45       	ld.w	r5,r7[0x10]
8000590e:	58 05       	cp.w	r5,0
80005910:	c1 f0       	breq	8000594e <_fflush_r+0x102>
80005912:	6e 04       	ld.w	r4,r7[0x0]
80005914:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80005918:	8f 05       	st.w	r7[0x0],r5
8000591a:	f9 b8 01 00 	movne	r8,0
8000591e:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80005922:	0a 14       	sub	r4,r5
80005924:	8f 28       	st.w	r7[0x8],r8
80005926:	c1 18       	rjmp	80005948 <_fflush_r+0xfc>
80005928:	08 99       	mov	r9,r4
8000592a:	0a 9a       	mov	r10,r5
8000592c:	6e a8       	ld.w	r8,r7[0x28]
8000592e:	6e 8b       	ld.w	r11,r7[0x20]
80005930:	0c 9c       	mov	r12,r6
80005932:	5d 18       	icall	r8
80005934:	18 14       	sub	r4,r12
80005936:	58 0c       	cp.w	r12,0
80005938:	e0 89 00 07 	brgt	80005946 <_fflush_r+0xfa>
8000593c:	8e 68       	ld.sh	r8,r7[0xc]
8000593e:	a7 a8       	sbr	r8,0x6
80005940:	3f fc       	mov	r12,-1
80005942:	ae 68       	st.h	r7[0xc],r8
80005944:	d8 22       	popm	r4-r7,pc
80005946:	18 05       	add	r5,r12
80005948:	58 04       	cp.w	r4,0
8000594a:	fe 99 ff ef 	brgt	80005928 <_fflush_r+0xdc>
8000594e:	d8 2a       	popm	r4-r7,pc,r12=0
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	67 28       	ld.w	r8,r3[0x48]
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	67 48       	ld.w	r8,r3[0x50]
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	67 68       	ld.w	r8,r3[0x58]

8000595c <__sfp_lock_acquire>:
8000595c:	5e fc       	retal	r12

8000595e <__sfp_lock_release>:
8000595e:	5e fc       	retal	r12

80005960 <_cleanup_r>:
80005960:	d4 01       	pushm	lr
80005962:	fe cb f7 0e 	sub	r11,pc,-2290
80005966:	e0 a0 02 fd 	rcall	80005f60 <_fwalk>
8000596a:	d8 02       	popm	pc

8000596c <__sfmoreglue>:
8000596c:	d4 21       	pushm	r4-r7,lr
8000596e:	16 95       	mov	r5,r11
80005970:	f6 06 10 5c 	mul	r6,r11,92
80005974:	ec cb ff f4 	sub	r11,r6,-12
80005978:	fe b0 f9 12 	rcall	80004b9c <_malloc_r>
8000597c:	18 97       	mov	r7,r12
8000597e:	c0 90       	breq	80005990 <__sfmoreglue+0x24>
80005980:	99 15       	st.w	r12[0x4],r5
80005982:	30 0b       	mov	r11,0
80005984:	2f 4c       	sub	r12,-12
80005986:	0c 9a       	mov	r10,r6
80005988:	8f 2c       	st.w	r7[0x8],r12
8000598a:	8f 0b       	st.w	r7[0x0],r11
8000598c:	fe b0 fb c8 	rcall	8000511c <memset>
80005990:	0e 9c       	mov	r12,r7
80005992:	d8 22       	popm	r4-r7,pc

80005994 <__sfp>:
80005994:	d4 21       	pushm	r4-r7,lr
80005996:	49 b8       	lddpc	r8,80005a00 <__sfp+0x6c>
80005998:	18 96       	mov	r6,r12
8000599a:	70 07       	ld.w	r7,r8[0x0]
8000599c:	6e 68       	ld.w	r8,r7[0x18]
8000599e:	58 08       	cp.w	r8,0
800059a0:	c0 31       	brne	800059a6 <__sfp+0x12>
800059a2:	0e 9c       	mov	r12,r7
800059a4:	c3 0c       	rcall	80005a04 <__sinit>
800059a6:	ee c7 ff 28 	sub	r7,r7,-216
800059aa:	30 05       	mov	r5,0
800059ac:	6e 2c       	ld.w	r12,r7[0x8]
800059ae:	6e 18       	ld.w	r8,r7[0x4]
800059b0:	c0 68       	rjmp	800059bc <__sfp+0x28>
800059b2:	98 69       	ld.sh	r9,r12[0xc]
800059b4:	ea 09 19 00 	cp.h	r9,r5
800059b8:	c1 10       	breq	800059da <__sfp+0x46>
800059ba:	2a 4c       	sub	r12,-92
800059bc:	20 18       	sub	r8,1
800059be:	cf a7       	brpl	800059b2 <__sfp+0x1e>
800059c0:	6e 08       	ld.w	r8,r7[0x0]
800059c2:	58 08       	cp.w	r8,0
800059c4:	c0 61       	brne	800059d0 <__sfp+0x3c>
800059c6:	30 4b       	mov	r11,4
800059c8:	0c 9c       	mov	r12,r6
800059ca:	cd 1f       	rcall	8000596c <__sfmoreglue>
800059cc:	8f 0c       	st.w	r7[0x0],r12
800059ce:	c0 30       	breq	800059d4 <__sfp+0x40>
800059d0:	6e 07       	ld.w	r7,r7[0x0]
800059d2:	ce db       	rjmp	800059ac <__sfp+0x18>
800059d4:	30 c8       	mov	r8,12
800059d6:	8d 38       	st.w	r6[0xc],r8
800059d8:	d8 22       	popm	r4-r7,pc
800059da:	30 08       	mov	r8,0
800059dc:	f9 48 00 4c 	st.w	r12[76],r8
800059e0:	99 08       	st.w	r12[0x0],r8
800059e2:	99 28       	st.w	r12[0x8],r8
800059e4:	99 18       	st.w	r12[0x4],r8
800059e6:	99 48       	st.w	r12[0x10],r8
800059e8:	99 58       	st.w	r12[0x14],r8
800059ea:	99 68       	st.w	r12[0x18],r8
800059ec:	99 d8       	st.w	r12[0x34],r8
800059ee:	99 e8       	st.w	r12[0x38],r8
800059f0:	f9 48 00 48 	st.w	r12[72],r8
800059f4:	3f f8       	mov	r8,-1
800059f6:	b8 78       	st.h	r12[0xe],r8
800059f8:	30 18       	mov	r8,1
800059fa:	b8 68       	st.h	r12[0xc],r8
800059fc:	d8 22       	popm	r4-r7,pc
800059fe:	d7 03       	nop
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	67 20       	ld.w	r0,r3[0x48]

80005a04 <__sinit>:
80005a04:	d4 21       	pushm	r4-r7,lr
80005a06:	18 96       	mov	r6,r12
80005a08:	78 67       	ld.w	r7,r12[0x18]
80005a0a:	58 07       	cp.w	r7,0
80005a0c:	c4 91       	brne	80005a9e <__sinit+0x9a>
80005a0e:	fe c8 00 ae 	sub	r8,pc,174
80005a12:	30 15       	mov	r5,1
80005a14:	99 a8       	st.w	r12[0x28],r8
80005a16:	f9 47 00 d8 	st.w	r12[216],r7
80005a1a:	f9 47 00 dc 	st.w	r12[220],r7
80005a1e:	f9 47 00 e0 	st.w	r12[224],r7
80005a22:	99 65       	st.w	r12[0x18],r5
80005a24:	cb 8f       	rcall	80005994 <__sfp>
80005a26:	8d 0c       	st.w	r6[0x0],r12
80005a28:	0c 9c       	mov	r12,r6
80005a2a:	cb 5f       	rcall	80005994 <__sfp>
80005a2c:	8d 1c       	st.w	r6[0x4],r12
80005a2e:	0c 9c       	mov	r12,r6
80005a30:	cb 2f       	rcall	80005994 <__sfp>
80005a32:	6c 09       	ld.w	r9,r6[0x0]
80005a34:	30 48       	mov	r8,4
80005a36:	93 07       	st.w	r9[0x0],r7
80005a38:	b2 68       	st.h	r9[0xc],r8
80005a3a:	93 17       	st.w	r9[0x4],r7
80005a3c:	93 27       	st.w	r9[0x8],r7
80005a3e:	6c 18       	ld.w	r8,r6[0x4]
80005a40:	b2 77       	st.h	r9[0xe],r7
80005a42:	93 47       	st.w	r9[0x10],r7
80005a44:	93 57       	st.w	r9[0x14],r7
80005a46:	93 67       	st.w	r9[0x18],r7
80005a48:	93 89       	st.w	r9[0x20],r9
80005a4a:	91 07       	st.w	r8[0x0],r7
80005a4c:	91 17       	st.w	r8[0x4],r7
80005a4e:	91 27       	st.w	r8[0x8],r7
80005a50:	fe ce f9 fc 	sub	lr,pc,-1540
80005a54:	fe cb fa 2c 	sub	r11,pc,-1492
80005a58:	93 9e       	st.w	r9[0x24],lr
80005a5a:	93 ab       	st.w	r9[0x28],r11
80005a5c:	fe ca fa 54 	sub	r10,pc,-1452
80005a60:	fe c4 fa 60 	sub	r4,pc,-1440
80005a64:	93 ba       	st.w	r9[0x2c],r10
80005a66:	93 c4       	st.w	r9[0x30],r4
80005a68:	30 99       	mov	r9,9
80005a6a:	b0 69       	st.h	r8[0xc],r9
80005a6c:	b0 75       	st.h	r8[0xe],r5
80005a6e:	91 c4       	st.w	r8[0x30],r4
80005a70:	91 47       	st.w	r8[0x10],r7
80005a72:	91 57       	st.w	r8[0x14],r7
80005a74:	91 67       	st.w	r8[0x18],r7
80005a76:	91 88       	st.w	r8[0x20],r8
80005a78:	91 9e       	st.w	r8[0x24],lr
80005a7a:	91 ab       	st.w	r8[0x28],r11
80005a7c:	91 ba       	st.w	r8[0x2c],r10
80005a7e:	8d 2c       	st.w	r6[0x8],r12
80005a80:	31 28       	mov	r8,18
80005a82:	99 07       	st.w	r12[0x0],r7
80005a84:	b8 68       	st.h	r12[0xc],r8
80005a86:	99 17       	st.w	r12[0x4],r7
80005a88:	99 27       	st.w	r12[0x8],r7
80005a8a:	30 28       	mov	r8,2
80005a8c:	b8 78       	st.h	r12[0xe],r8
80005a8e:	99 c4       	st.w	r12[0x30],r4
80005a90:	99 67       	st.w	r12[0x18],r7
80005a92:	99 9e       	st.w	r12[0x24],lr
80005a94:	99 ab       	st.w	r12[0x28],r11
80005a96:	99 ba       	st.w	r12[0x2c],r10
80005a98:	99 47       	st.w	r12[0x10],r7
80005a9a:	99 57       	st.w	r12[0x14],r7
80005a9c:	99 8c       	st.w	r12[0x20],r12
80005a9e:	d8 22       	popm	r4-r7,pc

80005aa0 <_malloc_trim_r>:
80005aa0:	d4 21       	pushm	r4-r7,lr
80005aa2:	16 95       	mov	r5,r11
80005aa4:	18 97       	mov	r7,r12
80005aa6:	fe b0 f4 2b 	rcall	800042fc <__malloc_lock>
80005aaa:	4a 24       	lddpc	r4,80005b30 <_malloc_trim_r+0x90>
80005aac:	68 28       	ld.w	r8,r4[0x8]
80005aae:	70 16       	ld.w	r6,r8[0x4]
80005ab0:	e0 16 ff fc 	andl	r6,0xfffc
80005ab4:	ec c8 ff 91 	sub	r8,r6,-111
80005ab8:	f0 05 01 05 	sub	r5,r8,r5
80005abc:	e0 15 ff 80 	andl	r5,0xff80
80005ac0:	ea c5 00 80 	sub	r5,r5,128
80005ac4:	e0 45 00 7f 	cp.w	r5,127
80005ac8:	e0 8a 00 23 	brle	80005b0e <_malloc_trim_r+0x6e>
80005acc:	30 0b       	mov	r11,0
80005ace:	0e 9c       	mov	r12,r7
80005ad0:	fe b0 fc c2 	rcall	80005454 <_sbrk_r>
80005ad4:	68 28       	ld.w	r8,r4[0x8]
80005ad6:	0c 08       	add	r8,r6
80005ad8:	10 3c       	cp.w	r12,r8
80005ada:	c1 a1       	brne	80005b0e <_malloc_trim_r+0x6e>
80005adc:	ea 0b 11 00 	rsub	r11,r5,0
80005ae0:	0e 9c       	mov	r12,r7
80005ae2:	fe b0 fc b9 	rcall	80005454 <_sbrk_r>
80005ae6:	5b fc       	cp.w	r12,-1
80005ae8:	c1 71       	brne	80005b16 <_malloc_trim_r+0x76>
80005aea:	30 0b       	mov	r11,0
80005aec:	0e 9c       	mov	r12,r7
80005aee:	fe b0 fc b3 	rcall	80005454 <_sbrk_r>
80005af2:	68 28       	ld.w	r8,r4[0x8]
80005af4:	f8 08 01 09 	sub	r9,r12,r8
80005af8:	58 f9       	cp.w	r9,15
80005afa:	e0 8a 00 0a 	brle	80005b0e <_malloc_trim_r+0x6e>
80005afe:	a1 a9       	sbr	r9,0x0
80005b00:	91 19       	st.w	r8[0x4],r9
80005b02:	48 d8       	lddpc	r8,80005b34 <_malloc_trim_r+0x94>
80005b04:	70 09       	ld.w	r9,r8[0x0]
80005b06:	48 d8       	lddpc	r8,80005b38 <_malloc_trim_r+0x98>
80005b08:	f8 09 01 09 	sub	r9,r12,r9
80005b0c:	91 09       	st.w	r8[0x0],r9
80005b0e:	0e 9c       	mov	r12,r7
80005b10:	fe b0 f3 fc 	rcall	80004308 <__malloc_unlock>
80005b14:	d8 2a       	popm	r4-r7,pc,r12=0
80005b16:	68 28       	ld.w	r8,r4[0x8]
80005b18:	0a 16       	sub	r6,r5
80005b1a:	a1 a6       	sbr	r6,0x0
80005b1c:	91 16       	st.w	r8[0x4],r6
80005b1e:	48 78       	lddpc	r8,80005b38 <_malloc_trim_r+0x98>
80005b20:	70 09       	ld.w	r9,r8[0x0]
80005b22:	0a 19       	sub	r9,r5
80005b24:	0e 9c       	mov	r12,r7
80005b26:	91 09       	st.w	r8[0x0],r9
80005b28:	fe b0 f3 f0 	rcall	80004308 <__malloc_unlock>
80005b2c:	da 2a       	popm	r4-r7,pc,r12=1
80005b2e:	d7 03       	nop
80005b30:	00 00       	add	r0,r0
80005b32:	01 e4       	ld.ub	r4,r0[0x6]
80005b34:	00 00       	add	r0,r0
80005b36:	05 f0       	ld.ub	r0,r2[0x7]
80005b38:	00 00       	add	r0,r0
80005b3a:	09 e0       	ld.ub	r0,r4[0x6]

80005b3c <_free_r>:
80005b3c:	d4 21       	pushm	r4-r7,lr
80005b3e:	16 96       	mov	r6,r11
80005b40:	18 97       	mov	r7,r12
80005b42:	58 0b       	cp.w	r11,0
80005b44:	e0 80 00 c2 	breq	80005cc8 <_free_r+0x18c>
80005b48:	fe b0 f3 da 	rcall	800042fc <__malloc_lock>
80005b4c:	20 86       	sub	r6,8
80005b4e:	4c ba       	lddpc	r10,80005c78 <_free_r+0x13c>
80005b50:	6c 18       	ld.w	r8,r6[0x4]
80005b52:	74 2e       	ld.w	lr,r10[0x8]
80005b54:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005b58:	a1 c8       	cbr	r8,0x0
80005b5a:	ec 08 00 09 	add	r9,r6,r8
80005b5e:	72 1b       	ld.w	r11,r9[0x4]
80005b60:	e0 1b ff fc 	andl	r11,0xfffc
80005b64:	1c 39       	cp.w	r9,lr
80005b66:	c1 c1       	brne	80005b9e <_free_r+0x62>
80005b68:	f6 08 00 08 	add	r8,r11,r8
80005b6c:	58 0c       	cp.w	r12,0
80005b6e:	c0 81       	brne	80005b7e <_free_r+0x42>
80005b70:	6c 09       	ld.w	r9,r6[0x0]
80005b72:	12 16       	sub	r6,r9
80005b74:	12 08       	add	r8,r9
80005b76:	6c 3b       	ld.w	r11,r6[0xc]
80005b78:	6c 29       	ld.w	r9,r6[0x8]
80005b7a:	97 29       	st.w	r11[0x8],r9
80005b7c:	93 3b       	st.w	r9[0xc],r11
80005b7e:	10 99       	mov	r9,r8
80005b80:	95 26       	st.w	r10[0x8],r6
80005b82:	a1 a9       	sbr	r9,0x0
80005b84:	8d 19       	st.w	r6[0x4],r9
80005b86:	4b e9       	lddpc	r9,80005c7c <_free_r+0x140>
80005b88:	72 09       	ld.w	r9,r9[0x0]
80005b8a:	12 38       	cp.w	r8,r9
80005b8c:	c0 53       	brcs	80005b96 <_free_r+0x5a>
80005b8e:	4b d8       	lddpc	r8,80005c80 <_free_r+0x144>
80005b90:	0e 9c       	mov	r12,r7
80005b92:	70 0b       	ld.w	r11,r8[0x0]
80005b94:	c8 6f       	rcall	80005aa0 <_malloc_trim_r>
80005b96:	0e 9c       	mov	r12,r7
80005b98:	fe b0 f3 b8 	rcall	80004308 <__malloc_unlock>
80005b9c:	d8 22       	popm	r4-r7,pc
80005b9e:	93 1b       	st.w	r9[0x4],r11
80005ba0:	58 0c       	cp.w	r12,0
80005ba2:	c0 30       	breq	80005ba8 <_free_r+0x6c>
80005ba4:	30 0c       	mov	r12,0
80005ba6:	c1 08       	rjmp	80005bc6 <_free_r+0x8a>
80005ba8:	6c 0e       	ld.w	lr,r6[0x0]
80005baa:	f4 c5 ff f8 	sub	r5,r10,-8
80005bae:	1c 16       	sub	r6,lr
80005bb0:	1c 08       	add	r8,lr
80005bb2:	6c 2e       	ld.w	lr,r6[0x8]
80005bb4:	0a 3e       	cp.w	lr,r5
80005bb6:	f9 bc 00 01 	moveq	r12,1
80005bba:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80005bbe:	eb fe 1a 02 	st.wne	r5[0x8],lr
80005bc2:	fd f5 1a 03 	st.wne	lr[0xc],r5
80005bc6:	f2 0b 00 0e 	add	lr,r9,r11
80005bca:	7c 1e       	ld.w	lr,lr[0x4]
80005bcc:	ed be 00 00 	bld	lr,0x0
80005bd0:	c1 30       	breq	80005bf6 <_free_r+0xba>
80005bd2:	16 08       	add	r8,r11
80005bd4:	58 0c       	cp.w	r12,0
80005bd6:	c0 c1       	brne	80005bee <_free_r+0xb2>
80005bd8:	4a 8e       	lddpc	lr,80005c78 <_free_r+0x13c>
80005bda:	72 2b       	ld.w	r11,r9[0x8]
80005bdc:	2f 8e       	sub	lr,-8
80005bde:	1c 3b       	cp.w	r11,lr
80005be0:	c0 71       	brne	80005bee <_free_r+0xb2>
80005be2:	97 36       	st.w	r11[0xc],r6
80005be4:	97 26       	st.w	r11[0x8],r6
80005be6:	8d 2b       	st.w	r6[0x8],r11
80005be8:	8d 3b       	st.w	r6[0xc],r11
80005bea:	30 1c       	mov	r12,1
80005bec:	c0 58       	rjmp	80005bf6 <_free_r+0xba>
80005bee:	72 2b       	ld.w	r11,r9[0x8]
80005bf0:	72 39       	ld.w	r9,r9[0xc]
80005bf2:	93 2b       	st.w	r9[0x8],r11
80005bf4:	97 39       	st.w	r11[0xc],r9
80005bf6:	10 99       	mov	r9,r8
80005bf8:	ec 08 09 08 	st.w	r6[r8],r8
80005bfc:	a1 a9       	sbr	r9,0x0
80005bfe:	8d 19       	st.w	r6[0x4],r9
80005c00:	58 0c       	cp.w	r12,0
80005c02:	c6 01       	brne	80005cc2 <_free_r+0x186>
80005c04:	e0 48 01 ff 	cp.w	r8,511
80005c08:	e0 8b 00 13 	brhi	80005c2e <_free_r+0xf2>
80005c0c:	a3 98       	lsr	r8,0x3
80005c0e:	f4 08 00 39 	add	r9,r10,r8<<0x3
80005c12:	72 2b       	ld.w	r11,r9[0x8]
80005c14:	8d 39       	st.w	r6[0xc],r9
80005c16:	8d 2b       	st.w	r6[0x8],r11
80005c18:	97 36       	st.w	r11[0xc],r6
80005c1a:	93 26       	st.w	r9[0x8],r6
80005c1c:	a3 48       	asr	r8,0x2
80005c1e:	74 19       	ld.w	r9,r10[0x4]
80005c20:	30 1b       	mov	r11,1
80005c22:	f6 08 09 48 	lsl	r8,r11,r8
80005c26:	f3 e8 10 08 	or	r8,r9,r8
80005c2a:	95 18       	st.w	r10[0x4],r8
80005c2c:	c4 b8       	rjmp	80005cc2 <_free_r+0x186>
80005c2e:	f0 0b 16 09 	lsr	r11,r8,0x9
80005c32:	58 4b       	cp.w	r11,4
80005c34:	e0 8b 00 06 	brhi	80005c40 <_free_r+0x104>
80005c38:	f0 0b 16 06 	lsr	r11,r8,0x6
80005c3c:	2c 8b       	sub	r11,-56
80005c3e:	c2 68       	rjmp	80005c8a <_free_r+0x14e>
80005c40:	59 4b       	cp.w	r11,20
80005c42:	e0 8b 00 04 	brhi	80005c4a <_free_r+0x10e>
80005c46:	2a 5b       	sub	r11,-91
80005c48:	c2 18       	rjmp	80005c8a <_free_r+0x14e>
80005c4a:	e0 4b 00 54 	cp.w	r11,84
80005c4e:	e0 8b 00 06 	brhi	80005c5a <_free_r+0x11e>
80005c52:	f0 0b 16 0c 	lsr	r11,r8,0xc
80005c56:	29 2b       	sub	r11,-110
80005c58:	c1 98       	rjmp	80005c8a <_free_r+0x14e>
80005c5a:	e0 4b 01 54 	cp.w	r11,340
80005c5e:	e0 8b 00 06 	brhi	80005c6a <_free_r+0x12e>
80005c62:	f0 0b 16 0f 	lsr	r11,r8,0xf
80005c66:	28 9b       	sub	r11,-119
80005c68:	c1 18       	rjmp	80005c8a <_free_r+0x14e>
80005c6a:	e0 4b 05 54 	cp.w	r11,1364
80005c6e:	e0 88 00 0b 	brls	80005c84 <_free_r+0x148>
80005c72:	37 eb       	mov	r11,126
80005c74:	c0 b8       	rjmp	80005c8a <_free_r+0x14e>
80005c76:	d7 03       	nop
80005c78:	00 00       	add	r0,r0
80005c7a:	01 e4       	ld.ub	r4,r0[0x6]
80005c7c:	00 00       	add	r0,r0
80005c7e:	05 ec       	ld.ub	r12,r2[0x6]
80005c80:	00 00       	add	r0,r0
80005c82:	09 dc       	ld.ub	r12,r4[0x5]
80005c84:	f0 0b 16 12 	lsr	r11,r8,0x12
80005c88:	28 4b       	sub	r11,-124
80005c8a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80005c8e:	78 29       	ld.w	r9,r12[0x8]
80005c90:	18 39       	cp.w	r9,r12
80005c92:	c0 e1       	brne	80005cae <_free_r+0x172>
80005c94:	74 18       	ld.w	r8,r10[0x4]
80005c96:	a3 4b       	asr	r11,0x2
80005c98:	30 1c       	mov	r12,1
80005c9a:	f8 0b 09 4b 	lsl	r11,r12,r11
80005c9e:	f1 eb 10 0b 	or	r11,r8,r11
80005ca2:	12 98       	mov	r8,r9
80005ca4:	95 1b       	st.w	r10[0x4],r11
80005ca6:	c0 a8       	rjmp	80005cba <_free_r+0x17e>
80005ca8:	72 29       	ld.w	r9,r9[0x8]
80005caa:	18 39       	cp.w	r9,r12
80005cac:	c0 60       	breq	80005cb8 <_free_r+0x17c>
80005cae:	72 1a       	ld.w	r10,r9[0x4]
80005cb0:	e0 1a ff fc 	andl	r10,0xfffc
80005cb4:	14 38       	cp.w	r8,r10
80005cb6:	cf 93       	brcs	80005ca8 <_free_r+0x16c>
80005cb8:	72 38       	ld.w	r8,r9[0xc]
80005cba:	8d 38       	st.w	r6[0xc],r8
80005cbc:	8d 29       	st.w	r6[0x8],r9
80005cbe:	93 36       	st.w	r9[0xc],r6
80005cc0:	91 26       	st.w	r8[0x8],r6
80005cc2:	0e 9c       	mov	r12,r7
80005cc4:	fe b0 f3 22 	rcall	80004308 <__malloc_unlock>
80005cc8:	d8 22       	popm	r4-r7,pc
80005cca:	d7 03       	nop

80005ccc <__sfvwrite_r>:
80005ccc:	d4 31       	pushm	r0-r7,lr
80005cce:	20 3d       	sub	sp,12
80005cd0:	14 94       	mov	r4,r10
80005cd2:	18 95       	mov	r5,r12
80005cd4:	16 97       	mov	r7,r11
80005cd6:	74 28       	ld.w	r8,r10[0x8]
80005cd8:	58 08       	cp.w	r8,0
80005cda:	e0 80 01 3f 	breq	80005f58 <__sfvwrite_r+0x28c>
80005cde:	96 68       	ld.sh	r8,r11[0xc]
80005ce0:	ed b8 00 03 	bld	r8,0x3
80005ce4:	c0 41       	brne	80005cec <__sfvwrite_r+0x20>
80005ce6:	76 48       	ld.w	r8,r11[0x10]
80005ce8:	58 08       	cp.w	r8,0
80005cea:	c0 b1       	brne	80005d00 <__sfvwrite_r+0x34>
80005cec:	0e 9b       	mov	r11,r7
80005cee:	0a 9c       	mov	r12,r5
80005cf0:	cd 4d       	rcall	80006098 <__swsetup_r>
80005cf2:	c0 70       	breq	80005d00 <__sfvwrite_r+0x34>
80005cf4:	8e 68       	ld.sh	r8,r7[0xc]
80005cf6:	a7 a8       	sbr	r8,0x6
80005cf8:	ae 68       	st.h	r7[0xc],r8
80005cfa:	30 98       	mov	r8,9
80005cfc:	8b 38       	st.w	r5[0xc],r8
80005cfe:	c2 b9       	rjmp	80005f54 <__sfvwrite_r+0x288>
80005d00:	8e 63       	ld.sh	r3,r7[0xc]
80005d02:	68 00       	ld.w	r0,r4[0x0]
80005d04:	06 96       	mov	r6,r3
80005d06:	e2 16 00 02 	andl	r6,0x2,COH
80005d0a:	c2 10       	breq	80005d4c <__sfvwrite_r+0x80>
80005d0c:	30 03       	mov	r3,0
80005d0e:	e0 62 04 00 	mov	r2,1024
80005d12:	06 96       	mov	r6,r3
80005d14:	c0 48       	rjmp	80005d1c <__sfvwrite_r+0x50>
80005d16:	60 03       	ld.w	r3,r0[0x0]
80005d18:	60 16       	ld.w	r6,r0[0x4]
80005d1a:	2f 80       	sub	r0,-8
80005d1c:	58 06       	cp.w	r6,0
80005d1e:	cf c0       	breq	80005d16 <__sfvwrite_r+0x4a>
80005d20:	e0 46 04 00 	cp.w	r6,1024
80005d24:	ec 09 17 80 	movls	r9,r6
80005d28:	e4 09 17 b0 	movhi	r9,r2
80005d2c:	06 9a       	mov	r10,r3
80005d2e:	6e a8       	ld.w	r8,r7[0x28]
80005d30:	6e 8b       	ld.w	r11,r7[0x20]
80005d32:	0a 9c       	mov	r12,r5
80005d34:	5d 18       	icall	r8
80005d36:	18 16       	sub	r6,r12
80005d38:	58 0c       	cp.w	r12,0
80005d3a:	e0 8a 01 0a 	brle	80005f4e <__sfvwrite_r+0x282>
80005d3e:	68 28       	ld.w	r8,r4[0x8]
80005d40:	18 18       	sub	r8,r12
80005d42:	89 28       	st.w	r4[0x8],r8
80005d44:	e0 80 01 0a 	breq	80005f58 <__sfvwrite_r+0x28c>
80005d48:	18 03       	add	r3,r12
80005d4a:	ce 9b       	rjmp	80005d1c <__sfvwrite_r+0x50>
80005d4c:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80005d50:	c0 70       	breq	80005d5e <__sfvwrite_r+0x92>
80005d52:	50 06       	stdsp	sp[0x0],r6
80005d54:	0c 93       	mov	r3,r6
80005d56:	0c 91       	mov	r1,r6
80005d58:	50 15       	stdsp	sp[0x4],r5
80005d5a:	08 92       	mov	r2,r4
80005d5c:	c9 c8       	rjmp	80005e94 <__sfvwrite_r+0x1c8>
80005d5e:	06 96       	mov	r6,r3
80005d60:	08 91       	mov	r1,r4
80005d62:	c0 48       	rjmp	80005d6a <__sfvwrite_r+0x9e>
80005d64:	60 03       	ld.w	r3,r0[0x0]
80005d66:	60 16       	ld.w	r6,r0[0x4]
80005d68:	2f 80       	sub	r0,-8
80005d6a:	58 06       	cp.w	r6,0
80005d6c:	cf c0       	breq	80005d64 <__sfvwrite_r+0x98>
80005d6e:	8e 68       	ld.sh	r8,r7[0xc]
80005d70:	6e 24       	ld.w	r4,r7[0x8]
80005d72:	10 99       	mov	r9,r8
80005d74:	e2 19 02 00 	andl	r9,0x200,COH
80005d78:	c5 50       	breq	80005e22 <__sfvwrite_r+0x156>
80005d7a:	08 36       	cp.w	r6,r4
80005d7c:	c4 43       	brcs	80005e04 <__sfvwrite_r+0x138>
80005d7e:	10 99       	mov	r9,r8
80005d80:	e2 19 04 80 	andl	r9,0x480,COH
80005d84:	c4 00       	breq	80005e04 <__sfvwrite_r+0x138>
80005d86:	6e 4b       	ld.w	r11,r7[0x10]
80005d88:	6e 09       	ld.w	r9,r7[0x0]
80005d8a:	16 19       	sub	r9,r11
80005d8c:	50 09       	stdsp	sp[0x0],r9
80005d8e:	6e 59       	ld.w	r9,r7[0x14]
80005d90:	10 9c       	mov	r12,r8
80005d92:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80005d96:	30 28       	mov	r8,2
80005d98:	f4 08 0c 08 	divs	r8,r10,r8
80005d9c:	fa e9 00 04 	st.d	sp[4],r8
80005da0:	10 94       	mov	r4,r8
80005da2:	40 09       	lddsp	r9,sp[0x0]
80005da4:	e2 1c 04 00 	andl	r12,0x400,COH
80005da8:	2f f9       	sub	r9,-1
80005daa:	0c 09       	add	r9,r6
80005dac:	12 38       	cp.w	r8,r9
80005dae:	f2 04 17 30 	movlo	r4,r9
80005db2:	58 0c       	cp.w	r12,0
80005db4:	c1 10       	breq	80005dd6 <__sfvwrite_r+0x10a>
80005db6:	08 9b       	mov	r11,r4
80005db8:	0a 9c       	mov	r12,r5
80005dba:	fe b0 f6 f1 	rcall	80004b9c <_malloc_r>
80005dbe:	18 92       	mov	r2,r12
80005dc0:	c1 40       	breq	80005de8 <__sfvwrite_r+0x11c>
80005dc2:	40 0a       	lddsp	r10,sp[0x0]
80005dc4:	6e 4b       	ld.w	r11,r7[0x10]
80005dc6:	fe b0 f9 07 	rcall	80004fd4 <memcpy>
80005dca:	8e 68       	ld.sh	r8,r7[0xc]
80005dcc:	e0 18 fb 7f 	andl	r8,0xfb7f
80005dd0:	a7 b8       	sbr	r8,0x7
80005dd2:	ae 68       	st.h	r7[0xc],r8
80005dd4:	c0 d8       	rjmp	80005dee <__sfvwrite_r+0x122>
80005dd6:	08 9a       	mov	r10,r4
80005dd8:	0a 9c       	mov	r12,r5
80005dda:	fe b0 f9 db 	rcall	80005190 <_realloc_r>
80005dde:	18 92       	mov	r2,r12
80005de0:	c0 71       	brne	80005dee <__sfvwrite_r+0x122>
80005de2:	6e 4b       	ld.w	r11,r7[0x10]
80005de4:	0a 9c       	mov	r12,r5
80005de6:	ca be       	rcall	80005b3c <_free_r>
80005de8:	30 c8       	mov	r8,12
80005dea:	8b 38       	st.w	r5[0xc],r8
80005dec:	cb 18       	rjmp	80005f4e <__sfvwrite_r+0x282>
80005dee:	40 0a       	lddsp	r10,sp[0x0]
80005df0:	40 09       	lddsp	r9,sp[0x0]
80005df2:	e8 0a 01 0a 	sub	r10,r4,r10
80005df6:	e4 09 00 08 	add	r8,r2,r9
80005dfa:	8f 54       	st.w	r7[0x14],r4
80005dfc:	8f 2a       	st.w	r7[0x8],r10
80005dfe:	8f 08       	st.w	r7[0x0],r8
80005e00:	8f 42       	st.w	r7[0x10],r2
80005e02:	0c 94       	mov	r4,r6
80005e04:	08 36       	cp.w	r6,r4
80005e06:	ec 04 17 30 	movlo	r4,r6
80005e0a:	06 9b       	mov	r11,r3
80005e0c:	08 9a       	mov	r10,r4
80005e0e:	6e 0c       	ld.w	r12,r7[0x0]
80005e10:	cd 9c       	rcall	80005fc2 <memmove>
80005e12:	6e 08       	ld.w	r8,r7[0x0]
80005e14:	08 08       	add	r8,r4
80005e16:	8f 08       	st.w	r7[0x0],r8
80005e18:	6e 28       	ld.w	r8,r7[0x8]
80005e1a:	08 18       	sub	r8,r4
80005e1c:	0c 94       	mov	r4,r6
80005e1e:	8f 28       	st.w	r7[0x8],r8
80005e20:	c2 e8       	rjmp	80005e7c <__sfvwrite_r+0x1b0>
80005e22:	08 36       	cp.w	r6,r4
80005e24:	5f ba       	srhi	r10
80005e26:	6e 0c       	ld.w	r12,r7[0x0]
80005e28:	6e 48       	ld.w	r8,r7[0x10]
80005e2a:	10 3c       	cp.w	r12,r8
80005e2c:	5f b8       	srhi	r8
80005e2e:	f5 e8 00 08 	and	r8,r10,r8
80005e32:	f2 08 18 00 	cp.b	r8,r9
80005e36:	c0 d0       	breq	80005e50 <__sfvwrite_r+0x184>
80005e38:	06 9b       	mov	r11,r3
80005e3a:	08 9a       	mov	r10,r4
80005e3c:	cc 3c       	rcall	80005fc2 <memmove>
80005e3e:	6e 08       	ld.w	r8,r7[0x0]
80005e40:	08 08       	add	r8,r4
80005e42:	0e 9b       	mov	r11,r7
80005e44:	8f 08       	st.w	r7[0x0],r8
80005e46:	0a 9c       	mov	r12,r5
80005e48:	fe b0 fd 02 	rcall	8000584c <_fflush_r>
80005e4c:	c1 80       	breq	80005e7c <__sfvwrite_r+0x1b0>
80005e4e:	c8 08       	rjmp	80005f4e <__sfvwrite_r+0x282>
80005e50:	6e 59       	ld.w	r9,r7[0x14]
80005e52:	12 36       	cp.w	r6,r9
80005e54:	c0 a3       	brcs	80005e68 <__sfvwrite_r+0x19c>
80005e56:	6e a8       	ld.w	r8,r7[0x28]
80005e58:	06 9a       	mov	r10,r3
80005e5a:	6e 8b       	ld.w	r11,r7[0x20]
80005e5c:	0a 9c       	mov	r12,r5
80005e5e:	5d 18       	icall	r8
80005e60:	18 94       	mov	r4,r12
80005e62:	e0 89 00 0d 	brgt	80005e7c <__sfvwrite_r+0x1b0>
80005e66:	c7 48       	rjmp	80005f4e <__sfvwrite_r+0x282>
80005e68:	0c 9a       	mov	r10,r6
80005e6a:	06 9b       	mov	r11,r3
80005e6c:	ca bc       	rcall	80005fc2 <memmove>
80005e6e:	6e 08       	ld.w	r8,r7[0x0]
80005e70:	0c 08       	add	r8,r6
80005e72:	0c 94       	mov	r4,r6
80005e74:	8f 08       	st.w	r7[0x0],r8
80005e76:	6e 28       	ld.w	r8,r7[0x8]
80005e78:	0c 18       	sub	r8,r6
80005e7a:	8f 28       	st.w	r7[0x8],r8
80005e7c:	62 28       	ld.w	r8,r1[0x8]
80005e7e:	08 18       	sub	r8,r4
80005e80:	83 28       	st.w	r1[0x8],r8
80005e82:	c6 b0       	breq	80005f58 <__sfvwrite_r+0x28c>
80005e84:	08 16       	sub	r6,r4
80005e86:	08 03       	add	r3,r4
80005e88:	c7 1b       	rjmp	80005d6a <__sfvwrite_r+0x9e>
80005e8a:	60 03       	ld.w	r3,r0[0x0]
80005e8c:	60 11       	ld.w	r1,r0[0x4]
80005e8e:	30 08       	mov	r8,0
80005e90:	2f 80       	sub	r0,-8
80005e92:	50 08       	stdsp	sp[0x0],r8
80005e94:	58 01       	cp.w	r1,0
80005e96:	cf a0       	breq	80005e8a <__sfvwrite_r+0x1be>
80005e98:	40 0a       	lddsp	r10,sp[0x0]
80005e9a:	58 0a       	cp.w	r10,0
80005e9c:	c1 41       	brne	80005ec4 <__sfvwrite_r+0x1f8>
80005e9e:	e2 c6 ff ff 	sub	r6,r1,-1
80005ea2:	02 9a       	mov	r10,r1
80005ea4:	30 ab       	mov	r11,10
80005ea6:	06 9c       	mov	r12,r3
80005ea8:	c8 2c       	rcall	80005fac <memchr>
80005eaa:	f8 c8 ff ff 	sub	r8,r12,-1
80005eae:	58 0c       	cp.w	r12,0
80005eb0:	f1 d3 e1 16 	subne	r6,r8,r3
80005eb4:	f9 b9 01 01 	movne	r9,1
80005eb8:	fb f9 1a 00 	st.wne	sp[0x0],r9
80005ebc:	f9 b8 00 01 	moveq	r8,1
80005ec0:	fb f8 0a 00 	st.weq	sp[0x0],r8
80005ec4:	02 36       	cp.w	r6,r1
80005ec6:	ec 04 17 80 	movls	r4,r6
80005eca:	e2 04 17 b0 	movhi	r4,r1
80005ece:	6e 59       	ld.w	r9,r7[0x14]
80005ed0:	6e 25       	ld.w	r5,r7[0x8]
80005ed2:	f2 05 00 05 	add	r5,r9,r5
80005ed6:	0a 34       	cp.w	r4,r5
80005ed8:	5f 9a       	srgt	r10
80005eda:	6e 0c       	ld.w	r12,r7[0x0]
80005edc:	6e 48       	ld.w	r8,r7[0x10]
80005ede:	10 3c       	cp.w	r12,r8
80005ee0:	5f b8       	srhi	r8
80005ee2:	f5 e8 00 08 	and	r8,r10,r8
80005ee6:	30 0a       	mov	r10,0
80005ee8:	f4 08 18 00 	cp.b	r8,r10
80005eec:	c0 d0       	breq	80005f06 <__sfvwrite_r+0x23a>
80005eee:	06 9b       	mov	r11,r3
80005ef0:	0a 9a       	mov	r10,r5
80005ef2:	c6 8c       	rcall	80005fc2 <memmove>
80005ef4:	6e 08       	ld.w	r8,r7[0x0]
80005ef6:	0a 08       	add	r8,r5
80005ef8:	0e 9b       	mov	r11,r7
80005efa:	8f 08       	st.w	r7[0x0],r8
80005efc:	40 1c       	lddsp	r12,sp[0x4]
80005efe:	fe b0 fc a7 	rcall	8000584c <_fflush_r>
80005f02:	c1 70       	breq	80005f30 <__sfvwrite_r+0x264>
80005f04:	c2 58       	rjmp	80005f4e <__sfvwrite_r+0x282>
80005f06:	12 34       	cp.w	r4,r9
80005f08:	c0 a5       	brlt	80005f1c <__sfvwrite_r+0x250>
80005f0a:	6e a8       	ld.w	r8,r7[0x28]
80005f0c:	06 9a       	mov	r10,r3
80005f0e:	6e 8b       	ld.w	r11,r7[0x20]
80005f10:	40 1c       	lddsp	r12,sp[0x4]
80005f12:	5d 18       	icall	r8
80005f14:	18 95       	mov	r5,r12
80005f16:	e0 89 00 0d 	brgt	80005f30 <__sfvwrite_r+0x264>
80005f1a:	c1 a8       	rjmp	80005f4e <__sfvwrite_r+0x282>
80005f1c:	08 9a       	mov	r10,r4
80005f1e:	06 9b       	mov	r11,r3
80005f20:	c5 1c       	rcall	80005fc2 <memmove>
80005f22:	6e 08       	ld.w	r8,r7[0x0]
80005f24:	08 08       	add	r8,r4
80005f26:	08 95       	mov	r5,r4
80005f28:	8f 08       	st.w	r7[0x0],r8
80005f2a:	6e 28       	ld.w	r8,r7[0x8]
80005f2c:	08 18       	sub	r8,r4
80005f2e:	8f 28       	st.w	r7[0x8],r8
80005f30:	0a 16       	sub	r6,r5
80005f32:	c0 71       	brne	80005f40 <__sfvwrite_r+0x274>
80005f34:	0e 9b       	mov	r11,r7
80005f36:	40 1c       	lddsp	r12,sp[0x4]
80005f38:	fe b0 fc 8a 	rcall	8000584c <_fflush_r>
80005f3c:	c0 91       	brne	80005f4e <__sfvwrite_r+0x282>
80005f3e:	50 06       	stdsp	sp[0x0],r6
80005f40:	64 28       	ld.w	r8,r2[0x8]
80005f42:	0a 18       	sub	r8,r5
80005f44:	85 28       	st.w	r2[0x8],r8
80005f46:	c0 90       	breq	80005f58 <__sfvwrite_r+0x28c>
80005f48:	0a 11       	sub	r1,r5
80005f4a:	0a 03       	add	r3,r5
80005f4c:	ca 4b       	rjmp	80005e94 <__sfvwrite_r+0x1c8>
80005f4e:	8e 68       	ld.sh	r8,r7[0xc]
80005f50:	a7 a8       	sbr	r8,0x6
80005f52:	ae 68       	st.h	r7[0xc],r8
80005f54:	3f fc       	mov	r12,-1
80005f56:	c0 28       	rjmp	80005f5a <__sfvwrite_r+0x28e>
80005f58:	30 0c       	mov	r12,0
80005f5a:	2f dd       	sub	sp,-12
80005f5c:	d8 32       	popm	r0-r7,pc
80005f5e:	d7 03       	nop

80005f60 <_fwalk>:
80005f60:	d4 31       	pushm	r0-r7,lr
80005f62:	30 05       	mov	r5,0
80005f64:	16 91       	mov	r1,r11
80005f66:	f8 c7 ff 28 	sub	r7,r12,-216
80005f6a:	0a 92       	mov	r2,r5
80005f6c:	fe b0 fc f8 	rcall	8000595c <__sfp_lock_acquire>
80005f70:	3f f3       	mov	r3,-1
80005f72:	c1 68       	rjmp	80005f9e <_fwalk+0x3e>
80005f74:	6e 26       	ld.w	r6,r7[0x8]
80005f76:	6e 14       	ld.w	r4,r7[0x4]
80005f78:	2f 46       	sub	r6,-12
80005f7a:	c0 c8       	rjmp	80005f92 <_fwalk+0x32>
80005f7c:	8c 08       	ld.sh	r8,r6[0x0]
80005f7e:	e4 08 19 00 	cp.h	r8,r2
80005f82:	c0 70       	breq	80005f90 <_fwalk+0x30>
80005f84:	8c 18       	ld.sh	r8,r6[0x2]
80005f86:	e6 08 19 00 	cp.h	r8,r3
80005f8a:	c0 30       	breq	80005f90 <_fwalk+0x30>
80005f8c:	5d 11       	icall	r1
80005f8e:	18 45       	or	r5,r12
80005f90:	2a 46       	sub	r6,-92
80005f92:	20 14       	sub	r4,1
80005f94:	ec cc 00 0c 	sub	r12,r6,12
80005f98:	58 04       	cp.w	r4,0
80005f9a:	cf 14       	brge	80005f7c <_fwalk+0x1c>
80005f9c:	6e 07       	ld.w	r7,r7[0x0]
80005f9e:	58 07       	cp.w	r7,0
80005fa0:	ce a1       	brne	80005f74 <_fwalk+0x14>
80005fa2:	fe b0 fc de 	rcall	8000595e <__sfp_lock_release>
80005fa6:	0a 9c       	mov	r12,r5
80005fa8:	d8 32       	popm	r0-r7,pc
80005faa:	d7 03       	nop

80005fac <memchr>:
80005fac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80005fb0:	c0 68       	rjmp	80005fbc <memchr+0x10>
80005fb2:	20 1a       	sub	r10,1
80005fb4:	19 88       	ld.ub	r8,r12[0x0]
80005fb6:	16 38       	cp.w	r8,r11
80005fb8:	5e 0c       	reteq	r12
80005fba:	2f fc       	sub	r12,-1
80005fbc:	58 0a       	cp.w	r10,0
80005fbe:	cf a1       	brne	80005fb2 <memchr+0x6>
80005fc0:	5e fa       	retal	r10

80005fc2 <memmove>:
80005fc2:	d4 01       	pushm	lr
80005fc4:	18 3b       	cp.w	r11,r12
80005fc6:	c1 92       	brcc	80005ff8 <memmove+0x36>
80005fc8:	f6 0a 00 09 	add	r9,r11,r10
80005fcc:	12 3c       	cp.w	r12,r9
80005fce:	c1 52       	brcc	80005ff8 <memmove+0x36>
80005fd0:	f8 0a 00 0b 	add	r11,r12,r10
80005fd4:	30 08       	mov	r8,0
80005fd6:	c0 68       	rjmp	80005fe2 <memmove+0x20>
80005fd8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80005fdc:	20 1a       	sub	r10,1
80005fde:	f6 08 0b 0e 	st.b	r11[r8],lr
80005fe2:	20 18       	sub	r8,1
80005fe4:	58 0a       	cp.w	r10,0
80005fe6:	cf 91       	brne	80005fd8 <memmove+0x16>
80005fe8:	d8 02       	popm	pc
80005fea:	f6 08 07 09 	ld.ub	r9,r11[r8]
80005fee:	20 1a       	sub	r10,1
80005ff0:	f8 08 0b 09 	st.b	r12[r8],r9
80005ff4:	2f f8       	sub	r8,-1
80005ff6:	c0 28       	rjmp	80005ffa <memmove+0x38>
80005ff8:	30 08       	mov	r8,0
80005ffa:	58 0a       	cp.w	r10,0
80005ffc:	cf 71       	brne	80005fea <memmove+0x28>
80005ffe:	d8 02       	popm	pc

80006000 <__sclose>:
80006000:	d4 01       	pushm	lr
80006002:	96 7b       	ld.sh	r11,r11[0xe]
80006004:	cb 8c       	rcall	80006174 <_close_r>
80006006:	d8 02       	popm	pc

80006008 <__sseek>:
80006008:	d4 21       	pushm	r4-r7,lr
8000600a:	16 97       	mov	r7,r11
8000600c:	96 7b       	ld.sh	r11,r11[0xe]
8000600e:	c2 bd       	rcall	80006264 <_lseek_r>
80006010:	8e 68       	ld.sh	r8,r7[0xc]
80006012:	10 99       	mov	r9,r8
80006014:	ad c8       	cbr	r8,0xc
80006016:	ad a9       	sbr	r9,0xc
80006018:	5b fc       	cp.w	r12,-1
8000601a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000601e:	ef f9 1c 06 	st.hne	r7[0xc],r9
80006022:	ef fc 1a 15 	st.wne	r7[0x54],r12
80006026:	d8 22       	popm	r4-r7,pc

80006028 <__swrite>:
80006028:	d4 21       	pushm	r4-r7,lr
8000602a:	96 68       	ld.sh	r8,r11[0xc]
8000602c:	16 97       	mov	r7,r11
8000602e:	14 95       	mov	r5,r10
80006030:	12 94       	mov	r4,r9
80006032:	e2 18 01 00 	andl	r8,0x100,COH
80006036:	18 96       	mov	r6,r12
80006038:	c0 50       	breq	80006042 <__swrite+0x1a>
8000603a:	30 29       	mov	r9,2
8000603c:	30 0a       	mov	r10,0
8000603e:	96 7b       	ld.sh	r11,r11[0xe]
80006040:	c1 2d       	rcall	80006264 <_lseek_r>
80006042:	8e 68       	ld.sh	r8,r7[0xc]
80006044:	ad c8       	cbr	r8,0xc
80006046:	08 99       	mov	r9,r4
80006048:	0a 9a       	mov	r10,r5
8000604a:	8e 7b       	ld.sh	r11,r7[0xe]
8000604c:	0c 9c       	mov	r12,r6
8000604e:	ae 68       	st.h	r7[0xc],r8
80006050:	c1 0c       	rcall	80006070 <_write_r>
80006052:	d8 22       	popm	r4-r7,pc

80006054 <__sread>:
80006054:	d4 21       	pushm	r4-r7,lr
80006056:	16 97       	mov	r7,r11
80006058:	96 7b       	ld.sh	r11,r11[0xe]
8000605a:	c7 7d       	rcall	80006348 <_read_r>
8000605c:	c0 65       	brlt	80006068 <__sread+0x14>
8000605e:	6f 58       	ld.w	r8,r7[0x54]
80006060:	18 08       	add	r8,r12
80006062:	ef 48 00 54 	st.w	r7[84],r8
80006066:	d8 22       	popm	r4-r7,pc
80006068:	8e 68       	ld.sh	r8,r7[0xc]
8000606a:	ad c8       	cbr	r8,0xc
8000606c:	ae 68       	st.h	r7[0xc],r8
8000606e:	d8 22       	popm	r4-r7,pc

80006070 <_write_r>:
80006070:	d4 21       	pushm	r4-r7,lr
80006072:	16 98       	mov	r8,r11
80006074:	18 97       	mov	r7,r12
80006076:	10 9c       	mov	r12,r8
80006078:	30 08       	mov	r8,0
8000607a:	14 9b       	mov	r11,r10
8000607c:	48 66       	lddpc	r6,80006094 <_write_r+0x24>
8000607e:	12 9a       	mov	r10,r9
80006080:	8d 08       	st.w	r6[0x0],r8
80006082:	fe b0 ef b1 	rcall	80003fe4 <_write>
80006086:	5b fc       	cp.w	r12,-1
80006088:	c0 51       	brne	80006092 <_write_r+0x22>
8000608a:	6c 08       	ld.w	r8,r6[0x0]
8000608c:	58 08       	cp.w	r8,0
8000608e:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006092:	d8 22       	popm	r4-r7,pc
80006094:	00 00       	add	r0,r0
80006096:	0a 38       	cp.w	r8,r5

80006098 <__swsetup_r>:
80006098:	d4 21       	pushm	r4-r7,lr
8000609a:	4b 38       	lddpc	r8,80006164 <__swsetup_r+0xcc>
8000609c:	18 96       	mov	r6,r12
8000609e:	16 97       	mov	r7,r11
800060a0:	70 0c       	ld.w	r12,r8[0x0]
800060a2:	58 0c       	cp.w	r12,0
800060a4:	c0 60       	breq	800060b0 <__swsetup_r+0x18>
800060a6:	78 68       	ld.w	r8,r12[0x18]
800060a8:	58 08       	cp.w	r8,0
800060aa:	c0 31       	brne	800060b0 <__swsetup_r+0x18>
800060ac:	fe b0 fc ac 	rcall	80005a04 <__sinit>
800060b0:	4a e8       	lddpc	r8,80006168 <__swsetup_r+0xd0>
800060b2:	10 37       	cp.w	r7,r8
800060b4:	c0 51       	brne	800060be <__swsetup_r+0x26>
800060b6:	4a c8       	lddpc	r8,80006164 <__swsetup_r+0xcc>
800060b8:	70 08       	ld.w	r8,r8[0x0]
800060ba:	70 07       	ld.w	r7,r8[0x0]
800060bc:	c0 e8       	rjmp	800060d8 <__swsetup_r+0x40>
800060be:	4a c8       	lddpc	r8,8000616c <__swsetup_r+0xd4>
800060c0:	10 37       	cp.w	r7,r8
800060c2:	c0 51       	brne	800060cc <__swsetup_r+0x34>
800060c4:	4a 88       	lddpc	r8,80006164 <__swsetup_r+0xcc>
800060c6:	70 08       	ld.w	r8,r8[0x0]
800060c8:	70 17       	ld.w	r7,r8[0x4]
800060ca:	c0 78       	rjmp	800060d8 <__swsetup_r+0x40>
800060cc:	4a 98       	lddpc	r8,80006170 <__swsetup_r+0xd8>
800060ce:	10 37       	cp.w	r7,r8
800060d0:	c0 41       	brne	800060d8 <__swsetup_r+0x40>
800060d2:	4a 58       	lddpc	r8,80006164 <__swsetup_r+0xcc>
800060d4:	70 08       	ld.w	r8,r8[0x0]
800060d6:	70 27       	ld.w	r7,r8[0x8]
800060d8:	8e 68       	ld.sh	r8,r7[0xc]
800060da:	ed b8 00 03 	bld	r8,0x3
800060de:	c1 e0       	breq	8000611a <__swsetup_r+0x82>
800060e0:	ed b8 00 04 	bld	r8,0x4
800060e4:	c3 d1       	brne	8000615e <__swsetup_r+0xc6>
800060e6:	ed b8 00 02 	bld	r8,0x2
800060ea:	c1 51       	brne	80006114 <__swsetup_r+0x7c>
800060ec:	6e db       	ld.w	r11,r7[0x34]
800060ee:	58 0b       	cp.w	r11,0
800060f0:	c0 a0       	breq	80006104 <__swsetup_r+0x6c>
800060f2:	ee c8 ff bc 	sub	r8,r7,-68
800060f6:	10 3b       	cp.w	r11,r8
800060f8:	c0 40       	breq	80006100 <__swsetup_r+0x68>
800060fa:	0c 9c       	mov	r12,r6
800060fc:	fe b0 fd 20 	rcall	80005b3c <_free_r>
80006100:	30 08       	mov	r8,0
80006102:	8f d8       	st.w	r7[0x34],r8
80006104:	8e 68       	ld.sh	r8,r7[0xc]
80006106:	e0 18 ff db 	andl	r8,0xffdb
8000610a:	ae 68       	st.h	r7[0xc],r8
8000610c:	30 08       	mov	r8,0
8000610e:	8f 18       	st.w	r7[0x4],r8
80006110:	6e 48       	ld.w	r8,r7[0x10]
80006112:	8f 08       	st.w	r7[0x0],r8
80006114:	8e 68       	ld.sh	r8,r7[0xc]
80006116:	a3 b8       	sbr	r8,0x3
80006118:	ae 68       	st.h	r7[0xc],r8
8000611a:	6e 48       	ld.w	r8,r7[0x10]
8000611c:	58 08       	cp.w	r8,0
8000611e:	c0 a1       	brne	80006132 <__swsetup_r+0x9a>
80006120:	8e 68       	ld.sh	r8,r7[0xc]
80006122:	e2 18 02 80 	andl	r8,0x280,COH
80006126:	e0 48 02 00 	cp.w	r8,512
8000612a:	c0 40       	breq	80006132 <__swsetup_r+0x9a>
8000612c:	0c 9c       	mov	r12,r6
8000612e:	0e 9b       	mov	r11,r7
80006130:	ca ec       	rcall	8000628c <__smakebuf_r>
80006132:	8e 69       	ld.sh	r9,r7[0xc]
80006134:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80006138:	c0 70       	breq	80006146 <__swsetup_r+0xae>
8000613a:	30 08       	mov	r8,0
8000613c:	8f 28       	st.w	r7[0x8],r8
8000613e:	6e 58       	ld.w	r8,r7[0x14]
80006140:	5c 38       	neg	r8
80006142:	8f 68       	st.w	r7[0x18],r8
80006144:	c0 68       	rjmp	80006150 <__swsetup_r+0xb8>
80006146:	ed b9 00 01 	bld	r9,0x1
8000614a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000614e:	8f 28       	st.w	r7[0x8],r8
80006150:	6e 48       	ld.w	r8,r7[0x10]
80006152:	58 08       	cp.w	r8,0
80006154:	c0 61       	brne	80006160 <__swsetup_r+0xc8>
80006156:	8e 68       	ld.sh	r8,r7[0xc]
80006158:	ed b8 00 07 	bld	r8,0x7
8000615c:	c0 21       	brne	80006160 <__swsetup_r+0xc8>
8000615e:	dc 2a       	popm	r4-r7,pc,r12=-1
80006160:	d8 2a       	popm	r4-r7,pc,r12=0
80006162:	d7 03       	nop
80006164:	00 00       	add	r0,r0
80006166:	01 e0       	ld.ub	r0,r0[0x6]
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	67 28       	ld.w	r8,r3[0x48]
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	67 48       	ld.w	r8,r3[0x50]
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	67 68       	ld.w	r8,r3[0x58]

80006174 <_close_r>:
80006174:	d4 21       	pushm	r4-r7,lr
80006176:	30 08       	mov	r8,0
80006178:	18 97       	mov	r7,r12
8000617a:	48 76       	lddpc	r6,80006194 <_close_r+0x20>
8000617c:	16 9c       	mov	r12,r11
8000617e:	8d 08       	st.w	r6[0x0],r8
80006180:	fe b0 fa 30 	rcall	800055e0 <_close>
80006184:	5b fc       	cp.w	r12,-1
80006186:	c0 51       	brne	80006190 <_close_r+0x1c>
80006188:	6c 08       	ld.w	r8,r6[0x0]
8000618a:	58 08       	cp.w	r8,0
8000618c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006190:	d8 22       	popm	r4-r7,pc
80006192:	d7 03       	nop
80006194:	00 00       	add	r0,r0
80006196:	0a 38       	cp.w	r8,r5

80006198 <_fclose_r>:
80006198:	d4 21       	pushm	r4-r7,lr
8000619a:	18 96       	mov	r6,r12
8000619c:	16 97       	mov	r7,r11
8000619e:	58 0b       	cp.w	r11,0
800061a0:	c0 31       	brne	800061a6 <_fclose_r+0xe>
800061a2:	16 95       	mov	r5,r11
800061a4:	c5 08       	rjmp	80006244 <_fclose_r+0xac>
800061a6:	fe b0 fb db 	rcall	8000595c <__sfp_lock_acquire>
800061aa:	58 06       	cp.w	r6,0
800061ac:	c0 70       	breq	800061ba <_fclose_r+0x22>
800061ae:	6c 68       	ld.w	r8,r6[0x18]
800061b0:	58 08       	cp.w	r8,0
800061b2:	c0 41       	brne	800061ba <_fclose_r+0x22>
800061b4:	0c 9c       	mov	r12,r6
800061b6:	fe b0 fc 27 	rcall	80005a04 <__sinit>
800061ba:	4a 48       	lddpc	r8,80006248 <_fclose_r+0xb0>
800061bc:	10 37       	cp.w	r7,r8
800061be:	c0 31       	brne	800061c4 <_fclose_r+0x2c>
800061c0:	6c 07       	ld.w	r7,r6[0x0]
800061c2:	c0 a8       	rjmp	800061d6 <_fclose_r+0x3e>
800061c4:	4a 28       	lddpc	r8,8000624c <_fclose_r+0xb4>
800061c6:	10 37       	cp.w	r7,r8
800061c8:	c0 31       	brne	800061ce <_fclose_r+0x36>
800061ca:	6c 17       	ld.w	r7,r6[0x4]
800061cc:	c0 58       	rjmp	800061d6 <_fclose_r+0x3e>
800061ce:	4a 18       	lddpc	r8,80006250 <_fclose_r+0xb8>
800061d0:	10 37       	cp.w	r7,r8
800061d2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800061d6:	8e 69       	ld.sh	r9,r7[0xc]
800061d8:	30 08       	mov	r8,0
800061da:	f0 09 19 00 	cp.h	r9,r8
800061de:	c0 51       	brne	800061e8 <_fclose_r+0x50>
800061e0:	fe b0 fb bf 	rcall	8000595e <__sfp_lock_release>
800061e4:	30 05       	mov	r5,0
800061e6:	c2 f8       	rjmp	80006244 <_fclose_r+0xac>
800061e8:	0e 9b       	mov	r11,r7
800061ea:	0c 9c       	mov	r12,r6
800061ec:	fe b0 fb 30 	rcall	8000584c <_fflush_r>
800061f0:	6e c8       	ld.w	r8,r7[0x30]
800061f2:	18 95       	mov	r5,r12
800061f4:	58 08       	cp.w	r8,0
800061f6:	c0 60       	breq	80006202 <_fclose_r+0x6a>
800061f8:	6e 8b       	ld.w	r11,r7[0x20]
800061fa:	0c 9c       	mov	r12,r6
800061fc:	5d 18       	icall	r8
800061fe:	f9 b5 05 ff 	movlt	r5,-1
80006202:	8e 68       	ld.sh	r8,r7[0xc]
80006204:	ed b8 00 07 	bld	r8,0x7
80006208:	c0 51       	brne	80006212 <_fclose_r+0x7a>
8000620a:	6e 4b       	ld.w	r11,r7[0x10]
8000620c:	0c 9c       	mov	r12,r6
8000620e:	fe b0 fc 97 	rcall	80005b3c <_free_r>
80006212:	6e db       	ld.w	r11,r7[0x34]
80006214:	58 0b       	cp.w	r11,0
80006216:	c0 a0       	breq	8000622a <_fclose_r+0x92>
80006218:	ee c8 ff bc 	sub	r8,r7,-68
8000621c:	10 3b       	cp.w	r11,r8
8000621e:	c0 40       	breq	80006226 <_fclose_r+0x8e>
80006220:	0c 9c       	mov	r12,r6
80006222:	fe b0 fc 8d 	rcall	80005b3c <_free_r>
80006226:	30 08       	mov	r8,0
80006228:	8f d8       	st.w	r7[0x34],r8
8000622a:	6f 2b       	ld.w	r11,r7[0x48]
8000622c:	58 0b       	cp.w	r11,0
8000622e:	c0 70       	breq	8000623c <_fclose_r+0xa4>
80006230:	0c 9c       	mov	r12,r6
80006232:	fe b0 fc 85 	rcall	80005b3c <_free_r>
80006236:	30 08       	mov	r8,0
80006238:	ef 48 00 48 	st.w	r7[72],r8
8000623c:	30 08       	mov	r8,0
8000623e:	ae 68       	st.h	r7[0xc],r8
80006240:	fe b0 fb 8f 	rcall	8000595e <__sfp_lock_release>
80006244:	0a 9c       	mov	r12,r5
80006246:	d8 22       	popm	r4-r7,pc
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	67 28       	ld.w	r8,r3[0x48]
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	67 48       	ld.w	r8,r3[0x50]
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	67 68       	ld.w	r8,r3[0x58]

80006254 <fclose>:
80006254:	d4 01       	pushm	lr
80006256:	48 38       	lddpc	r8,80006260 <fclose+0xc>
80006258:	18 9b       	mov	r11,r12
8000625a:	70 0c       	ld.w	r12,r8[0x0]
8000625c:	c9 ef       	rcall	80006198 <_fclose_r>
8000625e:	d8 02       	popm	pc
80006260:	00 00       	add	r0,r0
80006262:	01 e0       	ld.ub	r0,r0[0x6]

80006264 <_lseek_r>:
80006264:	d4 21       	pushm	r4-r7,lr
80006266:	16 98       	mov	r8,r11
80006268:	18 97       	mov	r7,r12
8000626a:	10 9c       	mov	r12,r8
8000626c:	30 08       	mov	r8,0
8000626e:	14 9b       	mov	r11,r10
80006270:	48 66       	lddpc	r6,80006288 <_lseek_r+0x24>
80006272:	12 9a       	mov	r10,r9
80006274:	8d 08       	st.w	r6[0x0],r8
80006276:	fe b0 f9 c1 	rcall	800055f8 <_lseek>
8000627a:	5b fc       	cp.w	r12,-1
8000627c:	c0 51       	brne	80006286 <_lseek_r+0x22>
8000627e:	6c 08       	ld.w	r8,r6[0x0]
80006280:	58 08       	cp.w	r8,0
80006282:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006286:	d8 22       	popm	r4-r7,pc
80006288:	00 00       	add	r0,r0
8000628a:	0a 38       	cp.w	r8,r5

8000628c <__smakebuf_r>:
8000628c:	d4 21       	pushm	r4-r7,lr
8000628e:	20 fd       	sub	sp,60
80006290:	96 68       	ld.sh	r8,r11[0xc]
80006292:	16 97       	mov	r7,r11
80006294:	18 96       	mov	r6,r12
80006296:	e2 18 00 02 	andl	r8,0x2,COH
8000629a:	c3 c1       	brne	80006312 <__smakebuf_r+0x86>
8000629c:	96 7b       	ld.sh	r11,r11[0xe]
8000629e:	f0 0b 19 00 	cp.h	r11,r8
800062a2:	c0 45       	brlt	800062aa <__smakebuf_r+0x1e>
800062a4:	1a 9a       	mov	r10,sp
800062a6:	c6 5c       	rcall	80006370 <_fstat_r>
800062a8:	c0 f4       	brge	800062c6 <__smakebuf_r+0x3a>
800062aa:	8e 65       	ld.sh	r5,r7[0xc]
800062ac:	0a 98       	mov	r8,r5
800062ae:	ab b8       	sbr	r8,0xb
800062b0:	e2 15 00 80 	andl	r5,0x80,COH
800062b4:	ae 68       	st.h	r7[0xc],r8
800062b6:	30 04       	mov	r4,0
800062b8:	e0 68 04 00 	mov	r8,1024
800062bc:	f9 b5 01 40 	movne	r5,64
800062c0:	f0 05 17 00 	moveq	r5,r8
800062c4:	c1 c8       	rjmp	800062fc <__smakebuf_r+0x70>
800062c6:	40 18       	lddsp	r8,sp[0x4]
800062c8:	e2 18 f0 00 	andl	r8,0xf000,COH
800062cc:	e0 48 20 00 	cp.w	r8,8192
800062d0:	5f 04       	sreq	r4
800062d2:	e0 48 80 00 	cp.w	r8,32768
800062d6:	c0 e1       	brne	800062f2 <__smakebuf_r+0x66>
800062d8:	6e b9       	ld.w	r9,r7[0x2c]
800062da:	fe c8 02 d2 	sub	r8,pc,722
800062de:	10 39       	cp.w	r9,r8
800062e0:	c0 91       	brne	800062f2 <__smakebuf_r+0x66>
800062e2:	8e 68       	ld.sh	r8,r7[0xc]
800062e4:	e0 65 04 00 	mov	r5,1024
800062e8:	ab a8       	sbr	r8,0xa
800062ea:	ef 45 00 50 	st.w	r7[80],r5
800062ee:	ae 68       	st.h	r7[0xc],r8
800062f0:	c0 68       	rjmp	800062fc <__smakebuf_r+0x70>
800062f2:	8e 68       	ld.sh	r8,r7[0xc]
800062f4:	e0 65 04 00 	mov	r5,1024
800062f8:	ab b8       	sbr	r8,0xb
800062fa:	ae 68       	st.h	r7[0xc],r8
800062fc:	0a 9b       	mov	r11,r5
800062fe:	0c 9c       	mov	r12,r6
80006300:	fe b0 f4 4e 	rcall	80004b9c <_malloc_r>
80006304:	8e 68       	ld.sh	r8,r7[0xc]
80006306:	c0 d1       	brne	80006320 <__smakebuf_r+0x94>
80006308:	ed b8 00 09 	bld	r8,0x9
8000630c:	c1 b0       	breq	80006342 <__smakebuf_r+0xb6>
8000630e:	a1 b8       	sbr	r8,0x1
80006310:	ae 68       	st.h	r7[0xc],r8
80006312:	ee c8 ff b9 	sub	r8,r7,-71
80006316:	8f 48       	st.w	r7[0x10],r8
80006318:	8f 08       	st.w	r7[0x0],r8
8000631a:	30 18       	mov	r8,1
8000631c:	8f 58       	st.w	r7[0x14],r8
8000631e:	c1 28       	rjmp	80006342 <__smakebuf_r+0xb6>
80006320:	a7 b8       	sbr	r8,0x7
80006322:	8f 4c       	st.w	r7[0x10],r12
80006324:	ae 68       	st.h	r7[0xc],r8
80006326:	8f 55       	st.w	r7[0x14],r5
80006328:	fe c8 09 c8 	sub	r8,pc,2504
8000632c:	8f 0c       	st.w	r7[0x0],r12
8000632e:	8d a8       	st.w	r6[0x28],r8
80006330:	58 04       	cp.w	r4,0
80006332:	c0 80       	breq	80006342 <__smakebuf_r+0xb6>
80006334:	8e 7c       	ld.sh	r12,r7[0xe]
80006336:	fe b0 f9 6d 	rcall	80005610 <isatty>
8000633a:	c0 40       	breq	80006342 <__smakebuf_r+0xb6>
8000633c:	8e 68       	ld.sh	r8,r7[0xc]
8000633e:	a1 a8       	sbr	r8,0x0
80006340:	ae 68       	st.h	r7[0xc],r8
80006342:	2f 1d       	sub	sp,-60
80006344:	d8 22       	popm	r4-r7,pc
80006346:	d7 03       	nop

80006348 <_read_r>:
80006348:	d4 21       	pushm	r4-r7,lr
8000634a:	16 98       	mov	r8,r11
8000634c:	18 97       	mov	r7,r12
8000634e:	10 9c       	mov	r12,r8
80006350:	30 08       	mov	r8,0
80006352:	14 9b       	mov	r11,r10
80006354:	48 66       	lddpc	r6,8000636c <_read_r+0x24>
80006356:	12 9a       	mov	r10,r9
80006358:	8d 08       	st.w	r6[0x0],r8
8000635a:	fe b0 ed b7 	rcall	80003ec8 <_read>
8000635e:	5b fc       	cp.w	r12,-1
80006360:	c0 51       	brne	8000636a <_read_r+0x22>
80006362:	6c 08       	ld.w	r8,r6[0x0]
80006364:	58 08       	cp.w	r8,0
80006366:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000636a:	d8 22       	popm	r4-r7,pc
8000636c:	00 00       	add	r0,r0
8000636e:	0a 38       	cp.w	r8,r5

80006370 <_fstat_r>:
80006370:	d4 21       	pushm	r4-r7,lr
80006372:	16 98       	mov	r8,r11
80006374:	18 97       	mov	r7,r12
80006376:	10 9c       	mov	r12,r8
80006378:	30 08       	mov	r8,0
8000637a:	48 76       	lddpc	r6,80006394 <_fstat_r+0x24>
8000637c:	14 9b       	mov	r11,r10
8000637e:	8d 08       	st.w	r6[0x0],r8
80006380:	fe b0 f9 60 	rcall	80005640 <_fstat>
80006384:	5b fc       	cp.w	r12,-1
80006386:	c0 51       	brne	80006390 <_fstat_r+0x20>
80006388:	6c 08       	ld.w	r8,r6[0x0]
8000638a:	58 08       	cp.w	r8,0
8000638c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006390:	d8 22       	popm	r4-r7,pc
80006392:	d7 03       	nop
80006394:	00 00       	add	r0,r0
80006396:	0a 38       	cp.w	r8,r5

80006398 <__do_global_ctors_aux>:
80006398:	d4 21       	pushm	r4-r7,lr
8000639a:	48 57       	lddpc	r7,800063ac <__do_global_ctors_aux+0x14>
8000639c:	c0 28       	rjmp	800063a0 <__do_global_ctors_aux+0x8>
8000639e:	5d 18       	icall	r8
800063a0:	20 47       	sub	r7,4
800063a2:	6e 08       	ld.w	r8,r7[0x0]
800063a4:	5b f8       	cp.w	r8,-1
800063a6:	cf c1       	brne	8000639e <__do_global_ctors_aux+0x6>
800063a8:	d8 22       	popm	r4-r7,pc
800063aa:	d7 03       	nop
800063ac:	00 00       	add	r0,r0
800063ae:	00 0c       	add	r12,r0

Disassembly of section .exception:

80006400 <_evba>:
80006400:	c0 08       	rjmp	80006400 <_evba>
	...

80006404 <_handle_TLB_Multiple_Hit>:
80006404:	c0 08       	rjmp	80006404 <_handle_TLB_Multiple_Hit>
	...

80006408 <_handle_Bus_Error_Data_Fetch>:
80006408:	c0 08       	rjmp	80006408 <_handle_Bus_Error_Data_Fetch>
	...

8000640c <_handle_Bus_Error_Instruction_Fetch>:
8000640c:	c0 08       	rjmp	8000640c <_handle_Bus_Error_Instruction_Fetch>
	...

80006410 <_handle_NMI>:
80006410:	c0 08       	rjmp	80006410 <_handle_NMI>
	...

80006414 <_handle_Instruction_Address>:
80006414:	c0 08       	rjmp	80006414 <_handle_Instruction_Address>
	...

80006418 <_handle_ITLB_Protection>:
80006418:	c0 08       	rjmp	80006418 <_handle_ITLB_Protection>
	...

8000641c <_handle_Breakpoint>:
8000641c:	c0 08       	rjmp	8000641c <_handle_Breakpoint>
	...

80006420 <_handle_Illegal_Opcode>:
80006420:	c0 08       	rjmp	80006420 <_handle_Illegal_Opcode>
	...

80006424 <_handle_Unimplemented_Instruction>:
80006424:	c0 08       	rjmp	80006424 <_handle_Unimplemented_Instruction>
	...

80006428 <_handle_Privilege_Violation>:
80006428:	c0 08       	rjmp	80006428 <_handle_Privilege_Violation>
	...

8000642c <_handle_Floating_Point>:
8000642c:	c0 08       	rjmp	8000642c <_handle_Floating_Point>
	...

80006430 <_handle_Coprocessor_Absent>:
80006430:	c0 08       	rjmp	80006430 <_handle_Coprocessor_Absent>
	...

80006434 <_handle_Data_Address_Read>:
80006434:	c0 08       	rjmp	80006434 <_handle_Data_Address_Read>
	...

80006438 <_handle_Data_Address_Write>:
80006438:	c0 08       	rjmp	80006438 <_handle_Data_Address_Write>
	...

8000643c <_handle_DTLB_Protection_Read>:
8000643c:	c0 08       	rjmp	8000643c <_handle_DTLB_Protection_Read>
	...

80006440 <_handle_DTLB_Protection_Write>:
80006440:	c0 08       	rjmp	80006440 <_handle_DTLB_Protection_Write>
	...

80006444 <_handle_DTLB_Modified>:
80006444:	c0 08       	rjmp	80006444 <_handle_DTLB_Modified>
	...

80006450 <_handle_ITLB_Miss>:
80006450:	c0 08       	rjmp	80006450 <_handle_ITLB_Miss>
	...

80006460 <_handle_DTLB_Miss_Read>:
80006460:	c0 08       	rjmp	80006460 <_handle_DTLB_Miss_Read>
	...

80006470 <_handle_DTLB_Miss_Write>:
80006470:	c0 08       	rjmp	80006470 <_handle_DTLB_Miss_Write>
	...

80006500 <_handle_Supervisor_Call>:
80006500:	fe cf 23 4c 	sub	pc,pc,9036

80006504 <_int0>:
80006504:	30 0c       	mov	r12,0
80006506:	fe b0 de d7 	rcall	800022b4 <_get_interrupt_handler>
8000650a:	58 0c       	cp.w	r12,0
8000650c:	f8 0f 17 10 	movne	pc,r12
80006510:	d6 03       	rete

80006512 <_int1>:
80006512:	30 1c       	mov	r12,1
80006514:	fe b0 de d0 	rcall	800022b4 <_get_interrupt_handler>
80006518:	58 0c       	cp.w	r12,0
8000651a:	f8 0f 17 10 	movne	pc,r12
8000651e:	d6 03       	rete

80006520 <_int2>:
80006520:	30 2c       	mov	r12,2
80006522:	fe b0 de c9 	rcall	800022b4 <_get_interrupt_handler>
80006526:	58 0c       	cp.w	r12,0
80006528:	f8 0f 17 10 	movne	pc,r12
8000652c:	d6 03       	rete

8000652e <_int3>:
8000652e:	30 3c       	mov	r12,3
80006530:	fe b0 de c2 	rcall	800022b4 <_get_interrupt_handler>
80006534:	58 0c       	cp.w	r12,0
80006536:	f8 0f 17 10 	movne	pc,r12
8000653a:	d6 03       	rete

8000653c <ipr_val>:
8000653c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000654c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000655c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000656c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000657c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000658c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000659c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800065fc:	d7 03 d7 03                                         ....

Disassembly of section .fini:

80006600 <_fini>:
80006600:	eb cd 40 40 	pushm	r6,lr
80006604:	48 26       	lddpc	r6,8000660c <_fini+0xc>
80006606:	1e 26       	rsub	r6,pc
80006608:	c0 48       	rjmp	80006610 <_fini+0x10>
8000660a:	d7 03       	nop
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	65 ea       	ld.w	r10,r2[0x78]
80006610:	fe b0 dd 3c 	rcall	80002088 <__do_global_dtors_aux>
80006614:	e3 cd 80 40 	ldm	sp++,r6,pc
